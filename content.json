{"pages":[{"title":"About Me","text":"2019.9- Computer Science and Technology, Shandong University.","link":"/about/index.html"}],"posts":[{"title":"DSA：（一）递归","text":"递归的核心部分在于找到目标问题的递归部分和基础部分，本文通过求子集和全排列这两个问题来具体分析递归思想的运用。 P1001:子集价值 算法描述 问题包括两个子问题，求子集和序列价值。 求子集：利用标记数组通过0、1标记对应元素是否在子集中，递归部分为从第一个元素开始依次标记，每个元素位置上的标记包括0和1两种情况，通过递归遍历2^n个子集，基础部分为最后一个元素被标记，子集中的元素全部确定。 求序列价值：当子集中的元素确定时，按照标记数组得到子集数组，若标记位为1，子集数组对应元素设置为原数，同时记录子集长度。然后通过子集数组名和子集长度调用价值函数，求出子集价值，返回至上一层。 C++实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;int value(T* p,int cnt)//求序列的价值{ if(cnt==0) return 0; T sum=0; for(int i=0;i&lt;cnt;i++) { sum+=(i+1)*p[i]; } return sum;}template &lt;class T&gt;int subset(T* p,int* mark,int pos,int cnt)//求子集价值的异或和{ int res=0,res1=0,res2=0; //基础部分 if(pos==cnt) { int curr[cnt];//当前的子集 int size=0; for(int i=0;i&lt;cnt;i++) { if(mark[i]==1)//mark标记位为1，取该元素 curr[size++]=p[i]; } res=value(curr,size); return res; } //递归部分 mark[pos]=0; res1=subset(p,mark,pos+1,cnt); mark[pos]=1; res2=subset(p,mark,pos+1,cnt); return res1^res2;}int main(){ int n,result=0; cin&gt;&gt;n; int input[n],flag[n]; //输入n个非负整数 for(int i=0;i&lt;n;i++) { cin&gt;&gt;input[i]; } result=subset(input,flag,0,n); cout&lt;&lt;result; return 0;} 结果分析 在求n个元素的所有子集价值的异或和的问题中，分析递归调用时res1和res2的意义，res1表示在当前位置的元素标记为0和之前位置元素的标记的约束下，满足约束条件的所有子集价值的异或和，res2表示在当前位置的元素标记为1和之前位置元素的标记的约束下，满足约束条件的所有子集价值的异或和。例如，对于{1,2}这个集合，递归的执行步骤如下： 设置元素1标记位mark[0]=0 调用subset 设置元素2标记位mark[1]=0 调用subset，res1接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 设置元素2标记位mark[1]=1 调用subset，res2接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 返回res1^res2 res1接收返回值，即两个子集价值的异或和 设置元素1标记位mark[0]=1 调用subset 设置元素2标记位mark[1]=0 调用subset，res1接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 设置元素2标记位mark[1]=1 调用subset，res2接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 返回res1^res2 res2接收返回值，即两个子集价值的异或和 返回res1^res2，即4个子集价值的异或和 如果子集函数subset的返回类型设计为void，则需要定义一个全局变量或者在子集函数内部定义一个静态局部变量res来存储子集价值的异或和，每次求出一个子集价值后与res进行异或运算，最后在主函数中直接输出res的结果即可。但是需要注意，在C++中要尽可能少的使用全局变量，所以子集函数的返回类型设计为int更好，通过每一次的值返回可以对递归过程有更深刻的认识。 P1002:全排列问题 算法描述 问题包括两个子问题，求全排列和序列价值。 求全排列：将待求排列的数组分为前缀和后缀，递归部分为通过循环依次将后缀中的每个元素与后缀中的第一个元素交换作为前缀，求剩余后缀的排列，然后复原到交换前的状态。基础部分为后缀仅有一个元素，此时得到一个确定的排列。 求序列价值：当后缀部分仅有一个元素时，此时的排列确定，通过数组名和数组长度调用价值函数，求出子集价值，返回至上一层。 C++实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;int value(T *p,int cnt) //求序列价值{ T sum=0; for(int i=0;i&lt;cnt;i++) { sum+=p[i]^(i+1); } return sum;}template &lt;class T&gt;int permutations(T* list,int k,int m,int cnt) //求所有排列价值的或{ int res=0; //基础部分 if(k==m) //仅有一个排列 { res=value(list,cnt); return res; } //递归部分 else //有多于一个的排列 { for(int i=k;i&lt;=m;i++) { swap(list[k],list[i]); //交换 res|=permutations(list,k+1,m,cnt); swap(list[k],list[i]); //复原 } return res; }}int main(){ int n,result=0; cin&gt;&gt;n; int input[n]; //输入n个非负整数 for(int i=0;i&lt;n;i++) { cin&gt;&gt;input[i]; } result=permutations(input,0,n-1,n); cout&lt;&lt;result; return 0;} 结果分析 在求全排列的过程中，递归部分需要注意在进行后缀的每个元素与后缀的第一个元素的交换后，一定要进行复原。res的意义是在已有前缀的约束下，对后缀进行所有排列的价值的或。 这里求全排列的函数permutations的返回类型也可以设计为void,只不过需要定义一个全局变量res，每次求出排列的价值后与res进行或运算,最后在主函数输出res的结果。这样思路上更简单，但是能不用全局变量最好还是不用。","link":"/2020/10/02/DSA/DSA_1/"},{"title":"DSA：（二）排序","text":"本文讲述四种简单排序算法，名次排序、及时终止的选择排序、及时终止的冒泡排序、插入排序。 P1003:排序算法 算法描述 定义排序类，私有成员包括指向动态数组的指针和数组的大小，公有成员包括构造函数，复制构造函数，析构函数，名次排序，及时终止的选择排序，及时终止的冒泡排序，插入排序，输入、输出函数。 名次排序需要计算出元素在序列的名次，即所有比它小的元素个数加上左侧出现的大小相同的元素个数，然后根据元素的名次进行排序，可以使用附加数组，也可以原地重排。 及时终止的选择排序是每次从无序段中找出最大元素，然后和无序段的末端元素进行交换，继续进行下一次排序。在寻找最大元素的过程中，如果判断出无序段已经有序，即每个元素均小于等于后面的元素，排序及时终止。 及时终止的冒泡排序是比较两个相邻元素的大小，将较大的元素交换至后面，每次冒泡过程可将序列中最大的元素调整到末端。如果在冒泡过程中判断出未进行交换，即任意相邻的两个元素均满足前面的元素小于后面的元素，排序及时终止。 插入排序是从序列中的第2个元素开始到第n个元素，每个元素依次作为被插入元素，在前n-1个元素构成的有序段中按照元素大小寻找合适位置进行插入。在寻找插入位置时，通过从后向前寻找，如果当前位置的元素大于被插入元素，当前位置元素后移一个位置，如果当前位置的元素小于等于被插入元素，则将被插入元素插入到当前元素的后一个位置。如果从前向后寻找插入位置，需要额外声明变量存储数据。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class SORT{private: T* pArray; //保存动态数组 int size; //数组大小public: SORT(int s); //构造函数 SORT(const SORT&lt;T&gt;&amp; S); //复制构造函数 ~SORT(); //析构函数 void rank_sort(); //名次排序 void selection_sort(); //及时终止的选择排序 void bubble_sort(); //及时终止的冒泡排序 void insert_sort(); //插入排序 void input(); //输入 void output(); //输出};template &lt;class T&gt;SORT&lt;T&gt;::SORT(int s) //构造函数{ size=s; pArray=new T[size];}template &lt;class T&gt;SORT&lt;T&gt;::SORT(const SORT&lt;T&gt;&amp; S) //复制构造函数{ size=S.size; pArray=new T[size]; for(int i=0;i&lt;size;i++) { pArray[i]=S.pArray[i]; }}template &lt;class T&gt;SORT&lt;T&gt;::~SORT() //析构函数{ delete []pArray;}template &lt;class T&gt;void SORT&lt;T&gt;::rank_sort()//附加数组的名次排序{ //计算名次 int order[size]; //保存名次的数组 for(int i=0;i&lt;size;i++) //初始化 order[i]=0; for(int i=1;i&lt;size;i++) for(int j=0;j&lt;i;j++) if(pArray[j]&lt;=pArray[i]) order[i]++; else order[j]++; T* temp=new T[size]; //附加数组 for(int i=0;i&lt;size;i++) //按照名次排序 temp[order[i]]=pArray[i]; for(int i=0;i&lt;size;i++) //复制 pArray[i]=temp[i]; delete []temp;}template &lt;class T&gt;void SORT&lt;T&gt;::selection_sort() //及时终止的选择排序{ bool sorted=false; //判断是否有序 for(int pos=size;!sorted &amp;&amp; (pos&gt;1);pos--) { int indexOfMax=0; sorted=true; //每次初始化为有序 //查找最大元素 for(int i=1;i&lt;pos;i++) { if(pArray[indexOfMax]&lt;=pArray[i]) indexOfMax=i; else sorted=false; //无序 } swap(pArray[indexOfMax],pArray[pos-1]); }}template &lt;class T&gt;void SORT&lt;T&gt;::bubble_sort() //及时终止的冒泡排序{ bool sorted=false; //判断是否有序 for(int i=0;i&lt;size-1&amp;&amp;!sorted;i++)//size个数最多进行(size-1)次冒泡 { sorted=true; //每次初始化为有序 for(int j=0;j&lt;size-1-i;j++) { if(pArray[j+1]&lt;pArray[j]) { swap(pArray[j],pArray[j+1]); sorted = false; //发生了交换,仍处于无序状态 } } }}template &lt;class T&gt;void SORT&lt;T&gt;::insert_sort() //插入排序{ for(int i=1;i&lt;size;i++) { T t=pArray[i]; //待插入的元素 int j; for(j=i-1;j&gt;=0 &amp;&amp; t&lt;pArray[j];j--) //寻找插入位置 pArray[j+1]=pArray[j]; pArray[j+1]=t; }}template &lt;class T&gt;void SORT&lt;T&gt;::input() //输入{ for(int i=0;i&lt;size;i++) cin&gt;&gt;pArray[i];}template &lt;class T&gt;void SORT&lt;T&gt;::output() //输出{ for(int i=0;i&lt;size;i++) cout&lt;&lt;pArray[i]&lt;&lt;&quot; &quot;;}int main(){ int n; cin&gt;&gt;n; SORT&lt;int&gt; s(n); //创建对象 s.input(); s.bubble_sort(); s.output(); return 0;} 结果分析 （1）名次排序、冒泡排序、插入排序是稳定的，选择排序是不稳定的。 e.g. 给序列3，1，1排序，首先找出最大元素3，和末端的1交换，序列变为1，1，3，满足及时终止的条件，排序结束，两个1的相对位置发生了变化。 （2）在使用for循环进行次数控制时，要注意边界，防止出现数组越界或者排序次数不够的情况。 （3）名次排序、冒泡排序、插入排序、选择排序的时间复杂度都是O(n^2)。 （4）对于名次排序，采用附加数组和原地重排两种方式进行比较，原地重排的最坏执行时间增加了，但是内存占用减少了，用时间换空间。 Postscript 1.排序的稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 2.排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。例如若将上面的冒泡排序中相邻量元素交换的判定条件改为pArray[j+1]&lt;=pArray[j],则两个相等的元素就会交换位置，从而变成不稳定的排序算法。 3.上面的代码只给出了采用附加数组的名次排序，这里给出原地重排的代码实现。 123456789101112131415161718192021222324template &lt;class T&gt;void SORT&lt;T&gt;::rank_sort()//原地重排数组使之有序{ //计算名次 int order[size]; //保存名次的数组 for(int i=0;i&lt;size;i++) //初始化 order[i]=0; for(int i=1;i&lt;size;i++) for(int j=0;j&lt;i;j++) if(pArray[j]&lt;=pArray[i]) order[i]++; else order[j]++; //原地重排 for(int i=0;i&lt;size;i++) { //把正确的元素移到pArray[i] while(order[i]!=i) { int t=order[i]; swap(pArray[i],pArray[t]); swap(order[i],order[t]); } }}","link":"/2020/10/02/DSA/DSA_2/"},{"title":"DSA：（三）数组描述线性表","text":"经过前面两次基础知识的铺垫之后，我们正式进入数据结构部分。本文通过通讯录的实现来分析线性表的数组描述。 P1004:通讯录 要求 1.不要使用STL（可以使用string类）。 2.封装线性表类，提供插入，删除，查找等操作。 3.线性表实现使用数组描述方法（顺序存储结构）。 描述 设通讯录中每一个联系人的内容有：姓名、电话号码、班级宿舍。由标准输入读入联系人信息，使用线性表中操作实现通讯录管理功能，包括：插入、删除、编辑、查找（按姓名查找）；键盘输入一班级，输出通讯录中该班级中所有人的信息。 格式 每个操作的第一个数为操作数(插入：0，删除：1，编辑：2，查找：3，输出一个班所有人员信息：4)，具体格式如下： 123450 姓名 电话 班级 宿舍 //插入一条记录1 姓名 //根据姓名删除一条记录2 姓名 编辑项目 项目新值 //根据姓名编辑一条记录(编辑项目为1到3的整数，1代表编辑电话，2代表编辑班级，3代表编辑宿舍)3 姓名 //根据姓名查找，找到输出1，未找到输出04 班级 //输出该班级的所有成员的宿舍号的异或值 其中查找操作当找到相应的人时输出1，未找到输出0。输出一个班级的人员信息时输出所有成员的宿舍号的异或值。输入数据保证合法。 输入 第一行一个n(1&lt;=n&lt;=20000), 代表接下来操作的数目。接下来n行代表各项操作。 输出 当遇到查找和输出一个班所有人员信息操作时输出。 样例 输入 点击右上角可直接复制。 1234567891011121314151617181920212223242526272829280 Evan 57298577609 1 650 WINNIE 37367348390 4 13 Evan4 63 WINNIE1 Evan4 71 WINNIE3 MARYAM3 CAMERON3 TZIVIA0 OMAR 16447001130 6 554 84 23 JADEN3 ELIZABETH2 OMAR 1 794099055683 JOSHUA2 OMAR 1 89782148171 OMAR3 Azaan3 MARIA0 HANNAH 94060479192 5 983 HEIDY1 HANNAH0 Axel 92066832927 3 701 Axel3 TIFFANY 输出 123456789101112131415161010000000000000 限制 1s 算法描述 定义结构体contact，包含姓名、电话号码、班级、宿舍信息。线性表中的每一个元素都是一个结构体，通过结构体可以访问具体的个人信息。 使用顺序存储结构，封装线性表类AddressList，私有成员包括联系人个数contactSize，一维数组的容量listLength，存储联系人的一维数组element。公有成员包括构造函数，复制构造函数，析构函数，以及具体的方法，包括插入一条信息，根据姓名删除一条记录，根据姓名编辑电话，根据姓名编辑班级或宿舍（与根据姓名编辑电话函数形成重载），根据姓名查找，输出班级所有成员宿舍号的异或值。 读入数据时，按行读入，首先读入操作数instruction，根据操作数利用switch分支进行分类，再根据所属操作类别读入对应的数据，调用对应的成员函数，输出数据。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;using namespace std;struct contact{ string name; //姓名 string telephoneNumber; //电话号码 int classNumber; //班级 int dormitoryNumber; //宿舍};class AddressList{private: int contactSize; //联系人的个数 int listLength; //一维数组的容量 contact* element; //存储联系人的一维数组public: AddressList(int initialCapacity=10); //构造函数 AddressList(const AddressList&amp; s); //复制构造函数 ~AddressList(); //析构函数 void insert(string name, string telephoneNumber, int classNumber, int dormitoryNumber); //插入一条记录 void eraser(string name); //根据姓名删除一条记录 void edit(string name, int num, string telephoneNumber); //根据姓名编辑电话 void edit(string name, int num, int Number); //根据姓名编辑班级或宿舍 int search(string name); //根据姓名查找 int outputClass(int classNumber); //输出班级所有成员宿舍号的异或值};AddressList::AddressList(int initialCapacity) //构造函数{ if(initialCapacity&lt;1) //初始容量小于1，抛出异常 { throw invalid_argument(&quot;InitialCapacity must be positive.&quot;); } listLength=initialCapacity; element=new contact[listLength]; contactSize=0;}AddressList::AddressList(const AddressList&amp; s) //复制构造函数{ listLength=s.listLength; contactSize=s.contactSize; element=new contact[listLength]; for(int i=0;i&lt;contactSize;i++) element[i]=s.element[i];}AddressList::~AddressList() //析构函数{ delete []element;}void AddressList::insert(string name, string telephoneNumber, int classNumber, int dormitoryNumber) //插入一条记录{ if(contactSize==listLength) //数组已满，容量扩大两倍 { contact* Nelement=new contact[listLength*2]; listLength=listLength*2; for(int i=0;i&lt;contactSize;i++) { Nelement[i]=element[i]; } delete []element; element=Nelement; } //在线性表末端(下标为contactSize处)插入一条记录 element[contactSize].name=name; element[contactSize].telephoneNumber=telephoneNumber; element[contactSize].classNumber=classNumber; element[contactSize].dormitoryNumber=dormitoryNumber; contactSize++;}void AddressList::eraser(string name) //根据姓名删除一条记录{ int index=0; //姓名对应的索引 for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) index=i; } for(int i=index+1;i&lt;contactSize;i++) //向左移动元素 { element[i-1]=element[i]; } element[--contactSize].~contact(); //联系人个数-1,析构无效元素}void AddressList::edit(string name, int num, string telephoneNumber) //根据姓名编辑电话{ for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) { element[i].telephoneNumber=telephoneNumber; } }}void AddressList::edit(string name, int num, int Number) //根据姓名编辑班级或宿舍{ if(num==2) //编辑班级 { for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) { element[i].classNumber=Number; } } } else //编辑宿舍 { for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) { element[i].dormitoryNumber=Number; } } }}int AddressList::search(string name) //根据姓名查找{ for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) return 1; } return 0;}int AddressList::outputClass(int classNumber) //输出班级所有成员宿舍号的异或值{ int res=0; for(int i=0;i&lt;contactSize;i++) { if(element[i].classNumber==classNumber) { res^=element[i].dormitoryNumber; } } return res;}int main(){ int n;//操作数目 cin&gt;&gt;n; AddressList Contact(10); //创建联系人对象 int instruction; //指令编号 string iName,iTelephone; //读入的姓名、电话信息 int iClass,iDormitory; //读入的班级、宿舍信息 for(int i=0;i&lt;n;i++) { cin&gt;&gt;instruction; switch(instruction) { case 0: //插入一条记录 cin&gt;&gt;iName&gt;&gt;iTelephone&gt;&gt;iClass&gt;&gt;iDormitory; Contact.insert(iName,iTelephone,iClass,iDormitory); break; case 1: //删除一条记录 cin&gt;&gt;iName; Contact.eraser(iName); break; case 2: //根据姓名编辑一条记录 int editNum; cin&gt;&gt;iName&gt;&gt;editNum; if(editNum==1) { cin&gt;&gt;iTelephone; Contact.edit(iName,editNum,iTelephone); } else if (editNum==2) { cin&gt;&gt;iClass; Contact.edit(iName,editNum,iClass); } else { cin&gt;&gt;iDormitory; Contact.edit(iName,editNum,iDormitory); } break; case 3: //根据姓名查找 cin&gt;&gt;iName; cout&lt;&lt;Contact.search(iName)&lt;&lt;endl; break; case 4: //输出班级所有成员宿舍号的异或 cin&gt;&gt;iClass; cout&lt;&lt;Contact.outputClass(iClass)&lt;&lt;endl; break; } } return 0;} 结果分析 第一次提交时7个节点通过，3个节点RE，一直找不到错误，然后仔细读代码(大概也就读了十几遍的样子)，发现在成员函数insert中，新数组动态申请时使用listLength*2表示新数组的元素个数，之后忘了对listLength扩大两倍（我真是个憨憨），修改后提交通过。","link":"/2020/10/04/DSA/DSA_3/"},{"title":"DSA：（七）队列","text":"循环队列的数组描述有不同的实现策略，主要不同之处在于如何区分队列是空还是满。本文的实现策略是不将队列插满，队列元素个数最多是arrayLength-1，在向队列插入元素之前，先要判断本次操作是否会使队列变满。 P1011:卡片游戏 描述 假设桌上有一叠扑克牌，依次编号为1-n（从上至下）。当至少还有两张的时候，可以进行操作：把第一张牌扔掉，然后把新的第一张（原先扔掉的牌下方的那张牌,即第二张牌）放到整叠牌的最后。输入n，输出最后剩下的牌。 要求 1.创建队列类，使用数组描述的循环队列。 2.实现卡片游戏。 格式 输入 一个整数n，代表一开始卡片的总数。 输出 最后一张卡片的值。 样例 输入 1100 输出 172 限制 1s, 64MB for each test case. 算法描述 使用数组存储结构，封装循环队列类arrayQueue，私有成员包括队列首元素的下一个位置（逆时针）queueFront，队列尾元素的位置queueBack，数组大小arrayLength，存储队列的数组queue。公有成员包括构造函数，析构函数，ADT方法包括判断队列是否为空，返回队列中元素个数，返回队首元素，返回队尾元素，删除队首元素，将元素插入到队尾。 构造函数中，设置queueFront=queueBack=0。队空标志为queueFront=queueBack，队列元素个数为(arrayLength+queueBack-queueFront)%arrayLength。元素入队时，若插入一个元素后队列满，需要扩大容量，通过queueFront计算队列首元素的位置start，与2进行比较判断原队列中是否形成环，若没有形成环，对元素只需调用一次copy方法进行复制，若形成环，需要使用copy进行两次复制。 对扑克牌进行操作，把第一张牌扔掉，队列操作是删除队首元素；把新的一张牌放到整叠牌的最后，队列操作是获得队首元素，删除队首元素，将得到的队首元素插入到队尾。通过队列的元素个数进行循环控制。 C++实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}int main(){ int n; cin&gt;&gt;n; arrayQueue&lt;int&gt; card; for(int i=1;i&lt;=n;i++) card.push(i); while(card.size()&gt;=2) { card.pop(); int t=card.front(); card.pop(); card.push(t); } cout&lt;&lt;card.front()&lt;&lt;endl; return 0;} 结果分析 1.构造函数设置queueFront=queueBack=0，保证符合队列为空的标志，并且将0号位置空出来，从1号位置开始插入。队列的最大元素个数为arrayLength-1，若插入一个元素后队列满，可以根据队列首元素的位置与2的大小关系判断队列中是否形成了环，然后进行元素的复制。 2.通过queueFront和queueBack计算队列元素个数，若队列中没有形成环，queueBack-queueFront得到队列元素个数，若队列中形成了环，queueFront-queueBack为空白位置的个数，arrayLength-(queueFront-queueBack)得到队列元素个数。将两种情况合并，(arrayLength+queueBack-queueFront)%arrayLength表示队列元素个数。","link":"/2020/11/12/DSA/DSA_7/"},{"title":"Visual Studio Code环境配置和使用技巧","text":"Windows平台下vscode配置较为复杂，需要下载编译环境，添加环境变量，手动在json文件中输入编译环境的目录。Linux平台下配置较为简单，使用命令行(sudo apt-get install )安装gcc和g++，然后在文件夹下新建测试文件，点击运行和调试，在弹出的窗口中直接选择gcc或g++即可自动生成json文件，不需要任何改动。 Windows平台 Step1: 下载MinGW 官网下载地址: MinGW-w64 - for 32 and 64 bit Windows 不同版本区别如下： 这里建议选择x86_64-posix-sehz。下载后，解压到自己常用的软件安装路径下，这里以D盘为例。 Step2: 添加环境变量 1.以windows10为例，右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量。 2.找到系统变量下的Path，点击编辑，新建，将bin目录的路径复制即可。 Step3: 配置json文件 1.打开vscode，选择或新建一个空文件夹目录打开作为项目目录。 2.点击“文件”按钮，再点击“新建文件夹”按钮，并重命名为”.vscode”。 3.在该文件夹内，在点击“新建文件”按钮，新建launch.json，tasks.json，c_cpp_properties.json三个.json文件。 文件具体内容如下： launch.json 1234567891011121314151617181920212223242526{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示 &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，这里只能为cppdbg &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加） &quot;program&quot;: &quot;${workspaceFolder}/${fileBasenameNoExtension}.exe&quot;,// 将要进行调试的程序的路径 &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可 &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，一般设置为false &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录，一般为${workspaceFolder}即代码所在目录 &quot;environment&quot;: [], &quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口，true使用控制台（小黑框），false使用内置终端 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe&quot;, // miDebugger的路径，注意这里要与MinGw的路径对应 &quot;preLaunchTask&quot;: &quot;g++&quot;, // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] } ] } tasks.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;g++&quot;, //这里注意一下，见下文 &quot;command&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;-ggdb3&quot;, // 生成和调试有关的信息 &quot;-Wall&quot;, // 开启额外警告 &quot;-static-libgcc&quot;, // 静态链接 &quot;-std=c++17&quot;, // 使用c++17标准 &quot;-finput-charset=UTF-8&quot;, //输入编译器文本编码 默认为UTF-8 &quot;-fexec-charset=GB18030&quot;, //输出exe文件的编码 &quot;-D _USE_MATH_DEFINES&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin&quot; }, // &quot;problemMatcher&quot;: [ //C/C++插件提供的problemMatcher，文件路径有问题，会出现找不到文件的错误 // &quot;$gcc&quot; // ] &quot;problemMatcher&quot;: { &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [ &quot;relative&quot;, &quot;\\\\&quot; ], &quot;pattern&quot;: { &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 } }, &quot;presentation&quot;: { &quot;echo&quot;: true, &quot;reveal&quot;: &quot;always&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never &quot;focus&quot;: false, &quot;panel&quot;: &quot;shared&quot; // 不同的文件的编译信息共享一个终端面板 }, } ]} c_cpp_properties.json 1234567891011121314{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;MinGW64&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;, &quot;compilerPath&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}&quot; ], &quot;cppStandard&quot;: &quot;c++17&quot; } ], &quot;version&quot;: 4} 一些其他的教程可能还会有settings.json文件，非必需，而且里面往往有一些仅适用于个人的习惯设置（字体大小等），这里不再展示。 传送门：具体每个配置选项的含义，可参考https://www.bilibili.com/video/BV1sW411v7VZ json文件参考来源：https://blog.csdn.net/qq_40477151/article/details/103917156 Step4: 运行和调试 launch.json文件中的 1&quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口，true使用控制台（小黑框），false使用内置终端 若使用控制台，需要在main函数return之前暂停一下，否则小黑框会一闪而过，可以使用stdlib.h库中的system(“pause”)，也可简单地使用getchar()。 若使用内置终端，则会直接在内置的终端输出。 调试过程与其他IDE类似，略。 一个小小的hint: 使用freopen重定向输入输出流，可以不用每次都复制一遍输入，或者无法辨别某个数据是输入还是输出（不方便比对正确结果）。 Demo: 插件推荐 1.Code Runner 安装后即可直接运行代码，使用内置终端。一些设置如下： Warning: 一定要将“Run In Terminal”的选项勾上，否则运行之后你找不到任何地方可以输入数据！ 2.Theme Light: Atom one light, Night Owl Light, GitHub Light. Dark: Atom one dark, One Dark Pro, Dark+. 传送门: - Visual Studio Code Light Themes - Visual Studio Code Dark Themes 3.Icon: Material Icon Theme. 4.filesize: 统计文件大小。 Linux平台 真的是非常easy啊！毕竟，一个连虚拟机或者双系统都拥有的人难道还不会配vscode吗？ Update 1.2021-03-27: C17标准不支持#include&lt;bits/stdc.h&gt;，编译时会报一长串错误，C14标准支持，如果想使用这个头文件，可以在json文件中将C标准改为C++14。 终于解决了一个困扰已久的问题。 2.2021-04-23：vscode-cpptools占用C盘空间过大问题 vscode-cpptools中是为了加速cpp编译的预编译文件，默认为5120MB约为5G，可以改为512MB。 点击文件-&gt;首选项-&gt;设置-&gt;搜索C_Cpp.intelliSenseCacheSize-&gt;设置大小","link":"/2021/03/20/Configuring%20Environment/vscode/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello Hexo Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2020/10/02/Hello%20World/hello-world/"},{"title":"程序设计思维与实践：Week2","text":"Week2作业 A：相邻数对 问题描述 给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。 输入格式 输入的第一行包含一个整数n，表示给定整数的个数。 第二行包含所给定的n个整数。 输出格式 输出一个整数，表示值正好相差1的数对的个数。 样例输入 12610 2 6 3 7 8 样例输出 13 样例说明 值正好相差11的数对包括 (2, 3), (6, 7), (7, 8)。 评测用例规模与约定 1≤n≤1000，给定的整数为不超过 1000010000 的非负整数。 Code 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,cnt=0,temp; cin&gt;&gt;n; vector&lt;int&gt; x(n); while(n--) { cin&gt;&gt;temp; x.push_back(temp); } for(auto it=x.begin();it!=x.end();it++) { for(auto ib=it+1;ib!=x.end();ib++) { if((*ib)-(*it)==1 || (*ib)-(*it)==-1) cnt++; } } cout&lt;&lt;cnt&lt;&lt;endl; return 0;} B：门禁系统 问题描述 涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。 输入格式 输入的第一行包含一个整数n，表示涛涛的记录条数。 第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。 输出格式 输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。 样例输入 1251 2 1 1 3 样例输出 11 1 2 3 1 评测用例规模与约定 1≤n≤1000，读者的编号为不超过n的正整数。 Code 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,temp; cin&gt;&gt;n; map&lt;int,int&gt; x; while(n--) { cin&gt;&gt;temp; x[temp]++; cout&lt;&lt;x[temp]&lt;&lt;&quot; &quot;; } return 0;} C：桶装数字 问题描述 yhf有n个桶，每个桶里都装着一些数字（一个或多个），所有的数字总共有m个。这天，lzh把yhf所有的桶全打翻了，数字洒了一地！所幸，每个数字都有它所在的桶的标记。yhf希望恢复所有的桶，但是他还要刷考研题目，于是他拜托你来完成这个任务。 由于yhf能在一秒内完成一套考研数学题，因此他希望你的程序能在一秒内得出结果。 输入格式 第一行输入两个整数n,m，第二行到第m+1行，每行两个整数x,t，分别表示这个数字和它所在的桶。 保证每个桶至少含有一个数字。 输出格式 输出n行，若第i个桶含有k_i个数字，则第i行输出k_i个整数，表示这个桶内的数字。注意：输出每个桶的数字时应按升序排序输出。 样例输入 1234562 53 12 22 13 21 2 样例输出 122 31 2 3 评测用例规模与约定 Code 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m,a,b; cin&gt;&gt;n&gt;&gt;m; vector&lt;vector&lt;int&gt;&gt; x(n+1,vector&lt;int&gt;()); while(m--) { cin&gt;&gt;a&gt;&gt;b; x[b].push_back(a); } for(int i=1;i&lt;=n;i++) sort(x[i].begin(),x[i].end()); for(int i=1;i&lt;=n;i++) { for(auto k:x[i]) cout&lt;&lt;k&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } return 0;} D：笔记本 问题描述 为了复习考研英语，yhf开始背单词。 yhf有一个笔记本，一开始是空的。当yhf遇到一个不认识的单词时，他会先查找笔记本，如果笔记本上没有，他就会先在互联网上查找这个单词，然后记在笔记本上。当yhf认为他已经熟记一个单词时，他会将这个单词在笔记本上擦掉（如果笔记本上没有就不用擦了）。yhf有时也会关心他的笔记本上记了多少单词，他会将笔记本上的单词按照字典序升序读一遍。 这天，yhf发现他的笔记本已经记满了单词，他决定用程序来实现笔记本的功能。但考虑到编写程序消耗的时间可以多背几千个单词，他决定把这个任务交给你。 输入格式 输入第一行包含一个整数m，接下来有m行，每一行有一个整数op，表示你的程序应执行哪种操作,具体如下： op=1，后接一个单词，表示查找这个单词；如果笔记本中没有这个单词，则将单词写进笔记本。 op=2，后接一个单词，表示删除这个单词；如果笔记本中没有这个单词，则无需进行操作。 op=3，表示按字典序通读整个笔记本。 输出格式 输出m行，每一行表示输入的操作对应的输出，具体如下： op=1，如果笔记本中有这个单词，输出found，否则输出write。 op=2，如果笔记本中有这个单词，输出erased，否则输出not found。 op=3，在一行内按字典序升序输出所有单词，中间用空格隔开。 样例输入 12345678981 problem1 problem2 problem1 problem2 acm1 pro1 acm3 样例输出 12345678writefounderasedwritenot foundwritewriteacm pro problem 评测用例规模与约定 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int m,op; string s; map&lt;string,bool&gt; note; cin&gt;&gt;m; while(m--) { cin&gt;&gt;op; if(op==1) { cin&gt;&gt;s; auto it=note.find(s); if(it!=note.end()) cout&lt;&lt;&quot;found&quot;&lt;&lt;endl; else { note.insert(make_pair(s,true)); cout&lt;&lt;&quot;write&quot;&lt;&lt;endl; } } else if(op==2) { cin&gt;&gt;s; auto it=note.find(s); if(it!=note.end()) { note.erase(it); cout&lt;&lt;&quot;erased&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;not found&quot;&lt;&lt;endl; } } else { for(auto &amp;x:note) cout&lt;&lt;x.first&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } } return 0;}","link":"/2021/03/21/Thinking%20and%20Practice%20in%20Programming/week-2/"},{"title":"程序设计思维与实践：Week1","text":"Week1作业和实验 作业 A：打酱油 问题描述 小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 输入格式 输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。 输出格式 输出一个整数，表示小明最多可以得到多少瓶酱油。 样例1 输入 140 输出 15 样例说明 把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。 样例2 输入 180 输出 111 样例说明 把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。 Code 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,cnt=0; scanf(&quot;%d&quot;,&amp;n); while(n&gt;=50) { cnt+=7; n-=50; } while(n&gt;=30) { cnt+=4; n-=30; } while(n&gt;=10) { cnt++; n-=10; } printf(&quot;%d\\n&quot;,cnt); return 0;} B：最小差值 问题描述 给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。 输入格式 输入第一行包含一个整数n。 第二行包含n个正整数，相邻整数之间使用一个空格分隔。 输出格式 输出一个整数，表示答案。 样例1 输入 1251 5 4 8 20 输出 11 样例说明 相差最小的两个数是5和4，它们之间的差值是1。 样例2 输入 1259 3 6 1 3 输出 10 样例说明 有两个相同的数3，它们之间的差值是0。 数据规模和约定 对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。 Code 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std; int num[1000]; int main(){ int n,min; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;num[i]); } min=fabs(num[0]-num[1]); for(int i=0;i&lt;n-1;i++) { for(int j=i+1;j&lt;n;j++) { if(fabs(num[i]-num[j])&lt;fabs(min)) min=fabs(num[i]-num[j]); } } printf(&quot;%d\\n&quot;,min); return 0;} 实验 A：签到题【请在实验开始5分钟内完成签到】 Description 请在比赛开始 5分钟 以内提交以下代码进行签到。 12#include &lt;cstdio&gt;int main(){puts(&quot;qiandao&quot;);} B：IO1 Description 计算a+b。 Input 输入第一行是一个整数N，代表接下来N行会有N组样例输入。 Output 每组输出占一行。 Sample Input 12321 510 20 Sample Output 12630 Code 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,a,b; scanf(&quot;%d&quot;,&amp;n); while(n--) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,a+b); } return 0; C：IO2 Description 计算a+b。 Input 有多组样例输入，以0 0代表输入结束。 Output 每组输出占一行。 Sample Input 1231 510 200 0 Sample Output 12630 Code 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,a,b; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b) &amp;&amp; a!=0 &amp;&amp; b!=0) { printf(&quot;%d\\n&quot;,a+b); } return 0;} D：IO3 Description 计算a+b。 Input 有多组样例输入。 Output 每组输出占一行。 Sample Input 121 510 20 Sample Output 12630 Code 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,a,b; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)) { printf(&quot;%d\\n&quot;,a+b); } return 0;} E：IO4 问题描述 你的任务是计算一些整数的和。 输入格式 输入包含多组样例。 每组样例包含一个整数N，然后在同行有N个整数。 若N = 0，则表示输入结束，这个样例不需要被处理。 输出格式 对于每组用例，你应当输出这组样例N个数字的和，每个输出占一行。 样例输入 1234 1 2 3 45 1 2 3 4 50 样例输出 121015 Code 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n!=0) { int x,sum=0; for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;x); sum+=x; } printf(&quot;%d\\n&quot;,sum); } return 0;} F：IO5 问题描述 请计算下面每行数的和。 输入格式 第一行有一个整数N，表示有N行数。接下来N行，每行第一个为整数M，表示本行后面有M个整数。 输出格式 对于输入的每一行数，请分别对应输出每一行数的和。 样例输入 12324 1 2 3 45 1 2 3 4 5 样例输出 121015 Hint 本题相关知识：输入输出和循环语句（for）的使用方式。 Code 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; scanf(&quot;%d&quot;,&amp;n); while(n--) { int m,x,sum=0; scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;m;i++) { scanf(&quot;%d&quot;,&amp;x); sum+=x; } printf(&quot;%d\\n&quot;,sum); } return 0;} G：IO6 问题描述 请计算下面每行数的和。 输入格式 输入包含多组数据，每组数据占一行。每行第一个数为整数N，后面有N个整数。 输出格式 对于输入的每一行数，请分别对应输出每一行数的和。 样例输入 124 1 2 3 45 1 2 3 4 5 样例输出 121015 Hint 本题相关知识：输入输出和循环语句（while）的使用方式。 Code 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int m; while(~scanf(&quot;%d&quot;,&amp;m)) { int x,sum=0; for(int i=0;i&lt;m;i++) { scanf(&quot;%d&quot;,&amp;x); sum+=x; } printf(&quot;%d\\n&quot;,sum); } return 0;} H：IO7 问题描述 请计算下面每行数的和。 输入格式 输入包含多组数据，每组数据占一行。每行有若干个整数。 输出格式 对于输入的每一行数，请分别对应输出每一行数的和。 样例输入 121 2 3 41 2 3 4 5 样例输出 121015 Hint 本题相关知识：读取一行的处理和格式化读取字符串，也可使用getline和stringstream。 Code 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std; int main(){ string a; while(getline(cin,a)) { istringstream is(a); int sum=0; int x; while(is&gt;&gt;x) sum+=x; cout&lt;&lt;sum&lt;&lt;endl; } return 0;} I：IO8 问题描述 给定两个十六进制整数a和b，输出他们的和。 输入格式 输入多组数据，以EOF作为数据的结束。 每组数据在一行中包含了两个十六进制整数a和b。 输出格式 对于每一组数据，以十进制输出a+b的和。 每组输出占用一行。 样例输入 1231 9A Ba b 样例输出 123102121 Code 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int a,b; while(~scanf(&quot;%x%x&quot;,&amp;a,&amp;b)) printf(&quot;%d\\n&quot;,a+b); return 0;} J：Discount 问题描述 给出商品的原价和现价，求该商品的优惠力度。 输入格式 输入两个数 A,B(1≤B&lt;A≤10^5)，分别表示原价和现价。 输出格式 输出一个实数，表示降价的百分比，保留三位小数输出。 样例输入 17 5 样例输出 128.571 Code 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int a,b; double x; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); x=100.0*(a-b)/a; printf(&quot;%.3f\\n&quot;,x); return 0;} K：Slot 问题描述 给出一个长度为3的字符串，所有字母均为大写英文字母，请判断该字符串是否由同一个字母构成。 输入格式 输入一行表示字符串。 输出格式 若该字符串是否由同一个字母构成，输出Won，否则输出Lost。 样例输入1 1TTT 样例输出1 1Won 样例输入2 1SYS 样例输出2 1Lost Code 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ char str[3]; scanf(&quot;%s&quot;,str); if(str[0]==str[1] &amp;&amp; str[1]==str[2]) printf(&quot;Won\\n&quot;); else printf(&quot;Lost\\n&quot;); return 0;} L：Orthogonality 样例输入1 12331 0 5-5 0 1 样例输出1 1Yes 样例输入2 12331 2 33 2 1 样例输出2 1No Code 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int a[100000],b[100000];int main(){ int n,res=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;b[i]); } for(int i=0;i&lt;n;i++) { res+=a[i]*b[i]; } if(res==0) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); return 0;} M：uNrEaDaBlE sTrInG 问题描述 我们称一个字符串是“难读的”，当且仅当它的奇数位置的字母都是小写字母，偶数位置的字母都是大写字母。请你判断一个字符串是否为“难读的”字符串。 输入格式 输入一行包含一个字符串。 输出格式 如果输入的字符串是“难读的”，输出Yes，否则输出No。 样例输入1 1tImElImItExCeEdEd 样例输出1 1Yes 样例输入2 1AccePt 样例输出2 1No Code 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ string str; cin&gt;&gt;str; for(int i=0;i&lt;str.size();i++) { if(i%2==0) { if(str.at(i)&gt;='a' &amp;&amp; str.at(i)&lt;='z') continue; else {printf(&quot;No\\n&quot;); return 0;} } else { if(str.at(i)&gt;='A' &amp;&amp; str.at(i)&lt;='Z') continue; else {printf(&quot;No\\n&quot;); return 0;} } } printf(&quot;Yes\\n&quot;); return 0;} N：Remove It 问题描述 给出一个长度为n的数列和一个数x，请从数列中删除数值等于x的项，输出剩余的数列。 输入格式 输入第一行包含两个整数n,x，第二行包含n个整数，表示数列。 输出格式 输出一行，表示删除后的数列。输出数字的相对顺序应与原数列相同。 样例输入1 126 41 2 3 4 3 4 样例输出1 11 2 3 3 样例输入2 123 66 6 6 样例输出2 1 Code 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,x,a; scanf(&quot;%d%d&quot;,&amp;n,&amp;x); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a); if(a!=x) printf(&quot;%d &quot;,a); else continue; } return 0;} O：Rally 样例输入 1265 2 4 2 8 8 样例输出 137 Code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int pos[100];int main(){ int n,a,b; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;pos[i]); a=pos[0]; b=pos[0]; for(int i=1;i&lt;n;i++) { if(pos[i]&lt;a) a=pos[i]; if(pos[i]&gt;b) b=pos[i]; } int res=0; for(int j=0;j&lt;n;j++) res+=(pos[j]-a)*(pos[j]-a); for(int i=a+1;i&lt;=b;i++) { int cur=0; for(int j=0;j&lt;n;j++) { cur+=(pos[j]-i)*(pos[j]-i); } if(cur&lt;res) res=cur; } printf(&quot;%d\\n&quot;,res); return 0;} P：：(Colon) 问题描述 钟表的时针和分针长度分别为a,b，当前的时间为H时M分，求时针端点与分针端点的距离。 输入格式 输入一行包含4个整数a,b,H,M。 输出格式 输出一个实数，表示端点之间的距离。你的输出与实际值的误差应小于10^(-9)。 样例输入 13 4 10 40 样例输出 14.56425719433005567605 Code 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;#define pi 3.1415926535int main(){ int a,b,H,M; double j,x; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;H,&amp;M); j=fabs(H*30+M*0.5-M*6); x=sqrt(a*a+b*b-2*a*b*cos(j*pi/180)); printf(&quot;%.9f\\n&quot;,x); return 0;} Q：Kaprekar Number 样例输入1 11024 2 样例输出1 18172 样例输入2 110 3 样例输出2 10 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;int g1(int x){ if(x==0) return 0; int a[20],w,y=0; for(int i=0;x&gt;0;i++) { a[i]=x%10; x=x/10; w=i; } w++; for(int i=0;i&lt;w-1;i++) { for(int j=0;j&lt;w-i-1;j++) { if(a[j]&lt;a[j+1]) { swap(a[j],a[j+1]); } } } for(int i=0;i&lt;w;i++) { y+=a[i]*pow(10,w-i-1); } return y;}int g2(int x){ if(x==0) return 0; int a[20],w,y=0; for(int i=0;x&gt;0;i++) { a[i]=x%10; x=x/10; w=i; } w++; for(int i=0;i&lt;w-1;i++) { for(int j=0;j&lt;w-i-1;j++) { if(a[j]&gt;a[j+1]) { swap(a[j],a[j+1]); } } } for(int i=0;i&lt;w;i++) { y+=a[i]*pow(10,w-i-1); } return y;}int main(){ int N,K,res=0; scanf(&quot;%d%d&quot;,&amp;N,&amp;K); for(int i=0;i&lt;K;i++) { res=g1(N)-g2(N); N=res; } printf(&quot;%d\\n&quot;,res); return 0;}","link":"/2021/03/21/Thinking%20and%20Practice%20in%20Programming/week-1/"},{"title":"程序设计思维与实践：Week3","text":"Week3作业和CSP模测（一） 作业 A：游戏 问题描述 有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入1 15 2 样例输出1 13 样例输入2 17 3 样例输出2 14 数据规模和约定 对于所有评测用例，1≤n≤1000，1≤k≤9。 Code 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,k,num=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) q.push(i); while(q.size()&gt;1) { num++; if(num%k==0 || num%10==k) { q.pop(); } else { q.push(q.front()); q.pop(); } } printf(&quot;%d\\n&quot;,q.front()); return 0;} B：跳一跳 问题描述 近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。 简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。 如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。 现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式 输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 输出格式 输出一个整数，为本局游戏的得分（在本题的规则下）。 样例输入 11 1 2 2 2 1 1 2 2 0 样例输出 122 数据规模和约定 对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int x,sum=0,last=0,i=0; while(~scanf(&quot;%d&quot;,&amp;x) &amp;&amp; x!=0) { i++; if(i==1) //first jump { if(x==1) {sum+=1; last=1;} else {sum+=2; last=2;} } else { if(x==1) { sum+=1; last=1; } if(x==2) { if(last==1) { sum+=2; last=2; } else { sum+=last+2; last+=2; } } } } printf(&quot;%d\\n&quot;,sum); return 0;} C：奇怪的电梯 样例输入 1235 1 53 3 1 2 50 样例输出 13 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int k[210],vis[210],cnt[210];int main(){ int N,A,B; while(scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N!=0) { scanf(&quot;%d%d&quot;,&amp;A,&amp;B); memset(k,0,210*sizeof(int)); memset(vis,0,210*sizeof(int)); memset(cnt,0,210*sizeof(int)); for(int i=1;i&lt;=N;i++) scanf(&quot;%d&quot;,&amp;k[i]); queue&lt;int&gt; q; q.push(A); vis[A]=1; cnt[A]=0; while (!q.empty()) { int r=q.front(); if(r==B) { printf(&quot;%d\\n&quot;,cnt[r]); break; } q.pop(); int up=r+k[r]; int down=r-k[r]; if(up&lt;=N &amp;&amp; vis[up]==0) { q.push(up); vis[up]=1; cnt[up]=cnt[r]+1; } if(down&gt;=1 &amp;&amp; vis[down]==0) { q.push(down); vis[down]=1; cnt[down]=cnt[r]+1; } } if(q.empty()) printf(&quot;-1\\n&quot;); } return 0;} D：选数 样例输入 124 33 7 12 19 样例输出 11 数据规模和约定 提示 素数的判定方法 12345678bool prime(int n){ if（n==1) return false; if (n==2) return true; for(int i=2;i*i&lt;=n;i++) if (n%i==0) return false; return true; } Code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int a[21];int n,k,cnt=0;bool prime(int n){ if(n==1) return false; if(n==2) return true; for(int i=2;i*i&lt;=n;i++) if(n%i==0) return false; return true;}void dfs(int sum,int kk,int x){ if(kk==k &amp;&amp; prime(sum)) { cnt++; return ; } if(x&gt;n) return ; dfs(sum,kk,x+1); dfs(sum+a[x],kk+1,x+1);}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs(0,0,1); printf(&quot;%d\\n&quot;,cnt); return 0;} E：棋盘问题 问题描述 小H收集到一些形状特殊的棋盘，她想在棋盘上面摆放棋子（棋子都是相同的）。她希望摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，你能帮她求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案数C嘛？ 输入格式 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n * n的矩阵内描述棋盘，以及摆放棋子的数目。 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 注意只有#棋盘区域可以摆放棋子。 输出格式 对于每一组数据，给出一行输出，输出摆放的方案数目C（数据保证C&lt;2^31）。 样例输入 1234567892 1#..#4 4...#..#..#..#...-1 -1 样例输出 1221 数据规模和约定 1&lt;=k&lt;=n&lt;=8 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;char a[10][10];int cnt = 0, n, k, kk;int vis[10];void dfs(int x){ if (kk == k) { cnt++; return; } if (x &gt;= n) return; for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; a[i][x] == '#') { vis[i] = 1; kk++; dfs(x + 1); vis[i] = 0; kk--; } } dfs(x + 1);}int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &amp;&amp; n != -1 &amp;&amp; k != -1) { cnt = 0; kk = 0; memset(a, '\\0', 100 * sizeof(char)); memset(vis, 0, 10 * sizeof(int)); getchar(); for (int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, a[i]); dfs(0); printf(&quot;%d\\n&quot;, cnt); } return 0;} CSP模测（一） A：R!!G!!B!! 问题描述 msy 的显示器被 yhf 借走了，于是 msy 需要一个新的显示器。他买来了许多 LED 小灯，每个小灯只能发出红、绿、蓝三种颜色光的其中一种。msy 需要三个不同颜色的小灯来拼成一个像素（像素之间并不能共用小灯），但是他并不知道每种颜色的小灯具体有多少个，只知道每个小灯的颜色。msy 想知道他用手头上的小灯可以拼出多少个像素，但是一个个数太麻烦了，他希望你来用程序解决这个问题。 输入格式 第一行输入一个数 nn，表示所有小灯的数量。 第二行输入一个长度为 nn 的字符串，表示每个小灯的颜色。颜色使用R、G、B三种字母表示。 输出格式 输出一个整数，表示 msy 可以拼出的像素的个数。 样例输入 128RGBRGBRG 样例输出 12 评测用例规模与约定 1≤n≤10^5 Code 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; scanf(&quot;%d&quot;,&amp;n); string str; cin&gt;&gt;str; int R=0,G=0,B=0; for(int i=0;i&lt;str.size();i++) { if(str[i]=='R') R++; else if(str[i]=='G') G++; else B++; } printf(&quot;%d\\n&quot;,min(min(R,G),B)); return 0;} B：密码强弱度 问题描述 在很多的交互式网站中，都需要通过使用用户名与密码进行登录，为了正确的评估一个密码的强弱，机智的 lzh 想出了一个评价方案。 这里研究的密码只有数字与大小写字母组成。具体的评价方案如下： 如果一个密码的长度小于 66，则这个密码的强度为 00。 对于长度大于等于 66 的密码，根据字符的种类（字符分为三类：数字，小写字母，大写字母），将连续的同种类的密码划分为一段，其段数即为密码的强弱程度。例如，密码 asd123As2d 可以分为 asd、123、A、s、2、d 6段，所以这个密码的强度为6。 输入格式 输入一行一个字符串s，1≤∣s∣≤10^6，表示密码。 输出格式 输出一行一个整数，表示密码的强弱程度。 Case 1 Input 11VIpuVNOv8 Output 16 Code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;bool f(char a,char b){ if(a&gt;='a' &amp;&amp; a&lt;='z' &amp;&amp; b&gt;='a' &amp;&amp; b&lt;='z') return true; if(a&gt;='A' &amp;&amp; a&lt;='Z' &amp;&amp; b&gt;='A' &amp;&amp; b&lt;='Z') return true; if(a&gt;='0' &amp;&amp; a&lt;='9' &amp;&amp; b&gt;='0' &amp;&amp; b&lt;='9') return true; return false;}int main(){ string s; int ans=0; cin&gt;&gt;s; if(s.size()&lt;6) ans=0; else { for(int i=0;i&lt;s.size()-1;i++) { if(f(s[i],s[i+1])) { continue; } ans++; } } if(ans==0) printf(&quot;0\\n&quot;); else printf(&quot;%d\\n&quot;,ans+1); return 0;} C：拉面馆 Case 1 Input 123451 1 1321 1601 1 Output 128 Case 2 Input 123456789102 5 243 452 1 22 1 251 63 66 69 732 1 21 12 1 22 1 22 1 2 Output 12345620AngryAngryAngry Case 3 Input 1234567891011121314151617181920212223242526272829303114 14 33 4 12 15 23 26 28 30 33 34 37 41 43 451 11 22 1 32 1 32 1 22 1 21 12 1 32 1 22 1 33 1 2 31 32 1 31 259 61 62 63 66 72 80 83 88 91 92 95 96 991 21 12 1 32 1 31 21 33 1 2 32 1 32 1 32 1 22 1 31 32 1 21 1 Output 1234567891011121314141825293331Angry53736580Angry7371 Code Score:30 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,k;int t[200010];int inc[200010][5];int s[200010];int lov[200010][5];int choose[200010];bool eat(int a){ int i=n; for(;i&gt;=1;i--) { if(inc[i][0]&gt;=lov[a][0] &amp;&amp; choose[i]) { int j=1; for(;j&lt;=k;j++) { if(lov[a][j]==1) { if(inc[i][j]==1) continue; else break; } } if(j&gt;k) { choose[i]=0; printf(&quot;%d\\n&quot;,s[a]-t[i]); return true; } } } if(i==0) return false; else return true;}int main(){ //freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;a.out&quot;,&quot;w&quot;,stdout); memset(choose,1,200010*sizeof(int)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;t[i]); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;inc[i][0]); int temp; for(int j=1;j&lt;=inc[i][0];j++) { scanf(&quot;%d&quot;,&amp;temp); inc[i][temp]=1; } /* printf(&quot;第%d碗面的配料有: &quot;,i); for(int j=1;j&lt;=k;j++) if(inc[i][j]==1) printf(&quot;%d &quot;,j); printf(&quot;\\n&quot;); */ } for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;s[i]); for(int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;lov[i][0]); int temp; for(int j=1;j&lt;=lov[i][0];j++) { scanf(&quot;%d&quot;,&amp;temp); lov[i][temp]=1; } /* printf(&quot;第%d个人like的配料有: &quot;,i); for(int j=1;j&lt;=k;j++) if(lov[i][j]==1) printf(&quot;%d &quot;,j); printf(&quot;\\n&quot;); */ } for(int i=1;i&lt;=m;i++) { if(eat(i)) { ; } else { printf(&quot;Angry\\n&quot;); } } return 0;} Score:100 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int t[200010], s[200010];set&lt;int&gt; sp[8];int main() { int n, m, k; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;t[i]); for (int i = 1; i &lt;= n; i++) { int kk, v = 0; scanf(&quot;%d&quot;, &amp;kk); for (int j = 1; j &lt;= kk; j++) { int x; scanf(&quot;%d&quot;, &amp;x); v |= (1 &lt;&lt; (x - 1)); } for (int j = 1; j &lt; 8; j++) if ((v &amp; j) == j) sp[j].emplace(t[i]); } for (int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;s[i]); for (int i = 1; i &lt;= m; i++) { int kk, v = 0; scanf(&quot;%d&quot;, &amp;kk); for (int j = 1; j &lt;= kk; j++) { int x; scanf(&quot;%d&quot;, &amp;x); v |= (1 &lt;&lt; (x - 1)); } if (sp[v].empty()) printf(&quot;Angry\\n&quot;); else { int tt = *sp[v].rbegin(); printf(&quot;%d\\n&quot;, s[i] - tt); for (int j = 1; j &lt; 8; j++) { sp[j].erase(tt); } } } return 0;}","link":"/2021/03/21/Thinking%20and%20Practice%20in%20Programming/week-3/"},{"title":"20210414","text":"1a1d9abe5672c7bc37baaec17a6e5159515451f0571d00edcbb5bd7cff710270a8fba6795f0fa45552155e3314c529b9d9f346565a011a7fda1dc6de7518da9f308cb32fbb7164899e9ba96a62e3336c84a781ca251b05b553c151cf47cb45acdcb5e731aa67009807d667ca95ba55e9248df06f500556b0b4649258e5cfa96b2085e1c730eb0ecff6b720b0b75a552a0695263e949f1b2acc08a9be525cfe788e06420178b52b9f68c92bb4e7fe739194b410e22d409708115bb6892234e9c5fb369c152e41c6114e2700e03689d3f099b5168e5290b1df49dd31b76e5edb51e0bf5676243393e54ce5008004289fd910672b28f8dbbbe445c0d059c58334cb056b9a3c3929f4435fdae50cc333b2a38ff22014490156ce9d2a4a8e9ca6dbed1697800686ac06417014c8333ff366ebe98fa1859d555c9a9afe2ac459f6e3dbd03169884879db987d7847f1c0d1b3a81328644251d3eabd2d463cf083316e6a903a67b492c5a65d506288cedd33d7acc844f164d786a81c996a9a843e96ab41ab102a548f79676478d0ed8d1d544540c026f257e232260145784217f8206904c4b04ec7484a36915fee502430e18a9cb747a31d0cdd9c03fdcab1cd1fcfc2ac3e0a2fa2dab70b2d82ff97512b4db414b18631720c116ee10c80df94b89ff56a161e3898e2d1a0cb8d4da10aa2090965c32d726c684129d39150c1b1c236f5867f775274eec181be2208ff80a6544a02f17a10999d3f7998fa89d934fff67b92d438903b0bf7b4f335da482def6eb76df5ab61eac1a680ab67617a58c3eab2af68b8cb5ea1a40e139dc1b5d5fbf1a0cc4e1b32bd316a4c0ad310c719906229a4520e89606b3cb18c02d22c3ae2a68b1d01a3a05e3fe61c5246530df7fe2fdc8d956a7eb689630fddaa8e4630938a09a602e4353fe515d5c2377e6ae4752e99c53228fa45e9de4c642fe21cbe23ca7403 输入密码，查看文章","link":"/2021/04/20/JingYing%20Class/20210414/"},{"title":"20210420","text":"1a1d9abe5672c7bc37baaec17a6e5159515451f0571d00edcbb5bd7cff710270b2c80bd894018ec924b79a1de86d11857ac4a9e07dbd2285c83f0ed0d66899db6914466fc15d15aab1daf05592cd048f281d31a08a336a9844a6daac72f48136898dd250ec0a5884994642d99488dd0b55ba20d2261542012505ad89c29005bbf332616d9057da393278bca301eed26e39260a1346b754e06e8557afa63e4ec259cfe38440f7af322c6bd1aa508b48d785706f5c8a79dc7079c73597bfee20f8f1d91128a5b00d5a60218bf6ca1ae265970ee5cbaf299e14745e8226e922c552f454dbafdb262fc271bbc0264f6e4e6ab29a884da77c5c1dd10b10ff17f9bbc27b3cab2b741b06ea07cdb264f94ba87938ef47ed620952c055223867423e4a6287136e004ec6c481409533fdc299cb72cd15aa4ceebc6d9f8757f4890559106498f49d8f40fe52953ad9ef5c312d9c68ac823673fe07f2804b377b5f8fd31d1d1adc5e9a6938b05030ee82cabeb15057355cc3a4c6eab71728ffd6b01f03eba23ec84174a7fa9e7713aaa49fc9668468dfaae8c53a42f9d69b3f6f5bd72b69e45caf5c14c048d03e329fc19001836ba9af79052deeb1089b1dfc67ab26ab769a93b802c62d58abfb94a455d9a7da7d3abe0e46be64c54cc376f517f2b566992509504cd23a8f485e691f2b0ea375a0733e3b8366d9232087c448ad5aa9dcdceb100931bfc625389e3b30736047ed1d5a3952bc5aba0e5ef0d6d8cb606cb2bb3989b3f82be3a05035006eba1397b7f2d34230d2dbf535d5301ef8c66e54aa4cfc11e0d603cc480e8d4bfd34accbf4c439be2c2afbd8c9ea4c63959355bfd071ed550e2b8eb03ce2dac90647a20af3848377689e3d4622c979932a0701136f02147463960ea9c8ee87e8a27879cf9b2c0fa0a2811afecca266a65f66efde000799f137c11c36ace42ae85d83784f146d9db789a6ca408ce43c5aa7b495297e5efd4f3eb381d91ca303b3d2ef67a12aa770e35945088e962a7950140520aa141ef7806b9664d6ea21f4e1b49bfe023b447ff15d0079063065148d1c993aee93e4c75a3b03137c5897638a02a433f0439d1e4f520fc8a5a810029ac3e0ab44d9a1cfe6f3d94ff13954ab6d5310a77c2ccf1586cf186d1e4f5ec911d3756fd13788ec305a375636c773658637233288328638b18514af2b818bc9e3553f202e13adf8188ac4bc17f352b5695c0294fc23103d90a5cb5cb1449257d312e87377710926e7080ad26d0c6be5481d3e14d749175d4aa0359fcb417abc5415bf1df588d0f9a288b917227d5ac0c717379bb834e841b0003377f918599df5ace44fff2ef83ad78d1cf5caf31eda385e8d301449170137433ccee82b70db4ac0bf63263b572fdaa4b6d0bd0e317f22d2ec81c4db3039c04c9d691269cbf526e81f0a79ac00a07c7a162f3f74b5b92c7b602f46496f0b3059f3e15e73032a325002e704867988fa99811f274cf58bd25bddd76c639ae9969031854225048ed9aa91e06e9524a2f70f8bc8ee949d4e18feaef07ce092ff035767dab5e7fc2d114a010038fef89de2d20d3613d3aec4fb54e1e5a837cd7a679be615f6725fa7cef274a53f74cc0d555cc66f4ff10636f114696765c22fa319ff1cde616eef1398bb1a414f23015f7577682c6aaf2863cd9b0cc33255f521752ee0b9570b41bc99a69f9dd0172b99302128ba3864d7c7e537a51cc7bc2094f215b0ff296950e6c22904e475f1cd4ab823c1a75c85ecb28f0e450211e798c917d0be83d5e1dcd0dce4f9e848ab8873fc6cda7108d71d1b43ddf02ef76410f988a9d80146d12742443829e12626626243433d3cc3d343c36f29537bf4407645e0128949742d25b038afe6181a51fea491f469240946e43515128d1f3c527f871b83a11087432d5e2e30ed9cec7364a27878b4c3cf4b22d0831f015ac942af132ba46e32fbd306b3847143d5544c2ccf35b804f4b69687f4f842790c8f1dc5ce470f6a76b92c99e37c177314fa90ca00526ca99933367bcd744ccc5ee75c33733fc67b7c79905e89141ff1ae0786df188e76fa53e977af4f8610dda85de27fa2635ab578878d105c9c288a58c7139e3dd11a30c847c4a45d0f43d35043a2e0dbe749bbf8f2fc7f3f51e61abee49ea0b65cab792d0a1bdbbf37f7b933d0de42645add844eb862cefc1f0884e04eb8a6e1cac294f3c32d643fcaf49c3db36cfb2472999eceeeb0c2b5ad09313afdecd968daf99bc5690b62f37149e302dc0d1584548e8392241fdc264554c1a97425f7dbb743760456f6956a350cf4e710d90211037b140ab47f1dbdb392ad0dff64a4fb96808631407583f363e08008fa9b1dc8d4cf83aa0959f6117f31b2360922f448beac6c81e33220fc6e2030ec0073e707306f05b6feafb17f693cbf558c109e9d560d5cfd638f441af40da21d41db64a35198fc53604fa8f66f0440d0fb93f9122050ded9af8361592f6b5550a63617cb8d79e2bf69a4ac414aea92bf7dafb06d116c02cd4031a81cb0133f238593e300e5bb31e720e088a9f44150af794de4fbd1b505e857dfee21acccb56adb19eae609a699060b4a5e24966df7b043561ff15d8be1aeb5a0116db0488d18ac46a1967928e24618103acd4cdee5ddb8442916a3ed7be5cd442cb5c6200ba0996e1e6cc65b8c27d0fd45eb5c450ea215cb43e6fb5a0103343f2593710e4068bc90eb16fd40a71294a180d6b5430eac426c93f4ba5dd41e67c671969970c625520a60ec3966afa04e5661ac3113693f420b396376a4861d2dc47f2bd0495b3852a9435ce82ebfdd8d8d96c2976b300d91fa39bcddc44035042bdf0da8c213fafa46419dd246bdcc6d4ff79e0b72fed6888dae4c20599a7007bb8a9bcb0ece467ff88d68051889aba819c8cc9fb679974e6badadb1624775b9b82411bd119a0adf3010bb199b943fc73b0d573620abf5d6f8a82871966ddb63feaddf86a2fbd4e7a7dc01ee30abe1e0ef9a1619aedbd56b737f8345396c9c513c666bec59c71ac7a64a68a1c34e42b4ad20a729d75a28d0ae233e40ebb23f35c28d297c89f1c196f746c2454600ef7dab7893074c166bf680047c2eb2bfba0f8d864926f7eeb2ddd326848fdd266b983a678986cf45ace9078176e6e8c183dc89dcd71b27e7a8ef340fcfce9c75954d1d5fc80e23a234c4dbcac0c195434382b01cf6c6b9034bbb953bd60ff127e9a2ee4569d9601abb4255e45a05787e446fe44da223615ac0bb97960c 输入密码，查看文章","link":"/2021/04/20/JingYing%20Class/20210420/"},{"title":"计算机网络复习笔记","text":"How to build a network? Computer Networks 写在前面 1Mbps=106bps1Mbps=10^{6}bps1Mbps=106bps 1Gbps=109bps1Gbps=10^{9}bps1Gbps=109bps 第一章：引言 1.1 名词解释 计算机网络：一组通过单一技术相互连接的自主计算机集合。 VPN（Virtual Private Networks）：虚拟专用网络。 peer-to-peer：对等。 RFID（Radio Frequency IDentification）：射频识别。 hotspot：无线热点。 GPS（Global Positioning System）：全球定位系统。 NFC（Near Field Communication）：近场通信。 点到点 端到端 单播（unicasting）、广播（broadcasting）、组播（multicasting） PAN（Personal Area Network）：个域网 LAN（Local Area Network）：局域网 WIFI：无线局域网的一个标准 IEEE 802.11 Ethernet：以太网 IEEE 802.3 VLAN（Virtual LAN）：虚拟局域网 MAN（Metropolitan Area Network）：城域网 WAN（Wide Area Network）：广域网 通信子网（subnet）、子网：子网的工作是把信息从一个主机携带到另一个主机。 子网由两个不同部分组成：传输线路（e.g. 铜线、光纤、无线）和交换元素（交换机、路由器）。 ISP（Internet Service Provider）：Internet服务提供商 相应的子网称为ISP网络。 协议：通信双方就如何进行通信的一种约定。 对等体：不同机器上构成相应层次的实体。 接口：定义了下层向上层提供哪些原语操作和服务。 网络体系结构：层和协议的集合。 协议栈：一个特定的系统所使用的一组协议，即每一层一个协议。 统计复用：许多网络设计根据主机的短期需求变化动态共享网络带宽，而不是给每个主机分配可能用也可能不会用的固定比例带宽。 流量控制：保持快速发送方不会用数据把慢速接收方淹没。 拥塞：太多的计算机需要发送太多的流量，而网络没有能力传递所有的数据包。 面向连接的服务：按照电话系统建模。 无连接服务：按照邮政系统建模。 存储-转发交换：中间节点只能在收到报文的全部内容后再将该报文发送给下一个节点。 直通式交换：报文还未全部接受完毕之前就向下一个节点传输。 DNS（Domain Name System）：将主机名字映射到网络地址。 ISO（International Standards Organization）：国际标准化组织。 OSI（Open Systems Interconnection）：开放系统互连。 物理层：关注在一条通信信道上传输原始比特。 数据链路层：将一个原始的传输设施转变成一条没有漏检传输错误的线路。 网络层：控制子网的运行。关注如何将数据报从源端路由到接收方。 传输层：接收来自上一层的数据，在必要的时候把这些数据分割成较小的单元，然后把这些数据单元传递给网络层，并且确保这些数据单元正确地到达另一端。 IP（Internet Protocol）：因特网协议。 ICMP（Internet Control Message Protocol）：因特网控制报文协议。 TCP（Transport Control Protocol）：传输控制协议，可靠的、面向连接的。 UDP（User Datagram Protocol）：用户数据报协议，不可靠的、无连接的。 DSL（Digital Subscriber Line）：数字用户线。 modem ：调制解调器。 CMTS（Cable Modem Termination System）：线缆调制解调终端系统。 宽带（broadband）：以高于拨号速率（56kbps）接入Internet。 FTTH（Fiber to the Home）：光纤到户。 POP（Point of Presence）：ISP存点，客户数据报进入ISP网络使用其服务的位置。 IXP（Internet eXchange Point）：Internet交换点。相互连接的ISP被认为彼此对等。 AMPS（Advanced Mobile Phone System）：高级移动电话系统。 1G GSM（Global System for Mobile communications）：全球移动通信系统。 2G UMTS（Universal Mobile Telecommunications System）：通用移动通信系统。 3G CDMA（Code Division Multiple Access）：码分多址。 WCDMA（Wideband Code Division Multiple Access）：宽带码分多址。 GPRS（General Packet Radio Service）：通用数据报无线业务。 软切换（soft handover）–硬切换（hard handover） SIM（Subscriber Identity Module）：用户识别模块。 ISM（Industral Scientific and Medical）：工业科学医疗频段。 AP（Access Point）：接入点。 OFDM（Orthogonal Frequency Division Multiplexing）：正交频分复用。 CSMA（Carrier Sense Multiple Access）：载波侦听多路访问。 WPA（WiFi Protected Access）：WiFi保护接入。 第二章：物理层 2.1 数据通信的理论基础 2.1.1 傅里叶分析 2.1.2 带宽有限的信号 带宽：在传输过程中振幅不会明显减弱的频率的宽度。 带宽是传输介质的一种物理特性，通常取决于介质的构成、厚度和电线或者光纤的长度。 一般将从0到某个最大频率的信号称为基带信号，将被搬移并占用某个更大频率范围的信号称为通带信号。 2.1.3 信道的最大数据速率 尼奎斯特定理 在无噪声信道中，如果物理带宽为B，信号离散度等级为V，则该信道最大数据速率 （数字带宽）=2Blog2V bps2B log_{2}V \\ bps2Blog2​V bps，计算后还要乘每秒采样数。 任意一个信号的通过一个物理带宽为B的低通滤波器只要进行每秒2B次的采样就可完全重构出被滤掉的信号。 信道一定，物理带宽确定时，要提高数字带宽只有增加离散等级。 香农定理 在有噪声信道中，如果物理带宽为B，信噪比为S/N，则该信道最大数据速率 （数字带宽）=Blog2(1+S/N) bpsB log_{2}(1+S/N) \\ bpsBlog2​(1+S/N) bps 分贝值=10log10S/N dB10log_{10}S/N \\ dB10log10​S/N dB 信道一定，物理带宽确定时，要提高数字带宽只有增加信噪比。 2.2 引导性传输介质 全双工（full-deplex）：可以双向同时使用的链路。 半双工（half-deplex）：可以双向使用但是一次只能使用一个方向的链路。 单双工（simplex）：只允许一个方向上的传输的链路。 2.3 无线传输 2.4 通信卫星 2.5 数字调制与多路复用 基带传输：信号的传输占有传输介质上从零到最大值之间的全部频率。 通带传输：信号占据了以载波信号频率为中心的一段频带。 2.5.1 基带传输 NRZ（Non-Return-to-Zero）：不归零。 曼彻斯特编码 从低到高：逻辑0 从高到低：逻辑1 需要两倍于NRZ编码的带宽。 NRZI（Non-Return-to-Zero Inverted）：不归零逆转 信号有跳变：1 信号无跳变：0 4B/5B 4个比特被映射为5个比特 保证永远不会出现连续三个0 双极编码 使用两个电压级别表示逻辑1 发送1时在+1V和-1V之间进行选择 2.5.2 通带传输 ASK（Amplitude Shift Keying）：幅移键控。通过两个不同的振幅表示0和1。 FSK（Frequency Shift Keying）：频移键控。通过两个不同的频率表示0和1。 最简单的形式是相移键控（PSK，Phase Shift Keying）。 二进制相移键控（BPSK，Binary Phase Shift Keying）：载波波形偏移0°或180°。 正交相移键控（QPSK，Quadrature Phase Shift Keying）：4个偏移，45°、135°、225°、315°。 2.5.3 频分复用 FDM：Frequency Division Multiplexing 保护带（guardband）：使信道之间完全隔离。 OFDM（Orthogonal Frequency Division Multiplexing）：正交频分复用。 2.5.4 时分复用 TDM：Time Division Multiplexing 每个用户周期性获得整个带宽非常短的一个时间。 要求时间上必须同步，各用户需要的带宽不均衡，而TDW用户时间片的使用却是一样的，将造成信道的浪费，不高效。 2.5.5 码分复用 CDMA：Code Division Multiple Access 允许每个站利用整个频段发送信号，没有时间限制。 可以将TDM看作许多人按顺序交谈，将FDM看作不用人按不同语调交谈，CDMA则是每对交谈者使用不用的语言。 CDMA关键在于能够提取出需要的信号，同时拒绝所有其他的信号并把这些信号当作噪声。 2.6 公共电话交换网络 本地回路(Local loops)：模拟线路，连接端局和千家万户，通常用三类双绞线承担。 干线、中继线(Trunks)：数字光纤，连接交换局。 交换局(Switching offices)：语音接驳干线的场所，包括端局。 56k（64k）的调制解调器：V.90标准电话线路频率为4kHz，采样率=2×4000=8000sample/sec=2×4000=8000sample/sec，每个码元传输8bit，其中1个比特控制错误，故传输数据速率=8000×7=56000kbps=8000×7=56000kbps，若算上控制错误的比特，毛速率为64kbps。 ADSL（Asymmetric Digital Subscriber Lines）： 非对称数字用户线。 连接调制解调器的本地回路带宽，被限制为4k，因为电话占频为4k；xDSL取消了电话系统里的滤波器后，可使用本地回路的全部（1.1兆）物理带宽。 使用离散多音（DMT，Discrete MultiTone）调制方法的ADSL操作： 1.1MHz的频谱，分为256根信道，每根4kHz（4312.5Hz）。信道0用于简单老式电话服务（POTS），信道1~5空闲， 剩下250条信道中，一条用于上行流控制，一条用于下行流控制，剩余248条信道用于数据传输。 每条信道内使用QAM调制方案，速率约为4000符号/秒。 QAM-64每个符号传输6bits。 1999年设定国际标准G.dmt，下行速度8Mbps，上行速度1Mbps。 DSLAM（Digital Subscriber Line Access Multiplexer）：数字用户线路接入复用器。 NID（Network Interface Device）：网络接口设备。 光纤入户（FttH）: PON（Passive Optical Network）：无源光网络。 下行流：光分离器 。上行流：光合并器。 脉冲编码调制，PCM，Pulse Code Modulation 模拟信号数字化的技术。构成了现代PSTN的核心。 采样、量化、编码、传输。 每125微秒发送一个语音样值，该采样率足以捕捉4kHz电话信道带宽上的信息。 时分多路复用TDM T1载波（北美和日本），24路。 每帧24*8=192个比特，加上控制用的一个比特的帧码，每125微秒产生193个比特，即数据传输率为193bits/0.000125s=1.544Mbps 每个样值中每个信道有7个数据比特。 E1载波（中国），32路语音的复用 每125微秒传递32*8=256个比特，即数据传输率为256bits/0.000125s=2.048Mbps TDM允许更高级别的复用，比如4条T1流复用为1条T2流，7条T2流复用为1条T3流（每一步复用有少量开销用于同步控制、成帧） SONET/SDH，光介质上进行同步数据传输的标准 SONET（Synchronous Optical NETwork）：同步光网络，美国ANSIS制定。 SDH（Synchronous Digital Hierarchy）：同步数字序列，国际标准组织ITU制定。 每隔125微秒发送810字节数据块，SONET是同步系统故不管是否有用该帧都被发送出去，总的传输速率为51.84Mbps。 9行，90列，有效载荷（SPE）为87列，共87×9×8bit×8000sample/sec=50.112Mbps。 SPE第一列是路径开销，因此用户数据为86列。 每帧前三列，保留用作传输系统管理信息。 前三列的前三行包含section开销。 前三列的后六行包含line开销，其中前两个字节包含了指向SPE首地址的指针。 源端正在构造SONET空帧时来了一个有效载荷数据，它可直接半途插入到当前构造的帧中，比如下图，SPE就从第1个帧的半途开始，横跨了两个帧。 对应于STS-n的光纤载波称为OC-n，其复用也是按比特进行的 如果一个载波（比如OC-3）没有被复用，而是仅承载了来自单个源的数据，则在线路名称后面加一个字母c（表示级联），因此OC-3表示由三条独立的OC-1载波构成的一条155.52Mbps载波，而OC-3c则表示来自于单个源的155.52Mbps数据流。 波分多路复用WDM WDM，Wavelength Division Multiplexing 波长λ，c=λf 按照波长分成若干份，承载不同用户的光信号。 交换 电路交换 包交换 第三章：数据链路层 3.1 数据链路层的设计问题 无确认的无连接服务。 以太网 有确认的无连接服务。WiFi。 有确认的有连接服务。 成帧： 字节计数法：每帧开始使以一个计数字段表示该帧的总字符数。 字节填充的标志字节法： 以某些特殊字符作帧的开始/结束标志，同时增加转义环节以免该字符无法表达。 缺点：容易造成帧界混淆（故增加转义字节），依赖8位字符。 比特填充的标志比特法： 用特殊的位模式01111110作为帧标志，即一个帧的开始（前一个帧的结束） 且为了处理帧内容中出现一个和帧标志相同的位串01111110。发送方一般在5个1后插入1个0，变为01111101。接收方自动删除第5个1后的0。 优点：可传输任意比特数的帧，传输速率更高。 物理层编码违禁法： 在物理层的线路编码方法里头，有一些冗余信号是不会出现在传输数据里的，以其作帧界。 比如，在4B/5B编码中，4B被映射成5B传输，32个模式，只用到16个，剩下的可以用作帧界。 比如，曼彻斯特编码，高电位跳变到低电位表示”1”，相反表示”0”。所以有两个跳变（高-&gt;高，低-&gt;低），两个冗余的跳变是没有使用的，也可拿作帧界。好处是使用冗余信号，不会混淆也不需要填充，故传输速率高。 3.2 差错检测和纠正 码字：包含数据位和校验位的n位单元（n=m+r）。 码率：码字中不包含冗余部分所占的比例，m/n。 海明距离：两个码字中不相同的位的个数。 意义：如果两个码字的海明距离为d，则需要d个1位错误才能将一个码字转变成另一个码字。 海明码，见计组和数字逻辑。 循环冗余校验码（CRC）： 任何一个kkk位的帧，可以看做一个k−1k-1k−1次的多项式。如1011001，看做x6+x4+x3+x0x_6+x_4+x_3+x_0x6​+x4​+x3​+x0​（6阶7项多项式） 约定一个生成多项式（Generator Polynomial）：G(x)G(x)G(x)，阶数为rrr，项数为r+1r+1r+1。 现在有一个要计算CRC的mmm位帧的多项式M(x)M(x)M(x)，m&gt;rm&gt;rm&gt;r，即M(x)M(x)M(x)比G(x)G(x)G(x)长。 在M(x)M(x)M(x)后附上 rrr个0，成为 xrM(x)xrM(x)xrM(x)。 xrM(x)/G(x)=Q(x)+R(x)xrM(x)/G(x)=Q(x)+R(x)xrM(x)/G(x)=Q(x)+R(x)，其中Q(x)Q(x)Q(x)为商、R(x)R(x)R(x)为余数，则xrM(x)−R(x)xrM(x)−R(x)xrM(x)−R(x)一定能被G(x)G(x)G(x)整除。 3.3 基本数据链路层协议 3.4 滑动窗口协议 第四章：介质访问控制子层 介质访问控制子层（MAC, Medium Access Control）：用来确定多路访问信道下一个使用者的协议，属于数据链路层的一个子层。 MAC子层位于数据链路层底部。 4.1 信道分配问题 4.2 多路访问协议 4.2.1 ALOHA 纯ALOHA 任何一个工作站都可以在帧生成后立即发送，并通过信号的反馈检测信道以判断是否发送成功。冲突则随机等待后重发。 即任性，想发就发。 生成k帧的概率服从泊松分布：Pr[k]=Gke−G/k!Pr[k]=G^ke^{−G}/k!Pr[k]=Gke−G/k!。例如生成0帧的概率是Pr[0]=e−GPr[0]=e^{−G}Pr[0]=e−G 在2t时间内，发送成功的概率应为，2t内都不才产生新帧的概率：P0=Pr[0]×Pr[0]=e−2GP0=Pr[0]×Pr[0]=e^{−2G}P0=Pr[0]×Pr[0]=e−2G 将P0=e−2GP0=e^{−2G}P0=e−2G代入S=G×P0S=G×P0S=G×P0，得S=G×e−2GS=G×e^{−2G}S=G×e−2G 求导求吞吐率S的极大值：S′=e−2G−2G×e−2G=0S′=e^{−2G}−2G×e^{−2G}=0S′=e−2G−2G×e−2G=0，故当 G=0.5G=0.5G=0.5时， S≈0.184S≈0.184S≈0.184 即，纯ALOHA信道的利用率最高为18.4%。 分槽ALOHA 把时间分成时隙（时间片），时隙 = 帧时T（较纯ALOHA降低一半） 发送帧必须在时隙的起点，所以冲突值发生在时隙的起点 冲突危险期缩短为T，一旦某个站占用某个时隙并发送成功，则在该时隙内不会出现冲突 P0=P[0]=e−GP0=P[0]=e^{−G}P0=P[0]=e−G，S=G×e−GS=G×e^{−G}S=G×e−G 在G=1时取得最大吞吐率：Smax=1e≈0.368Smax=1e≈0.368Smax=1e≈0.368 即，分隙ALOHA信道的利用率最高为36.8%。 4.2.2 载波侦听多路访问协议 载波侦听多路访问协议（CSMA，Carrier Sense Multiple Access），改进的ALOHA协议。特点：先听后发。 非坚持CSMA 概念：发送数据之前先侦听信道，若信道空闲，则发送帧；若信道忙碌，则等待一段随机时间后再侦听。 缺点：随机等待时间内介质上没有数据传送，这段时间被浪费，带来更大的延迟。 优点：更好的信道利用率。 持续式CSMA 分为：1-坚持CSMA、P-坚持CSMA P-坚持CSMA（适用于分时间槽的信道） 发送数据之前先侦听信道，若信道空闲，则以P的概率发送，以1-P的概率延迟一个时间槽发送；若信道忙碌，则等待直至信道变成空闲。如果发生冲突，等待一段随机时间后再侦听。 1-坚持CSMA 发送数据之前先侦听信道，若信道空闲，则发送帧；若信道忙碌，则等待直至信道变成空闲。如果发生冲突，等待一段随机时间后再侦听。 CSMA仍然会冲突的原因 同时侦听同时传送。 传播延迟。信号在介质传播速度是光速的65%（每微秒200米），在信号未到达接收方的时候，接收方监听信道发现空闲，随后发帧，两帧碰撞冲突。 冲突窗口 冲突危险期：一个工作站能够检测到冲突的时间最大值。 冲突窗口定义为上限：来回时间（RTT，Round Trip Time），2个帧时。 信号在信道传播速度：V = 200m/us 网卡处理帧的时间：网卡延时tPHYt_{PHY}tPHY​ 最远的两个工作站相距：SSS 计算得到：冲突窗口=2t+2tPHY2t+2t_{PHY}2t+2tPHY​，其中t=SVt=\\frac{S}{V}t=VS​ 倘若最远两个工作站间还有中继器，则冲突窗口=2（t+tPHY+N×t中继器）2（t+t_{PHY}+N×t_{中继器}）2（t+tPHY​+N×t中继器​），其中t=SVt=\\frac{S}{V}t=VS​ 如果冲突发生在最远两个工作站的正中间，那么此时检测到冲突的时间等于最远两个工作站之间的传播延迟。 带冲突检测的载波侦听多路访问协议（CSMA/CD,CSMA with Collision Detection），也是1-持续的CSMA。半双工以太网中使用。 工作原理 先听后发、边发边听。 经侦听，若介质空闲，则发送；若介质忙碌，持续侦听至空闲；发送之后，持续侦听是否碰撞冲突，若不冲突则发送成功，若冲突则随机等待后再重复侦听。 发送站感知冲突后，中断发送，之后发送一个非常简短的拥塞信号（Jam信号，是一个强化信号，广播出去通知各工作组该地方发生了碰撞）。 冲突检测和处理 冲突检测的方法：比较发出和收到的两个信号的能量与脉冲宽度变化 冲突检测的要求 时隙宽度 = 冲突窗口(最大冲突检测时间)- -&gt; 保证在一个时隙内能够检测到最远距离的冲突。 发送有效帧的时间 &gt;= 冲突窗口 --&gt; 防止因为在发生冲突时，已完成短帧发送而无法知道实际上已发送失败。 4.2.3 无冲突协议 以根本不可能产生冲突的方式解决信道竞争问题。 位图协议 假定有N个站，每个竞争期有N个槽。 j号站在j号槽中插入1位来声明自己有帧要发送。 经过N个槽后，按照数字顺序开始传送数据。 效率 低负载：每一帧的额外开销为N位，数据长度为d位，信道利用率为d/(n+d)d/(n+d)d/(n+d)。 高负载：若所有站在任何时候都有数据要发送，则N位竞争期被分摊到N个帧上，因此每一帧的额外开销只有1位，信道利用率为d/(1+d)d/(1+d)d/(1+d)。 令牌传递 令牌代表发送权限。 如果站有个等待传输的帧队列，当它接收到令牌就可以发送帧，然后再把令牌传递到下一站。 如果站没有排队的帧要传，则只把令牌传递下去。 二进制倒计数 如果一个站想要使用信道，它就以二进制位串的形式广播自己的地址，从高序的位开始。 假定所有的地址具有相同的长度。 不同站地址中相同位在同时发送时被信道布尔或在一起。 假设传输延迟可忽略。 一个站只要看到自己的地址位中的0值被改写成了1，则它必须放弃竞争。 特性：高序站的优先级比低序站的优先级高。 信道利用率d/(d+log2N)d/(d+log_2N)d/(d+log2​N)，如果精心设计帧格式，使得发送方的地址正好是帧内的第一个字段，信道利用率为100%。 4.2.4 有限竞争协议 低负载下采用竞争的做法而提供较短的延迟，高负载下采用无冲突技术获得良好的信道效率。 4.2.5 无线局域网协议 MACA（Multiple Access with Collision Avoidance）：冲突避免多路访问。 基本思想：发送方刺激接收方输出一个短帧，以便其附近的站能检测到这次传输，从而避免在接下去进行的（较大）数据帧传输中也发送数据。 A首先给B发送一个RTS（Request to Send）帧，包含了随后将要发送的数据帧的长度。 B用一个CTS（Clear to Send）作为应答，此CTS帧也包含了数据长度（从RTS）中复制过来。 A收到CTS之后开始传输。 4.3 以太网 4.3.1 经典以太网物理层 可以包含多个电缆段和多个中继器，但是不允许任意两个收发器之间的距离超过2.5km，并且任意两个收发器之间经过的中继器不能超过4个。 4.3.2 经典以太网MAC子层协议 SOF（Start of Frame）：帧起始定界符。 LLC（Logical Link Control）：逻辑链路控制。 IEEE802.3帧结构 前导码+帧起始字段：8个Bytes，前7个Bytes都是10101010，最后一个字节10101011（最后一位是1表明帧的开始）。前导码的作用——表明一个帧的开始。 而在DIX以太网帧中，帧起始字段最后一位是0。 目的地址：6个Bytes（MAC地址，前24位为OUI表示某公司，后24位表序号）。 源地址：6个Bytes（MAC地址，全球唯一，表示方法是’-‘、’:’、’.’配合16进制）。 长度字段：表明帧长度（不包括前导码、但包括帧头帧尾），帧长度最小64字节最大1518字节。 而在DIX以太网帧中，该字段是类型字段，表明上层网络层是什么协议。 如何区分是长度字段还是类型字段：判断大小，{长度字段大小&lt;1536(0x600) 类型字段大小&gt;1536(0x600){长度字段大小&lt;1536(0x600) 类型字段大小&gt;1536(0x600)。 数据字段：搭载了LLC的数据，长度最小是46字节，实际内容小于46则要填充到46，如此加上帧头帧尾的18字节再能保证整个帧至少64字节。 校验字段：4个Bytes，CRC循环冗余校验，除了前导码+帧起始字段都被校验。 有效帧长度至少64Bytes ★ CDMA/CD的要求：最短帧发送时间 &gt;= 冲突窗口 2τ2τ2τ 以太网(802.3)规定，在10Mbps局域网中 时隙2τ=51.2μs2τ=51.2μs2τ=51.2μs 最短帧长度：10Mbps×2τ/8=64Bytes10Mbps×2τ/8=64Bytes10Mbps×2τ/8=64Bytes或(51200/100ns)/8=64Bytes(51200/100ns)/8=64Bytes(51200/100ns)/8=64Bytes 为了更加容易区分有效帧和垃圾数据，以太网要求有效帧必须至少64字节 二进制指数后退的CSMA/CA 冲突检测到后，时间被分成离散的时隙，时隙长度等于信号在介质上来回传输时间(51.2μs)。一般地，第i次冲突后，等待的时间将从000~2i−12^i-12i−1之间随机选择一个数，然后等待这么多个时间槽。达到10次冲突后，随机数的选择区间被固定在最大值1023，以后不再增加。在16次冲突之后，控制器放弃努力，并给计算机返回一个失败报告。 4.3.3 以太网性能 4.3.4 交换式以太网 集线器 交换机 4.3.5 快速以太网 快速以太网（100M以太网——IEEE802.3u） 要求：跟10M以太网兼容 基本思想：保留原有的帧格式、接口和过程规则 比特时间：100ns -&gt; 10ns 电缆最大长度：2500m - &gt; 250m 编码方式 10M以太网：曼彻斯特编码 快速以太网：4B/5B（4bits数据被编码成5bits信号，易实现、电压平衡、效率80%） 4.3.6 千兆以太网 千兆以太网（G比特以太网，GE）：IEEE802.3z 兼容10/100M以太网（同时期的两个技术FDDI、ATM不兼容） 主要工作在全双工模式，若半双工，则需要CSMA/CD技术，可能带来传输距离过短的问题 -&gt; 可使用帧串、帧扩充等方法解决 编码方式：8B/10B 4.3.7 万兆以太网 4.3.8 以太网回顾 4.4 无线局域网 4.4.1 802.11体系结构和协议栈 分布式系统（distribution system） 自组织网络（ad hoc network） MAC子层决定如何分配信道，LLC子层隐藏802系列协议之间的差异，使它们在网络层看起来并无差别。 4.4.2 802.11物理层 频段：2.4GHz或5GHz 4.4.3 802.11MAC子层协议 CSMA/CA原理： 带冲突避免的载波侦听多路访问协议。 首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。 接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧ACK。 发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，会出现一段空闲时间。 隐藏站问题： 假设有3无线通信站ABC如下所示： A —&gt; (B &lt;— C) 其中B在C的无线电波范围内，但A不在C的无线电波范围内。此时C正在向B传送数据，而A也试图向B传送数据。此时，A不能够监听到B正在忙，而错误的认为此时可以向B传送数据了。如果A向B传送数据，则将导致错误。此即隐藏站问题。其中C是A的隐藏站。 暴露站问题： 假设有3无线通信站ABC如下所示： &lt;—–(A B) —&gt; C 其中B在A的无线电波范围内，但C不在A的无线电波范围内。此时A正在传送数据（向除B以外的某通信站），而B希望给C发送数据，但是错误地认为该传送过程将会失败（因为B会监听到一次传输，所以它会错误地认为此时不能向C发送数据）。此即暴露站问题。其中A是B的暴露站。 网络分配向量（NAV，Network Allocation Vector）：说明这个帧所属的一系列数据将传输多长时间。 4.4.4 802.11帧结构 三种类型的帧：数据帧、控制帧和管理帧。 数据帧： 第一个字段是帧控制字段，包括11个子字段：协议版本、类型（比如数据帧10、控制帧01或者管理帧00）、子类型（比如RTS和CTS）、去往DS、来自DS、更多段、重传、电源管理、更多数据、受保护的、顺序。 第二个字段是持续时间字段，它通告本帧和其确认帧将会占用信道多长时间，按微秒计时。 接下来是地址字段，包括3个地址：接收方地址、发送方地址、远程端点。 序号字段是帧的编号，可用于重复帧的检测。 数据字段包含了有效载荷，长度可以达到2312字节。 帧校验序列字段（CRC）。 管理帧的格式与数据帧的格式相同，其数据部分的的格式因子类型的不同而变。 控制帧要短一些，有帧控制字段、持续时间字段、帧校验序列字段，但只有一个地址，没有数据部分，大多数关键信息都转换成子类型字段。 4.4.5 服务 4.5 宽带无线 4.6 蓝牙 4.7 RFID 4.8 数据链路层交换 交换机在交换帧时的三种方式 存储转发：交换机把整个帧接收下来，计算校验和并检查该帧无错再做策略。（延迟大、出错率小） 直通交换（贯穿）：在接收时即读入目的端口转发出去。（延迟小、出错率高） 无分片交换：交换时，读满64字节后才转发，不会转发碎片帧，而冲突碎片往往是小于64字节的非法短帧runt。（延迟不大、出错率不高） 学习网桥： 后向学习法：学习的是源地址。 泛洪算法：对于每个发向未知目标地址的入境帧，网桥将它输出到所有的端口，但它来的那个输入端口除外。 若目的端口与源端口相同，则丢弃该帧。 若目的端口与源端口不同，则转发该帧到目的端口。 若目的端口未知（MAC地址查找不到），则泛洪该帧。 网桥可以进行协议转换。 生成树网桥： 生成树算法：Radia Perlman。 STP，Spanning Tree Protocol，IEEE802.1D 每一个网络有一个根网桥；每一个网桥有一个根端口；每一个网段有一个指定端口；剩下的非指定端口不被使用 生成树算法，可在有物理回路的网络中，生成逻辑无回路的生成树，但并不能保证其中的路径最优。 非指定端口虽不参与数据帧的转发，但它会侦听树的工作报文。当树上某些端口失效后，非指定端口将重新启用，形成新的生成树。 物理层：repeater中继器、hub 数据链路层：Bridge、switch 网络层：Router 传输层：Transport gateway 应用层：Application gateway 虚拟局域网 802.1Q标准 VLAN：一组逻辑上的设备或用户，不考虑地理位置。 VLAN的实现： 基于MAC地址 基于三层协议 基于端口（大多数）：在交换机内部有一张VLAN成员配置表 VLAN成员跨越不同交换机（帧标记法）： 帧在通过Trunk干线起点时打上标签，干线终点拆除标签（把这个帧涂上它所在VLAN的颜色） 第五章：网络层 5.1 网络层的设计问题 5.2 路由算法 5.3 拥塞控制算法 5.4 服务质量 5.5 网络互联 5.6 Internet的网络层 第六章：传输层 6.1 传输服务 6.2 传输协议的要素 6.3 拥塞控制 6.4 Internet传输协议：UDP 6.5 Internet传输协议：TCP 6.6 性能问题","link":"/2021/06/13/Computer%20Networks/revision/"},{"title":"DSA：（十一）搜索树","text":"二叉搜索树查找、删除、插入操作的平均性能为O(logn)，最坏情况下的性能为O(n)。索引二叉搜索树为每个节点增加了leftSize域，记录该节点左子树的元素个数，可以按名次进行查找和删除操作，在插入和删除后需要对一些节点的leftSize值进行更新。 P1018:二叉搜索树 描述 创建带索引的二叉搜索树类。存储结构使用链表，提供操作:插入、删除、按名次删除、查找、按名次查找、升序输出所有元素。 格式 输入 输入第一行一个数字m (m&lt;=1000000)，表示有m个操作。 接下来m行，每一行有两个数字a，b： 当输入的第一个数字a为0时，输入的第二个数字b表示向搜索树中插入b。 当输入的第一个数字a为1时，输入的第二个数字b表示向搜索树中查找b。 当输入的第一个数字a为2时，输入的第二个数字b表示向搜索树中删除b。 当输入的第一个数字a为3时，输入的第二个数字b表示查找搜索树中名次为b的元素。 当输入的第一个数字a为4时，输入的第二个数字b表示删除搜索树中名次为b的元素。 输出 对于输入中的每一种操作，输出执行操作的过程中依次比较的元素值的异或值。 注意 查询与删除操作中，待查询的元素也需要异或入答案中。 查找（删除）操作中，如果未找到，或者插入操作，已存在，输出0（不插入），不需要输出异或和。 查找（删除）第b大，如果不存在，输出0。 删除操作中，如果当前元素有两个孩子，替换的为右子树中最小的，如果只有一个孩子，直接用该孩子替换当前元素，如果没有孩子，直接删除。 删除操作的替换过程中所有比较操作不计入答案。 样例 样例1 输入 1234567891011121314130 60 70 40 50 11 50 73 32 41 53 44 30 4 输出 123456789101112130662270723163 样例2 输入 123456789101112131415140 430 170 550 620 570 660 674 50 670 703 64 70 202 43 输出 123456789101112131404343283434963402929915843 限制 1s, 10240KiB for each test case. 提示 查找和删除第k大的元素时，可以先把第k的元素找到，再按照该元素查找和删除。 算法描述 封装索引二叉搜索树类indexedBinarySearchTree，二叉树的存储结构使用链表，每个节点包括关键字key，左子树的元素个数leftSize，左孩子leftChild，右孩子rightChild。节点类的构造函数有四个，默认构造函数，通过theKey构造，通过theKey，theLeftChild，theRightChild构造（构造函数中计算leftSize值），通过theKey，theLeftSize，theLeftChild，theRightChild构造。索引二叉搜索树类中，非静态的私有成员包括根节点root，树的节点个数treeSize，静态的私有成员包括访问函数visit，前序遍历preOrder，中序遍历inOrder，后序遍历postOrder，删除t指向的节点dispose方法，输出该节点的关键字的output方法。公有成员包括构造函数，析构函数，empty方法，size方法，前序遍历，中序遍历，后序遍历，层次遍历，删除二叉树的erase方法，查找关键字的find方法，插入关键字的insert方法，删除关键字的erase方法，获取名次为b的节点的关键字的get方法，插入操作后更新leftSize域的updateLeftSizeAfterInsert方法，删除操作后更新leftSize域的updateLeftSizeAfterErase_1，updateLeftSizeAfterErase_2方法，两种方法针对删除操作中的两种情况进行相应更新。 find：查找关键字为theKey的节点，如果找到输出查找过程中依次比较的元素值的异或和，如果未找到输出0，不需要输出异或和。指针p从根节点开始搜索，寻找关键字等于theKey的节点，直到p为空为止。循环体首先进行异或操作，然后根据theKey和p-&gt;key的大小关系判断是否找到以及进左子树还是右子树。 insert：插入关键字为theKey的节点，如果不存在关键字为theKey的节点，输出插入过程中依次比较的元素值的异或和，如果已存在关键字为theKey的节点，输出0，不需要输出异或和。指针p从根节点开始搜索，寻找插入的位置，用指针pp保存p的父节点，根据theKey和p-&gt;key的大小关系判断是否已经存在关键字为theKey的节点以及进左子树还是右子树。根据theKey建立一个新节点，根据root是否为空判断是否是插入到一颗空树中，然后通过pp将其连在搜索树上。插入后，treeSize加一，调用updateLeftSizeAfterInsert方法对从根节点到插入点的路径上的节点的leftSize值进行更新。指针x从根节点开始，如果theKey小于x-&gt;key，当前节点的leftSize需要加一，如果theKey大于x-&gt;key，当前节点的leftSize不需要更新。最后输出异或值。 erase：删除关键字为theKey的节点，输出删除过程中依次比较的元素值的异或和，替换过程中的所有比较操作不计入答案。如果当前节点有两个孩子，用右子树中关键字最小的节点进行替换。如果只有一个孩子，直接用该节点的孩子进行替换。如果没有孩子，直接删除。如果不存在，输出0。指针p从根节点开始搜索，pp为p的父节点。搜索完毕后根据p是否为空判断是否存在关键字为theKey的节点。若不存在，输出0然后返回。若存在，根据p的孩子个数分两种情况进行考虑。 （1）p有两个孩子：转化为第（2）中情况。在p的右子树中沿着leftChild寻找最小元素s替代被删除的节点。替代过程是根据s-&gt;key，p-&gt;leftSize，p-&gt;leftChild，p-&gt;rightChild新建一个节点，将其连在pp上，更新指针pp，删除p节点，然后让p指向s（这是为了保证（2）中对节点s的删除）。 （2）p至多有一个孩子：将孩子指针存在c中，将pp和c连起来，删除p，treeSize减一。最后输出异或值。 对leftSize的更新在（1）过程之后（如果有的话），（2）过程之前进行。使用flag标记（1）过程是否进行，如果（1）过程执行，即要删除的节点有两个孩子，调用updateLeftSizeAfterErase_2，否则调用updateLeftSizeAfterErase_1。 updateLeftSizeAfterErase_2：要删除的节点有两个孩子，对从root到p的路径上的节点的leftSize进行更新。参数为节点类的指针s。指针x从根节点开始，当x不等于s时，执行while循环，通过x-&gt;key和s-&gt;key的大小关系进行相应节点的leftSize的更新。注意等于的特殊情况，第一次遇到相等的情况，表示x为替换后的节点，因为是用右子树的最小元素进行替换，所以直接进入右子树即可，第二次遇到表示路径寻找完毕。 updateLeftSizeAfterErase_1：要删除的节点至多有一个孩子，对从root到p的路径上的节点的leftSize进行更新。参数为关键字值theKey。指针x从根节点开始，当x不为空时，执行while循环，通过theKey和x-&gt;key的大小关系进行相应节点的leftSize的更新，若相等则路径寻找完毕。 get：返回第index个元素的关键字的值（index从0开始）。指针x从根节点开始搜索，如果index等于x-&gt;leftSize，则找到该元素，如果index小于x-&gt;leftSize，则第index个元素是左子树的第index个元素，如果index大于x-&gt;leftSize，则第index个元素是右子树的第(index-(x-&gt;leftSize+1))个元素。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct indexedBinarySearchTreeNode{ T key; //关键字 int leftSize; //左子树的元素个数 indexedBinarySearchTreeNode&lt;T&gt; *leftChild,*rightChild; //左孩子和右孩子 indexedBinarySearchTreeNode() { leftChild=rightChild=NULL; leftSize=0; } indexedBinarySearchTreeNode(const T&amp; theKey) { key=theKey; leftChild=rightChild=NULL; leftSize=0; } indexedBinarySearchTreeNode(const T&amp; theKey,indexedBinarySearchTreeNode&lt;T&gt; *theLeftChild,indexedBinarySearchTreeNode&lt;T&gt; *theRightChild) { key=theKey; leftChild=theLeftChild; rightChild=theRightChild; leftSize=0; //计算leftSize的值 indexedBinarySearchTreeNode&lt;T&gt; *p=theLeftChild; while(p!=NULL) //从根沿着右子树的路径计算节点个数 { leftSize+=p-&gt;leftSize+1; p=p-&gt;rightChild; } } indexedBinarySearchTreeNode(const T&amp; theKey,int theLeftSize,indexedBinarySearchTreeNode&lt;T&gt; *theLeftChild,indexedBinarySearchTreeNode&lt;T&gt; *theRightChild) { key=theKey; leftSize=theLeftSize; leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class indexedBinarySearchTree{private: indexedBinarySearchTreeNode&lt;T&gt; *root; //根节点 int treeSize; //树的节点数量 static void (*visit)(indexedBinarySearchTreeNode&lt;T&gt; *); //访问函数 static void preOrder(indexedBinarySearchTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(indexedBinarySearchTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(indexedBinarySearchTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(indexedBinarySearchTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 static void output(indexedBinarySearchTreeNode&lt;T&gt; *t) {cout&lt;&lt;t-&gt;key&lt;&lt;&quot; &quot;;} //输出节点的关键字public: indexedBinarySearchTree() {root=NULL; treeSize=0;} ~indexedBinarySearchTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void inOrderOutput() {inOrder(output); cout&lt;&lt;endl;} //输出中序序列 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } T* find(const T&amp; theKey) const; //查找关键字为theKey的节点 void insert(const T&amp; theKey); //插入关键字为theKey的节点 void erase(const T&amp; theKey); //删除关键字为theKey的节点 T get(int index); //获得名次为b的节点的关键字 void updateLeftSizeAfterInsert(const T&amp; theKey); //插入操作后对leftSize域的更新 void updateLeftSizeAfterErase_1(const T&amp; theKey); //要删除的节点p最多有一个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新 void updateLeftSizeAfterErase_2(indexedBinarySearchTreeNode&lt;T&gt; *s); //要删除的节点p有两个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新};template &lt;class T&gt;void (*indexedBinarySearchTree&lt;T&gt;::visit)(indexedBinarySearchTreeNode&lt;T&gt;*)=NULL; //类的静态成员的初始化template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::preOrder(indexedBinarySearchTreeNode&lt;T&gt; *t){ if(t!=NULL) { indexedBinarySearchTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::inOrder(indexedBinarySearchTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); indexedBinarySearchTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::postOrder(indexedBinarySearchTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); indexedBinarySearchTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;T* indexedBinarySearchTree&lt;T&gt;::find(const T &amp;theKey) const{//查找关键字为theKey的节点 //如果找到输出查找过程中依次比较的元素值的异或和 //如果未找到输出0，不需要输出异或和 int value=0; //异或和 //指针p从根开始搜索，寻找关键字等于theKey的节点 indexedBinarySearchTreeNode&lt;T&gt; *p=root; while(p!=NULL) { value^=p-&gt;key; //异或 if(theKey&lt;p-&gt;key) p=p-&gt;leftChild; else if(theKey&gt;p-&gt;key) p=p-&gt;rightChild; else { cout&lt;&lt;value&lt;&lt;endl; return &amp;p-&gt;key; } } //未找到关键字为theKey的节点 cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; return NULL;}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::insert(const T &amp;theKey){//插入关键字为theKey的节点 //如果不存在关键字为theKey的节点，输出插入过程中依次比较的元素值的异或和 //如果已存在关键字为theKey的节点，输出0，不需要输出异或和 int value=0; //异或和 indexedBinarySearchTreeNode&lt;T&gt; *p=root,*pp=NULL; //p从根节点开始，pp为p的父节点 //寻找插入点 while(p!=NULL) { value^=p-&gt;key; //异或 pp=p; //将p移向孩子节点 if(theKey&lt;p-&gt;key) p=p-&gt;leftChild; else if(theKey&gt;p-&gt;key) p=p-&gt;rightChild; else //已存在关键字为theKey的节点 { cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; return ; } } //为theKey建立一个新节点，并将该节点连接到pp indexedBinarySearchTreeNode&lt;T&gt; *newNode=new indexedBinarySearchTreeNode&lt;T&gt;(theKey); if(root!=NULL) //树非空 { if(theKey&lt;pp-&gt;key) pp-&gt;leftChild=newNode; else pp-&gt;rightChild=newNode; } else //插入到空树中 root=newNode; //更新treeSize和路径上节点的leftSize treeSize++; updateLeftSizeAfterInsert(theKey); cout&lt;&lt;value&lt;&lt;endl;}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::erase(const T&amp; theKey){//删除关键字为theKey的节点，输出删除过程中依次比较的元素值的异或和，替换过程中的所有比较操作不计入答案 //如果当前节点有两个孩子，用右子树中关键字最小的节点进行替换 //如果只有一个孩子，直接用该节点的孩子进行替换 //如果没有孩子，直接删除 //如果不存在，输出0 int value=0,flag=0; //异或值和标记 indexedBinarySearchTreeNode&lt;T&gt; *p=root,*pp=NULL; while (p!=NULL &amp;&amp; p-&gt;key!=theKey) {//p移动到它的孩子节点 value^=p-&gt;key; pp=p; if(theKey&lt;p-&gt;key) p=p-&gt;leftChild; else p=p-&gt;rightChild; } if(p==NULL) //不存在关键字theKey的节点 { cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; return ; } //重新组织树结构 //当p有两个孩子时的处理 if(p-&gt;leftChild!=NULL &amp;&amp; p-&gt;rightChild!=NULL) {//两个孩子 flag=1; //转化为空或只有一个孩子 //在p的右子树中寻找最小元素 indexedBinarySearchTreeNode&lt;T&gt; *s=p-&gt;rightChild,*ps=p; while(s-&gt;leftChild!=NULL) {//移动到最小元素 ps=s; s=s-&gt;leftChild; } //将最小元素s移动到p indexedBinarySearchTreeNode&lt;T&gt; *q=new indexedBinarySearchTreeNode&lt;T&gt;(s-&gt;key,p-&gt;leftSize,p-&gt;leftChild,p-&gt;rightChild); if(pp==NULL) //p为根节点 root=q; else if(p==pp-&gt;leftChild) pp-&gt;leftChild=q; else pp-&gt;rightChild=q; //更新p和p的父节点 if(ps==p) pp=q; else pp=ps; delete p; p=s; } //在进行删除前更新leftSize if(flag==1) //删除的节点有两个孩子 updateLeftSizeAfterErase_2(p); else //删除的节点最多有一个孩子 updateLeftSizeAfterErase_1(theKey); //p最多有一个孩子 //把孩子指针存放在c indexedBinarySearchTreeNode&lt;T&gt; *c; if(p-&gt;leftChild!=NULL) c=p-&gt;leftChild; else c=p-&gt;rightChild; //删除p if(p==root) root=c; else //p是pp的左孩子还是右孩子 { if(p==pp-&gt;leftChild) pp-&gt;leftChild=c; else pp-&gt;rightChild=c; } treeSize--; delete p; value^=theKey; cout&lt;&lt;value&lt;&lt;endl;}template &lt;class T&gt;T indexedBinarySearchTree&lt;T&gt;::get(int index){//返回第index个元素的关键字的值 //index从0开始 indexedBinarySearchTreeNode&lt;T&gt; *x=root; while(x!=NULL) { if(index==x-&gt;leftSize) //第index个元素是x-&gt;key break; else if(index&lt;x-&gt;leftSize) //第index个元素是左子树的第index个元素 x=x-&gt;leftChild; else //第index个元素是右子树的第(index-(x-&gt;leftSize+1))个元素 { index=index-(x-&gt;leftSize+1); x=x-&gt;rightChild; } } return x-&gt;key;}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::updateLeftSizeAfterInsert(const T &amp;theKey){//插入操作后对leftSize域的更新 indexedBinarySearchTreeNode&lt;T&gt; *x=root; //寻找从根开始到关键字为theKey的节点的路径 while(x!=NULL) { if(theKey&lt;x-&gt;key) //插入节点在x的左子树中，leftSize++ { x-&gt;leftSize++; x=x-&gt;leftChild; } else if(theKey&gt;x-&gt;key) //插入节点在x的右子树中 x=x-&gt;rightChild; else //路径寻找完毕 break; }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::updateLeftSizeAfterErase_1(const T &amp;theKey){//要删除的节点p最多有一个孩子，删除操作后对root到p的路径上节点的leftSize域 indexedBinarySearchTreeNode&lt;T&gt; *x=root; //寻找从根开始到关键字为theKey的节点的路径 while(x!=NULL) { if(theKey&lt;x-&gt;key) //删除节点在x的左子树中，leftSize-- { x-&gt;leftSize--; x=x-&gt;leftChild; } else if(theKey&gt;x-&gt;key) //删除节点在x的右子树中 x=x-&gt;rightChild; else //路径寻找完毕 break; }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::updateLeftSizeAfterErase_2(indexedBinarySearchTreeNode&lt;T&gt; *s){//要删除的节点p有两个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新 indexedBinarySearchTreeNode&lt;T&gt; *x=root; bool meet=false; //标记是否是第一次遇到关键字为s-&gt;key的节点 //寻找从根开始到s的路径 while(x!=s) { if(s-&gt;key&lt;x-&gt;key) //删除节点在x的左子树中，leftSize-- { x-&gt;leftSize--; x=x-&gt;leftChild; } else if(s-&gt;key&gt;x-&gt;key) //删除节点在x的右子树中 x=x-&gt;rightChild; else { if(!meet) //第一次遇到相同关键字的节点 { meet=true; //这个节点的关键字已经被右子树的最小元素替换 x=x-&gt;rightChild; //要删除的节点位于右子树，所以将指针指向右孩子 } else //第二次遇到，路径寻找完毕 break; } }}int main(){ indexedBinarySearchTree&lt;int&gt; IBST; int m,instruction,b; cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch (instruction) { case 0: cin&gt;&gt;b; IBST.insert(b); break; case 1: cin&gt;&gt;b; IBST.find(b); break; case 2: cin&gt;&gt;b; IBST.erase(b); break; case 3: cin&gt;&gt;b; IBST.find(IBST.get(b-1)); break; default: cin&gt;&gt;b; IBST.erase(IBST.get(b-1)); } } return 0;} 结果分析 1.updateLeftSizeAfterErase_1和updateLeftSizeAfterErase_2可以合并成updateLeftSize AfterErase，参数为索引二叉搜索树节点类的指针。while循环条件是x!=s，如果s-&gt;key小于x-&gt;key，x-&gt;leftSize减一，x=x-&gt;leftChild，否则x=x-&gt;rightChild。 2.插入节点时，对leftSize更新不能边寻找边更新，因为有可能该节点已经存在，不需要再插入，所以需要在插入操作完成后再根据theKey更新。","link":"/2020/12/23/DSA/DSA_11/"},{"title":"DSA：（十二）图","text":"图的表示可以通过邻接矩阵，邻接链表和邻接数组。本文通过邻接链表实现无向无权图的表示，成员方法包括插入一条边，删除一条边，广度优先搜索，深度优先搜索，求连通分量个数，求两点之间的最短路径（BFS）。linkedGraph类中含有迭代器类myIterator，通过顶点创建迭代器，依次返回该顶点的所有邻接点。 P1019:图论基础 描述 创建无向图类，存储结构使用邻接链表，提供操作：插入一条边，删除一条边，BFS，DFS。 格式 输入 第一行四个整数n，m，s，t。n (10≤n≤100000) 代表图中点的个数，m (10≤m≤200000) 代表接下来共有m个操作，s代表起始点，t代表终点。 接下来m行，每行代表一次插入或删除边的操作，操作格式为： 0 u v 在点u和v之间增加一条边 1 u v 删除点u和v之间的边 输出 第一行输出图中有多少个连通分量。 第二行输出所有连通子图中最小点的编号（升序），编号间用空格分隔。 第三行输出从s点开始的dfs序列长度。 第四行输出从s点开始的字典序最小的dfs序列。 第五行输出从t点开始的bfs序列的长度。 第六行输出从t点开始字典序最小的bfs序列。 第七行输出从s点到t点的最短路径，若是不存在路径则输出-1。 样例 输入 12345678910111213141516171819202110 20 4 50 6 40 10 30 4 80 4 101 4 100 2 10 5 80 5 20 10 70 9 60 9 10 7 10 8 100 7 50 8 30 6 71 6 41 8 30 7 80 9 2 输出 123456711 104 8 5 2 1 7 6 9 10 3 105 2 7 8 1 9 6 10 4 3 2 限制 1s, 10240KiB for each test case. 算法描述 使用邻接链表存储结构，封装无向图类linkedGraph。protected成员包括图的顶点数n，边数e，邻接表aList，深度优先搜索递归方法rDfs，静态成员标记数组reach，标记label，路径数组path，路径长度length。public成员包括构造函数，析构函数，返回顶点个数，返回边数，插入一条边，删除一条边，广度优先搜索，深度优先搜索，返回无向图的构件个数，通过BFS求两点之间的最短路径，对aList链表数组的每个元素进行排序。定义迭代器myIterator，提供next方法依次返回当前顶点的邻接顶点，若不存在返回0。方法iterator返回myIterator类的指针。 对chain类进行扩展，增加方法eraseElement(theVertex)删除顶点为theVertex的元素和冒泡排序方法bubbleSort。 insertEdge：插入一条边i, j。首先通过aList[i].indexOf(j)判断图中是否已经存在这条边，若已经存在则不需要再次插入，若不存在，调用aList[i]和aList[j]的insert方法，将邻接顶点插入到链表头，图的边数e加一。 eraseEdge：删除一条边i, j。首先通过aList[i].eraseElement (j)判断图中是否存在这条边，若不存在则不需要进行删除，若存在，调用aList[i]和aList[j]的eraseElement方法删除邻接点，图的边数e减一。 labelComponents：返回无向图的构件个数。首先将标记构件号的数组c和标记label初始化，然后遍历每个顶点，如果顶点i未到达，对其实施BFS，进行标记。 findPath：寻找一条从顶点theSource到顶点theDestination的最短路径，返回一个数组path，从索引1开始表示路径，path[0]表示路径长度。如果路径不存在，返回NULL。首先对path，length，reach等进行初始化，定义bool型变量exists表示路径是否存在，用parent数组存储每个节点的前驱节点。利用BFS搜索路径，每次从队列中删除一个有标记的顶点，判断是否到达theDestination，若未到达，则标记所有邻接于顶点w的还未到达的顶点，使用parent数组存储前驱节点。如果到达theDestination，exists赋值为true，跳出while循环。如果找到了最短路径，根据parent逆向寻找路径中的各个顶点，通过栈结构将其放入path数组中，path[0]记录路径长度。如果不存在路径，输出-1然后返回。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839#include &lt;iostream&gt;using namespace std;//---------------------graphChain类---------------------template &lt;class T&gt;struct chainNode //节点类{ //数据成员 T element; chainNode&lt;T&gt;* next; //方法 chainNode() {} chainNode(const T&amp; element) { this-&gt;element=element; } chainNode(const T&amp; element,chainNode&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};class linkedGraph;template &lt;class T&gt;class graphChain{ friend class linkedGraph;protected: chainNode&lt;T&gt;* firstNode; //指向链表第一个节点的指针 int listSize; //线性表的元素个数public: graphChain(); //构造函数 graphChain(const graphChain&lt;T&gt;&amp; theList); //复制构造函数 ~graphChain(); //析构函数 //方法 bool empty() const {return listSize==0;} int size() const {return listSize;} T&amp; get(int theIndex) const; int indexOf(const T&amp; theElement); //返回元素theElement首次出现时的索引，若不存在返回-1 void insert(int theIndex,const T&amp; theElement); //在索引为theIndex的位置插入元素theElement void erase(int theIndex); //删除链表中索引为theIndex的元素 T* eraseElement(T&amp; theVertex); //删除顶点为theVertex的元素 void bubbleSort(); //冒泡排序 //迭代器 class iterator { protected: chainNode&lt;T&gt;* node; public: //用C++的typedef语句实现前向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(chainNode&lt;T&gt;* theNode=NULL) //构造函数 { node=theNode; } //解引用操作符 T&amp; operator* () const {return node-&gt;element;} T* operator-&gt; () const {return &amp;node-&gt;element;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { node=node-&gt;next; return *this; } iterator operator++ (int)//后++ { iterator old=*this; node=node-&gt;next; return old; } //相等检验 bool operator!= (const iterator&amp; right) const { return node!=right.node; } bool operator== (const iterator&amp; right) const { return node==right.node; } }; iterator begin() const { return iterator(firstNode); } iterator end() const { return iterator(NULL); }};template &lt;class T&gt;graphChain&lt;T&gt;::graphChain() //构造函数{ firstNode=NULL; listSize=0;}template &lt;class T&gt;graphChain&lt;T&gt;::graphChain(const graphChain&lt;T&gt;&amp; theList) //复制构造函数{ listSize=theList.listSize; //链表为空 if(listSize==0) { firstNode=NULL; return ; } //链表不为空 chainNode&lt;T&gt;* sourceNode=theList.firstNode; firstNode=new chainNode&lt;T&gt;(sourceNode-&gt;element);//复制theList的首元素 sourceNode=sourceNode-&gt;next; chainNode&lt;T&gt;* targetNode=firstNode; while(sourceNode!=NULL) //复制剩余元素 { targetNode-&gt;next=new chainNode&lt;T&gt;(sourceNode-&gt;element); targetNode=targetNode-&gt;next; sourceNode=sourceNode-&gt;next; } targetNode-&gt;next=NULL; //尾结点}template &lt;class T&gt;graphChain&lt;T&gt;::~graphChain() //析构函数{ while(firstNode!=NULL) { chainNode&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;T&amp; graphChain&lt;T&gt;::get(int theIndex) const{//返回索引为theIndex的元素 //移向需要的节点 chainNode&lt;T&gt;* currentNode=firstNode; for(int i=0;i&lt;theIndex;i++) currentNode=currentNode-&gt;next; return currentNode-&gt;element;}template &lt;class T&gt;int graphChain&lt;T&gt;::indexOf(const T&amp; theElement){//返回元素theElement首次出现时的索引，若不存在返回-1 //搜索链表寻找theElement chainNode&lt;T&gt;* currentNode=firstNode; int index=0; while (currentNode!=NULL &amp;&amp; currentNode-&gt;element!=theElement) { currentNode=currentNode-&gt;next; index++; } if(currentNode==NULL) return -1; else return index;}template &lt;class T&gt;void graphChain&lt;T&gt;::insert(int theIndex,const T&amp; theElement) //插入操作{//在索引为theIndex的位置插入元素theElement if(theIndex==0)//在链表头插入 firstNode=new chainNode&lt;T&gt;(theElement,firstNode); else { //寻找前驱 chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;theIndex-1;i++) p=p-&gt;next; //在p之后插入 p-&gt;next=new chainNode&lt;T&gt;(theElement,p-&gt;next); } listSize++;}template &lt;class T&gt;void graphChain&lt;T&gt;::erase(int theIndex){//删除链表中索引为theIndex的元素 chainNode&lt;T&gt;* deleteNode; if(theIndex==0) {//删除链表的首节点 deleteNode=firstNode; firstNode=firstNode-&gt;next; } else { chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;theIndex-1;i++) p=p-&gt;next; deleteNode=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; } listSize--; delete deleteNode;}template &lt;class T&gt;T* graphChain&lt;T&gt;::eraseElement(T &amp;theVertex){//删除顶点为theVertex的元素 chainNode&lt;T&gt;* deleteNode; //要删除的节点 if(firstNode-&gt;element==theVertex) //删除的是链表的首节点 { deleteNode=firstNode; firstNode=firstNode-&gt;next; } else //删除的不是链表的首节点 { chainNode&lt;T&gt;* previousNode=firstNode; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=theVertex) { currentNode=currentNode-&gt;next; previousNode=previousNode-&gt;next; } if(currentNode==NULL) //链表中不存在要删除的元素 return NULL; else //链表中存在要删除的元素 { deleteNode=currentNode; previousNode-&gt;next=currentNode-&gt;next; } } T* pElement=&amp;deleteNode-&gt;element; listSize--; delete deleteNode; return pElement;}template &lt;class T&gt;void graphChain&lt;T&gt;::bubbleSort(){//冒泡排序 for(chainNode&lt;T&gt;* p=firstNode;p!=NULL;p=p-&gt;next) for(chainNode&lt;T&gt;* q=p-&gt;next;q!= NULL;q=q-&gt;next) if(p-&gt;element &gt; q-&gt;element) swap(p-&gt;element,q-&gt;element);}//---------------------arrayQueue类---------------------template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}//---------------------arrayStack类---------------------template &lt;class T&gt;class arrayStack{private: int stackTop; //栈顶 int arrayLength; //栈容量 T* stack; //元素数组public: //构造函数、析构函数 arrayStack(int initialCapacity=10); ~arrayStack() {delete []stack;} //ADT方法 bool empty() const {return stackTop==-1;} int size() const {return stackTop+1;} T&amp; top(); void pop(); void push(const T&amp; theElement);};template &lt;class T&gt;arrayStack&lt;T&gt;::arrayStack(int initialCapacity){ arrayLength=initialCapacity; stack=new T[arrayLength]; stackTop=-1;}template &lt;class T&gt;T&amp; arrayStack&lt;T&gt;::top(){ return stack[stackTop];}template &lt;class T&gt;void arrayStack&lt;T&gt;::pop(){ stack[stackTop--].~T();}template &lt;class T&gt;void arrayStack&lt;T&gt;::push(const T&amp; theElement){ if(stackTop==arrayLength-1) {//空间已满，容量加倍 T* newStack=new T[arrayLength*2]; arrayLength*=2; for(int i=0;i&lt;=stackTop;i++) newStack[i]=stack[i]; delete []stack; stack=newStack; } //在栈顶插入 stack[++stackTop]=theElement;}//---------------------linkedGraph类---------------------class linkedGraph{protected: int n; //顶点数 int e; //边数 graphChain&lt;int&gt; *aList; //邻接表 void rDfs(int v); //深度优先搜索递归方法 void rDfs_output(int v); //深度优先搜索递归方法（输出DFS序列） static int *reach; //标记数组 static int label; //标记 static int *path; //路径 static int length; //路径长度public: linkedGraph(int numberOfVertices=0) {//构造函数 n=numberOfVertices; e=0; aList=new graphChain&lt;int&gt;[n+1]; } ~linkedGraph() {delete []aList;} int numberOfVertices() const {return n;} //返回顶点数 int numberOfEdges() const {return e;} //返回边数 void insertEdge(int i,int j); //插入一条边 void eraseEdge(int i,int j); //删除一条边 void bfs(int v,int reach[],int label); //广度优先搜索 void bfs_output(int v,int reach[],int label); //广度优先搜索（输出BFS序列） void dfs(int v,int reach[],int label); //深度优先搜索 void dfs_output(int v,int reach[],int label); //深度优先搜索（输出DFS序列） int labelComponents(int c[]); //返回无向图的构件个数 int* findPath(int theSource,int theDestination);//通过BFS求两点之间的最短路径 void sortedAList() //对aList[i]进行排序 { for(int i=1;i&lt;=n;i++) aList[i].bubbleSort(); } //迭代器 class myIterator { protected: graphChain&lt;int&gt; chain; chainNode&lt;int&gt;* currentVertexNode; public: myIterator(graphChain&lt;int&gt;&amp; theGraphChain) { chain=theGraphChain; currentVertexNode=chain.firstNode; } ~myIterator() {chain.firstNode=NULL;} int next() {//返回下一个顶点。若不存在则返回0 //寻找下一个邻接的顶点 while(currentVertexNode!=NULL) { chainNode&lt;int&gt;* p=currentVertexNode; currentVertexNode=currentVertexNode-&gt;next; return p-&gt;element; } //不存在下一个邻接的顶点 return 0; } }; myIterator* iterator(int theVertex) //访问指定顶点的相邻顶点 {//返回顶点theVertex的迭代器 return new myIterator(aList[theVertex]); }};int* linkedGraph::reach=NULL; //标记数组int linkedGraph::label=0; //标记int* linkedGraph::path=NULL; //路径int linkedGraph::length=0; //路径长度void linkedGraph::insertEdge(int i,int j){//插入一条边i,j //判断是否是新边 if(aList[i].indexOf(j)==-1) { aList[i].insert(0,j); aList[j].insert(0,i); e++; }}void linkedGraph::eraseEdge(int i,int j){//删除一条边i,j //判断边i,j是否存在 int *v=aList[i].eraseElement(j); if(v!=NULL) { aList[j].eraseElement(i); e--; }}int linkedGraph::labelComponents(int *c){//返回无向图的构件个数 //令所有顶点是非构件 for(int i=0;i&lt;=n;i++) c[i]=0; label=0; //确定构件 for(int i=1;i&lt;=n;i++) { if(c[i]==0) //顶点i未到达 { label++; bfs(i,c,label); //给新构件做标记 } } return label;}void linkedGraph::bfs(int v,int reach[],int label){ arrayQueue&lt;int&gt; q(10); reach[v]=label; q.push(v); while (!q.empty()) { //从队列中删除一个有标记的顶点 int w=q.front(); q.pop(); //标记所有邻接于顶点w的还没有到达的顶点 for(chainNode&lt;int&gt;* u=aList[w].firstNode;u!=NULL;u=u-&gt;next) { //访问顶点w的一个关联的顶点 if(reach[u-&gt;element]==0) {//u-&gt;element是一个没有到达的顶点 q.push(u-&gt;element); reach[u-&gt;element]=label; //到达标记 } } }}void linkedGraph::bfs_output(int v,int reach[],int label){ arrayQueue&lt;int&gt; q(10); reach[v]=label; cout&lt;&lt;v&lt;&lt;&quot; &quot;; q.push(v); while (!q.empty()) { //从队列中删除一个有标记的顶点 int w=q.front(); q.pop(); //标记所有邻接于顶点w的还没有到达的顶点 for(chainNode&lt;int&gt;* u=aList[w].firstNode;u!=NULL;u=u-&gt;next) { //访问顶点w的一个关联的顶点 if(reach[u-&gt;element]==0) {//u-&gt;element是一个没有到达的顶点 q.push(u-&gt;element); reach[u-&gt;element]=label; //到达标记 cout&lt;&lt;u-&gt;element&lt;&lt;&quot; &quot;; } } } cout&lt;&lt;endl;}void linkedGraph::dfs(int v,int reach[],int label){ linkedGraph::reach=reach; linkedGraph::label=label; rDfs(v);}void linkedGraph::rDfs(int v){//深度优先搜索递归方法 reach[v]=label; myIterator* iv=iterator(v); int u; while((u=iv-&gt;next())!=0) //访问与v相邻的顶点 if(reach[u]==0) rDfs(u); //u是一个没有到达的顶点 delete iv;}void linkedGraph::dfs_output(int v,int reach[],int label){ linkedGraph::reach=reach; linkedGraph::label=label; rDfs_output(v);}void linkedGraph::rDfs_output(int v){//深度优先搜索递归方法 reach[v]=label; cout&lt;&lt;v&lt;&lt;&quot; &quot;; myIterator* iv=iterator(v); int u; while((u=iv-&gt;next())!=0) //访问与v相邻的顶点 if(reach[u]==0) rDfs_output(u); //u是一个没有到达的顶点 delete iv;}int* linkedGraph::findPath(int theSource, int theDestination){//寻找一条从顶点theSource到顶点theDestination的最短路径 //返回一个数组path，从索引1开始表示路径，path[0]表示路径长度 //如果路径不存在，返回NULL //为寻找路径的算法初始化 bool exists=false; path=new int[n+1]; path[1]=theSource; length=0; int *parent=new int[n+1]; //节点的父节点 reach=new int[n+1]; for(int i=1;i&lt;=n;i++) reach[i]=0; //搜索路径 arrayQueue&lt;int&gt; q(10); reach[theSource]=1; q.push(theSource); while (!q.empty()) { //从队列中删除一个有标记的顶点 int w=q.front(); q.pop(); if(w==theDestination) //到达theDestination { exists=true; break; } //标记所有邻接于顶点w的还没有到达的顶点 for(chainNode&lt;int&gt;* u=aList[w].firstNode;u!=NULL;u=u-&gt;next) { //访问顶点w的一个关联的顶点 if(reach[u-&gt;element]==0) {//u-&gt;element是一个没有到达的顶点 q.push(u-&gt;element); reach[u-&gt;element]=label; //到达标记 parent[u-&gt;element]=w; //存储父节点 } } } if(theSource==theDestination || exists) //找到一条最短路径 { //根据parent逆向寻找路径 int i=theDestination; arrayStack&lt;int&gt; stack; stack.push(theDestination); //入栈 while (parent[i]!=theSource) { stack.push(parent[i]); i=parent[i]; } length=stack.size(); path[0]=length; //出栈 for(int k=2;k&lt;=length+1;k++) { path[k]=stack.top(); stack.pop(); } cout&lt;&lt;path[0]&lt;&lt;endl; } else //不存在路径 { delete []path; path=NULL; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; } delete []reach; delete []parent; return path;}template &lt;class T&gt;void bubble_sort(T* array,int size) //及时终止的冒泡排序{ bool sorted=false; //判断是否有序 for(int i=0;i&lt;size-1&amp;&amp;!sorted;i++)//size个数最多进行(size-1)次冒泡 { sorted=true; //每次初始化为有序 for(int j=0;j&lt;size-1-i;j++) { if(array[j+1]&lt;array[j]) { swap(array[j],array[j+1]); sorted = false; //发生了交换,仍处于无序状态 } } }}int main(){ int n,m,s,t; //n个顶点，m个操作，s代表起始点，t代表终点 cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; int instruction,u,v; linkedGraph LG(n); //构建图 for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction&gt;&gt;u&gt;&gt;v; if(instruction==0) LG.insertEdge(u,v); else LG.eraseEdge(u,v); } int *c=new int[n+1]; //c[i]是顶点i的构件号 int *reachDFS=new int[n+1]; //DFS搜索时的标记数组 int *reachBFS=new int[n+1]; //BFS搜索时的标记数组 int cntDFS=0,cntBFS=0; //DFS和BFS序列长度 for(int i=1;i&lt;=n;i++) //初始化 reachDFS[i]=reachBFS[i]=0; //第一行输出图中有多少个连通分量 int components=LG.labelComponents(c); cout&lt;&lt;components&lt;&lt;endl; //第二行输出所有连通子图中最小点的编号（升序），编号间用空格分隔 int *min=new int[components]; //每个连通子图中的最小点的编号 for(int i=0;i&lt;components;i++) //初始化 min[i]=0; for(int i=1;i&lt;=n;i++) { if(min[c[i]-1]==0) min[c[i]-1]=i; else { if(i&lt;min[c[i]-1]) min[c[i]-1]=i; } } //对min[i]排序后输出 bubble_sort(min,components); for(int i=0;i&lt;components;i++) cout&lt;&lt;min[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; //第三行输出从s点开始的dfs序列长度 LG.dfs(s,reachDFS,1); for(int i=1;i&lt;=n;i++) if(reachDFS[i]==1) cntDFS++; cout&lt;&lt;cntDFS&lt;&lt;endl; //第四行输出从s点开始的字典序最小的dfs序列 LG.sortedAList(); for(int i=1;i&lt;=n;i++) reachDFS[i]=0; LG.dfs_output(s,reachDFS,1); cout&lt;&lt;endl; //第五行输出从t点开始的bfs序列的长度 LG.bfs(t,reachBFS,1); for(int i=1;i&lt;=n;i++) if(reachBFS[i]==1) cntBFS++; cout&lt;&lt;cntBFS&lt;&lt;endl; //第六行输出从t点开始字典序最小的bfs序列 LG.sortedAList(); for(int i=1;i&lt;=n;i++) reachBFS[i]=0; LG.bfs_output(t,reachBFS,1); //第七行输出从s点到t点的最短路径，若是不存在路径则输出-1 int *path=LG.findPath(s,t); //释放内存 delete []c; delete []reachDFS; delete []reachBFS; delete []path; delete []min; return 0;} 结果分析 1.求字典序最小的BFS和DFS序列，一种办法是在求之前对邻接表的每个链表排序，另一种办法是在插入边的时候，按照有序链表进行插入。 2.求所有连通子图最小点的编号，需要先求出连通子图个数，然后根据连通子图个数声明一个数组，用来保存每个连通子图的最小点编号。遍历所有顶点，根据该顶点的label值和数组中已经存储的编号，最终得到所有连通子图最小点的编号。进行排序后，即可按照升序输出。 3.求无权图中两个点之间的最短路径，使用BFS搜索即可，在搜索过程中保存当前节点的前驱节点，搜索结束后逆向寻找这条路径中的各个顶点。","link":"/2020/12/23/DSA/DSA_12/"},{"title":"DSA：（十）堆及其应用","text":"优先级队列中，每个元素都有一个优先级。在最小优先级队列中，查找和删除的元素都是优先级最小的元素。在最大优先级队列中，查找和删除的元素都是优先级最大的元素。优先级队列性能较好的是堆结构，一个大根堆（小根堆）既是大根树（小根树），也是完全二叉树。删除和插入的时间复杂度均为O(logn)，初始化的时间复杂度为O(n)。利用堆结构实现堆排序，时间复杂度为O(nlogn)。利用堆和二叉树，实现Huffman编码，保证没有一个编码是另一个编码的前缀，并且WEP最小。 P1016:堆的操作 内容 创建最小堆类，最小堆的存储结构使用数组。提供操作:插入、删除、初始化。题目第一个操作是建堆操作，接下来是对堆的插入和删除操作，插入和删除都在建好的堆上操作。 格式 输入 第一行一个数n（n&lt;=5000)，代表堆的大小。第二行n个数，代表堆的各个元素。 第三行一个数m (m&lt;=1000)，代表接下来共m个操作。接下来m行，分别代表各个操作。下面是各个操作的格式： 插入操作：1 num 删除操作：2 排序操作：第一行两个数3和n，3代表是排序操作，n代表待排序的数的数目，接下来一行n个数是待排序数。 保证排序操作只出现一次且一定是最后一个操作。 输出 第一行建堆操作输出建好堆后堆顶的元素。 接下来m个操作，若是插入和删除操作，每行输出执行操作后堆顶的元素的值；若是排序操作，输出一行按升序排序好的结果，每个元素间用空格分隔。 样例 输入 123456789101112131410-225580 113195 -257251 384948 -83524 331745 179545 293165 125998 376875101 -2325021 -3598331 951232221 2239711 -1187351 -2788433 10-96567 37188 -142422 166589 -169599 245575 -369710 423015 -243107 -108789 输出 1234567891011-257251-257251-359833-359833-257251-232502-225580-225580-225580-278843-369710 -243107 -169599 -142422 -108789 -96567 37188 166589 245575 423015 Limitation 1s, 64MB for each test case. 算法描述 使用数组存储结构，封装小根堆类minHeap，私有成员包括存储堆的数组heap，数组大小arrayLength，小根堆的大小heapSize，公有成员包括构造函数，析构函数，empty方法，size方法，返回堆顶元素的top方法，向堆中插入一个元素的push方法，删除堆顶元素的pop方法，初始化一个小根堆的initialize方法，从堆的析构函数中保存数组的deactiveArray方法。定义模板函数heapSort，利用堆排序对数组进行排序。 top：返回堆顶元素。直接返回heap[1]即可。 pop：删除堆顶元素。首先将堆顶元素heap[1]删除，然后将堆的最后一个元素放在根的位置，依次和左右孩子中较小的进行比较，寻找合适的位置放入。 push：向堆中插入一个元素。首先判断数组容量是否足够，若数组已满，需要进行扩容。为插入的元素寻找插入位置，判断条件是是否到达根节点和theElement值是否小于当前位置的元素值（保证小根堆的结构）。 initialize：初始化一个小根堆。令heap指向数组theHeap，heapSize=theSize。然后从最后一个具有孩子的节点开始扫描，用root表示正在处理的节点，对于每一个root值，利用while循环将以root为根的子树调整为小根堆。 deactiveArray：从堆的析构函数中保存数组。将类的heap指针置空。 heapSort：利用堆排序对数组a[1:n]排序。首先声明一个minHeap类的对象heap，调用initialize方法初始化小根堆，然后每次删除堆顶元素，将其放在数组的最后，最后调用deactivateArray方法，将heap的指针置空，保存数组a。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class minHeap //小根堆{private: T *heap; //保存堆的数组 int arrayLength; //数组大小 int heapSize; //堆的大小public: minHeap(int initialCapacity=10); ~minHeap() {delete []heap;} bool empty() const {return heapSize==0;} int size() const {return heapSize;} T&amp; top() const {return heap[1];} //返回堆顶元素 void pop(); //删除堆顶元素 void push(const T&amp; theElement); //向堆中插入一个元素 void initialize(T* theHeap,int theSize);//初始化一个小根堆 void deactivateArray() {heap=NULL;} //从堆的析构函数中保存数组a};template &lt;class T&gt;minHeap&lt;T&gt;::minHeap(int initialCapacity){ heap=new T[initialCapacity+1]; arrayLength=initialCapacity+1; heapSize=0;}template &lt;class T&gt;void minHeap&lt;T&gt;::pop(){//删除堆顶元素 heap[1].~T(); //删除最小元素 //重新构造堆 T lastElement=heap[heapSize--]; //从根开始，为lastElement寻找合适的位置 int currentNode=1,child=2; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(lastElement&lt;=heap[child]) break; heap[currentNode]=heap[child]; currentNode=child; child*=2; } heap[currentNode]=lastElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::push(const T &amp;theElement){//向堆中插入一个元素 if(heapSize==arrayLength-1) //数组已满 { T* newHeap=new T[arrayLength*2]; arrayLength*=2; copy(heap+1,heap+arrayLength,newHeap+1); delete []heap; heap=newHeap; } //为theElement寻找插入位置 int currentNode=++heapSize; while(currentNode!=1 &amp;&amp; theElement&lt;heap[currentNode/2]) {//不能把theElement放入heap[currentNode] heap[currentNode]=heap[currentNode/2]; currentNode/=2; } heap[currentNode]=theElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::initialize(T *theHeap, int theSize){//初始化一个小根堆 delete []heap; heap=theHeap; heapSize=theSize; arrayLength=theSize+1; //堆化 for(int root=heapSize/2;root&gt;=1;root--) { T rootElement=heap[root]; //子树的根 //寻找放置rootElement的位置 int child=2*root; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(rootElement&lt;=heap[child]) break; heap[child/2]=heap[child]; child*=2; } heap[child/2]=rootElement; }}template &lt;class T&gt;void heapSort(T *a, int n){//利用堆排序对数组a[1:n]进行排序 minHeap&lt;T&gt; heap(1); heap.initialize(a,n); for(int i=n-1;i&gt;=1;i--) { T x=heap.top(); heap.pop(); a[i+1]=x; } heap.deactivateArray(); //从堆的析构函数中保存数组a}int main(){ int n;//堆的大小 cin&gt;&gt;n; int *heapElement=new int[n+1]; for(int i=1;i&lt;=n;i++)//第二行n个数，代表堆的各个元素 cin&gt;&gt;heapElement[i]; minHeap&lt;int&gt; H(1); H.initialize(heapElement,n); cout&lt;&lt;H.top()&lt;&lt;endl; int m,instruction,num; //m个操作和当前的操作 cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch(instruction) { case 1: cin&gt;&gt;num; H.push(num); cout&lt;&lt;H.top()&lt;&lt;endl; break; case 2: H.pop(); cout&lt;&lt;H.top()&lt;&lt;endl; break; case 3: cin&gt;&gt;num; int *unsorted=new int[num+1]; for(int k=1;k&lt;=num;k++) cin&gt;&gt;unsorted[k]; heapSort(unsorted,num); for(int k=num;k&gt;=1;k--) cout&lt;&lt;unsorted[k]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; delete []unsorted; break; } } return 0;} P1017:霍夫曼编码 格式 输入 一串小写字母组成的字符串（不超过1000000)。 输出 输出这个字符串通过Huffman编码后的长度。 样例 输入 1abcdabcaba 输出 119 限制 1s, 1024KiB for each test case. 提示 样例中，‘a’ 出现了4次，‘b’ 出现了3次，‘c’ 出现了2次，‘d’ 出现了1次 编码为: ‘a’ : 0 ‘b’ : 10 ‘c’ : 110 ‘d’ : 111 算法描述 扩充链表存储的二叉树类，增加私有成员WEP，表示Huffman树的WEP值，增加方法computeWEP，计算Huffman树的WEP值，增加方法makeTree，将left，right，element合并成一颗新树。 定义huffmanNode类，表示Huffman树的每个节点。私有成员包括linkedBinaryTree类的指针tree和权值weight。公有成员是对括号的运算符重载，返回weight值。声明类的友元函数HuffmanTree。 HuffmanTree：用权值weight[1:n]构造Huffman树。首先创建一组hNode数组，对于每个hNode[i]，weight值由参数可以得到，tree通过new得到，调用makTree构造出一颗树。创建小根堆heap，heap的每一个元素都是huffmanNode类型，通过小根堆的initialize方法将一组单节点树hNode变成一个小根堆。然后不断从小根堆中取出两棵权值最小的树，将其合并成一个后放入小根堆。函数返回heap.top().tree。 computeWEP：计算Huffman树的WEP值。利用层次遍历，对于遍历到的每个节点，如果其标识为0，则其为内部节点，如果标识不为0，则其为外部节点，根据weight值和当前节点到根节点的路径长度（即层数-1）计算WEP。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//----------------------小根堆----------------------template &lt;class T&gt;class minHeap //小根堆{private: T *heap; //保存堆的数组 int arrayLength; //数组长度 int heapSize; //堆的大小public: minHeap(int initialCapacity=10); ~minHeap() {delete []heap;} bool empty() const {return heapSize==0;} int size() const {return heapSize;} T&amp; top() const {return heap[1];} //返回堆顶元素 void pop(); //删除堆顶元素 void push(const T&amp; theElement); //向堆中插入一个元素 void initialize(T* theHeap,int theSize);//初始化一个小根堆 void heapSort(T* a,int n); //利用堆排序对数组a[1:n]进行排序 void deactivateArray() {heap=NULL;} //从堆的析构函数中保存数组a};template &lt;class T&gt;minHeap&lt;T&gt;::minHeap(int initialCapacity){ heap=new T[initialCapacity+1]; arrayLength=initialCapacity+1; heapSize=0;}template &lt;class T&gt;void minHeap&lt;T&gt;::pop(){//删除堆顶元素 heap[1].~T(); //删除最大元素 //重新构造堆 T lastElement=heap[heapSize--]; //从根开始，为lastElement寻找合适的位置 int currentNode=1,child=2; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(lastElement&lt;=heap[child]) break; heap[currentNode]=heap[child]; currentNode=child; child*=2; } heap[currentNode]=lastElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::push(const T &amp;theElement){//向堆中插入一个元素 if(heapSize==arrayLength-1) //数组已满 { T* newHeap=new T[arrayLength*2]; arrayLength*=2; copy(heap+1,heap+arrayLength,newHeap+1); delete []heap; heap=newHeap; } //为theElement寻找插入位置 int currentNode=++heapSize; while(currentNode!=1 &amp;&amp; theElement&lt;heap[currentNode/2]) {//不能把theElement放入heap[currentNode] heap[currentNode]=heap[currentNode/2]; currentNode/=2; } heap[currentNode]=theElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::initialize(T *theHeap, int theSize){//初始化一个小根堆 delete []heap; heap=theHeap; heapSize=theSize; arrayLength=theSize+1; //堆化 for(int root=heapSize/2;root&gt;=1;root--) { T rootElement=heap[root]; //子树的根 //寻找放置rootElement的位置 int child=2*root; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(rootElement&lt;=heap[child]) break; heap[child/2]=heap[child]; child*=2; } heap[child/2]=rootElement; }}//----------------------队列----------------------template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}//----------------------二叉树----------------------template &lt;class T&gt;struct binaryTreeNode //二叉树节点类{ T element; binaryTreeNode&lt;T&gt; *leftChild, *rightChild; //三个构造函数 binaryTreeNode() {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement):element(theElement) {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement,binaryTreeNode&lt;T&gt;* theLeftChild,binaryTreeNode&lt;T&gt;* theRightChild):element(theElement) { leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class linkedBinaryTree{private: binaryTreeNode&lt;T&gt; *root; //根节点指针 int treeSize; //树的节点个数 int WEP; //Huffman树的WEP值 static void (*visit)(binaryTreeNode&lt;T&gt; *); //访问函数 static void preOrder(binaryTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(binaryTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(binaryTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(binaryTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 static void output(binaryTreeNode&lt;T&gt; *t) {cout&lt;&lt;t-&gt;element&lt;&lt;&quot; &quot;;} //输出节点t的element值 int height(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的高度 int nodeNumber(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的节点个数public: linkedBinaryTree() {root=NULL; treeSize=0; WEP=0;} ~linkedBinaryTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void postOrderOutput() //后序输出序列 {postOrder(output);cout&lt;&lt;endl;} void levelOrder(void(*)(binaryTreeNode&lt;T&gt;*)); //层次遍历 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } int Height() const {return height(root);} //计算二叉树的高度 int NodeNumber() const {return nodeNumber(root);} //计算二叉树的节点个数 void initialize(int num); //二叉树的初始化 void subtreeNodeNumber() const; //输出二叉树中所有节点为根的子树的节点个数 void subtreeHeight() const; //输出二叉树中所有节点为根的子树的高度 binaryTreeNode&lt;T&gt;* buildTree(T* pre,T* in,int len); //通过前序序列pre和中序序列in构造一颗二叉树,len表示序列长度 void update(T* pre,T* in,int len); //将构造的二叉树放到对象中，即更新root和treeSize void makeTree(const T&amp; element,linkedBinaryTree&lt;T&gt;&amp; left,linkedBinaryTree&lt;T&gt;&amp; right); //创建一个二叉树，element为根节点元素，left左子树，right为右子树 int computeWEP(int weight[]); //计算Huffman树的WEP值};template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt; *)=NULL; //类的静态成员的初始化template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::preOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { linkedBinaryTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::inOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); linkedBinaryTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::postOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); linkedBinaryTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::height(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int hl=height(t-&gt;leftChild); int hr=height(t-&gt;rightChild); if(hl&gt;hr) return ++hl; else return ++hr;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::nodeNumber(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int nl=nodeNumber(t-&gt;leftChild); int nr=nodeNumber(t-&gt;rightChild); return nl+nr+1;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::levelOrder(void (*theVisit)(binaryTreeNode&lt;T&gt; *)){ binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; while (t!=NULL) { theVisit(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else return ; q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::initialize(int num){//二叉树的初始化 //这棵树有num个节点，编号为1~num，根节点为1 //读入编号为i的节点的左孩子a，右孩子b，-1表示该位置没有节点 root=new binaryTreeNode&lt;T&gt;(1); treeSize=num; int *left=new int[num+1]; //左孩子 int *right=new int[num+1]; //右孩子 binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; for(int i=1;i&lt;=num;i++) cin&gt;&gt;left[i]&gt;&gt;right[i]; int cur=t-&gt;element; //当前节点的element值 //利用层次遍历进行初始化 while (t!=NULL) { if(left[cur]!=-1) t-&gt;leftChild=new binaryTreeNode&lt;T&gt;(left[cur]); if(right[cur]!=-1) t-&gt;rightChild=new binaryTreeNode&lt;T&gt;(right[cur]); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //初始化完成 { delete []left; delete []right; return ; } q.pop(); cur=t-&gt;element; }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeNodeNumber() const{//输出二叉树中所有节点为根的子树的节点个数 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的节点个数 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=nodeNumber(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeHeight() const{//输出二叉树中所有节点为根的子树的高度 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的高度 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=height(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;binaryTreeNode&lt;T&gt;* linkedBinaryTree&lt;T&gt;::buildTree(T *pre, T *in, int len){//根据前序序列pre和中序序列in构建二叉树 //len表示序列长度 //返回二叉树的根节点 //序列长度小于等于0，不需要继续构造 if(len&lt;=0) return NULL; binaryTreeNode&lt;T&gt;* subRoot=new binaryTreeNode&lt;T&gt;(pre[0]); //pre[0]为根节点 int index=0; //在中序序列中查找pre[0] for(int i=0;i&lt;len;i++) if(in[i]==pre[0]) { index=i; break; } //递归构造左子树和右子树 subRoot-&gt;leftChild=buildTree(pre+1,in,index); subRoot-&gt;rightChild=buildTree(pre+index+1,in+index+1,len-index-1); return subRoot;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::update(T* pre,T* in,int len){//将构造的二叉树放到对象中，即更新root和treeSize root=buildTree(pre, in, len); treeSize=len;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::makeTree(const T &amp;element, linkedBinaryTree&lt;T&gt; &amp;left, linkedBinaryTree&lt;T&gt; &amp;right){//将left,right和element合并成一颗新树 root=new binaryTreeNode&lt;T&gt;(element,left.root,right.root); treeSize=left.treeSize+right.treeSize+1; left.root=right.root=NULL; left.treeSize=right.treeSize=0;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::computeWEP(int weight[]){//计算Huffman树的WEP值 int road=0; //当前节点到根节点的路径长度 arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; q.push(root); while(1) { int length=q.size(); if(length==0) break; while(length&gt;0) { binaryTreeNode&lt;T&gt;* cur; cur=q.front(); q.pop(); length--; if(cur-&gt;element!=0) WEP+=weight[cur-&gt;element]*road; if(cur-&gt;leftChild!=NULL) q.push(cur-&gt;leftChild); if(cur-&gt;rightChild!=NULL) q.push(cur-&gt;rightChild); } road++; } if(WEP==0) //Huffman树只有根节点 return weight[1]; return WEP;}template &lt;class T&gt;linkedBinaryTree&lt;int&gt;* HuffmanTree(T weight[],int n); //用权值weight[1:n]构造霍夫曼树,n&gt;=1template &lt;class T&gt;class huffmanNode{ friend linkedBinaryTree&lt;int&gt;* HuffmanTree&lt;T&gt;(T weight[],int n); //友元函数的声明public: operator T() const {return weight;}private: linkedBinaryTree&lt;int&gt; *tree; T weight;};template &lt;class T&gt;linkedBinaryTree&lt;int&gt;* HuffmanTree(T weight[],int n){//用权值weight[1:n]构造霍夫曼树,n&gt;=1 //创建一组单节点树hNode数组 huffmanNode&lt;T&gt;* hNode=new huffmanNode&lt;T&gt;[n+1]; linkedBinaryTree&lt;int&gt; emptyTree; for(int i=1;i&lt;=n;i++) { hNode[i].weight=weight[i]; hNode[i].tree=new linkedBinaryTree&lt;int&gt;; hNode[i].tree-&gt;makeTree(i,emptyTree,emptyTree); } //将一组单节点树hNode[1:n]变成一个小根堆 minHeap&lt;huffmanNode&lt;T&gt;&gt; heap(1); heap.initialize(hNode,n); //不断从最小堆中取出两颗树合并成一个放入，直到剩下一颗 huffmanNode&lt;T&gt; w,x,y; linkedBinaryTree&lt;int&gt; *z; for(int i=1;i&lt;n;i++) { //从最小堆中选出两颗权值最小的树 x=heap.top(); heap.pop(); y=heap.top(); heap.pop(); //合并成一颗树w，放入堆 z=new linkedBinaryTree&lt;int&gt;; z-&gt;makeTree(0,*x.tree,*y.tree); w.weight=x.weight+y.weight; w.tree=z; heap.push(w); delete x.tree; delete y.tree; } return heap.top().tree;}int main(){ string str; cin&gt;&gt;str; int t[26]={0}; int weight[27]={0}; int size=0; for(int i=0;i&lt;str.size();i++) t[str.at(i)-'a']++; for(int i=0;i&lt;26;i++) if(t[i]!=0) weight[++size]=t[i]; linkedBinaryTree&lt;int&gt;* p=HuffmanTree(weight,size); cout&lt;&lt;p-&gt;computeWEP(weight)&lt;&lt;endl; return 0;} 结果分析 1.模板类声明友元的函数如果是模板函数，声明时需要在友元函数的函数名之后参数之前加上。 2.堆排序是不稳定的。 3.根据Huffman树求Huffman编码，可以对Huffman树进行后序遍历，利用栈记录走过的分支，如果是左分支，栈内进0，如果是右分支，栈内进1，直到到达一个外部节点，此时栈内记录的就是该节点对应的Huffman编码，然后继续后序遍历，直到遍历结束。","link":"/2020/12/23/DSA/DSA_10/"},{"title":"DSA：（四）链式描述线性表","text":"本文通过两个具体的题目实现线性表的链式描述，并为链表类封装了前向迭代器，链表类的方法包括插入、删除、原地逆置、查询、输出异或和、箱子排序、二路归并。 P1005:链表实现 要求 1.封装链表类，链表迭代器类。 2.链表类需提供操作：在指定位置插入元素，删除指定元素，搜索链表中是否有指定元素，原地逆置链表，输出链表。 3.不得使用与链表实现相关的STL。 描述 第一行两个整数N和Q。 第二行N个整数，作为节点的元素值，创建链表。 接下来Q行，执行各个操作，具体格式如下： 12345插入操作: 1 idx val //在链表的idx位置插入元素val删除操作: 2 val //删除链表中的val元素。若链表中存在多个该元素，仅删除第一个。若该元素不存在，输出-1逆置操作: 3 //原地逆置链表查询操作: 4 val //查询链表中的 val 元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引。若不存在该元素，输出-1输出操作: 5 //使用链表迭代器，输出当前链表索引与元素的异或和 样例 输入 点击右上角可直接复制。 12345678910111210 106863 35084 11427 53377 34937 14116 5000 49692 70281 73704 4 68631 2 4419954 214661 6 1148354 3493754 68631 10 18635 输出 12345670398665-141014154101410 限制 1s 算法描述 定义结构体chainNode，数据成员包含element和next，element为数据域，next为指针域。方法包括三个重载的构造函数，默认构造函数，通过元素element创建节点，通过元素element和指针next创建节点。 使用链式存储结构，封装链表类chain，保护成员包括指向链表首节点的指针firstNode和链表长度listSize。公有成员包括构造函数，复制构造函数，析构函数，以及具体的方法，包括插入操作，删除操作，原地逆置操作，查询操作，输出操作。 定义链表类的迭代器iterator，保护成员为节点类的指针node，公有成员包括构造函数，操作符重载函数（解引用操作符 * 和-&gt;，前++，后++，相等检验中的!=和==），在chain类中增加方法begin和end，返回指向链表首元素的指针和尾元素的指针。 读入数据时，按行读入，首先读入操作数instruction，根据操作数利用switch分支进行分类，再根据所属操作类别读入对应的数据，调用对应的成员函数，输出数据。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct chainNode //节点类{ //数据成员 T element; chainNode&lt;T&gt;* next; //方法 chainNode() {} chainNode(const T&amp; element) { this-&gt;element=element; } chainNode(const T&amp; element,chainNode&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};template &lt;class T&gt;class chain //链表类{protected: chainNode&lt;T&gt;* firstNode; //指向链表第一个节点的指针 int listSize; //线性表的元素个数public: chain(); //构造函数 chain(const chain&lt;T&gt;&amp; theList); //复制构造函数 ~chain(); //析构函数 //方法 void insert(int idx,const T&amp; val); //在链表的idx位置插入元素val void erase(const T&amp; val); //删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 void reverse(); //原地逆置链表 int search(const T&amp; val) const; //查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 int output() const; //输出当前链表索引与元素的异或和 //迭代器 class iterator { protected: chainNode&lt;T&gt;* node; public: //用C++的typedef语句实现前向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(chainNode&lt;T&gt;* theNode=NULL) //构造函数 { node=theNode; } //解引用操作符 T&amp; operator* () const {return node-&gt;element;} T* operator-&gt; () const {return &amp;node-&gt;element;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { node=node-&gt;next; return *this; } iterator operator++ (int)//后++ { iterator old=*this; node=node-&gt;next; return old; } //相等检验 bool operator!= (const iterator&amp; right) const { return node!=right.node; } bool operator== (const iterator&amp; right) const { return node==right.node; } }; iterator begin() const { return iterator(firstNode); } iterator end() const { return iterator(NULL); }};template &lt;class T&gt;chain&lt;T&gt;::chain() //构造函数{ firstNode=NULL; listSize=0;}template &lt;class T&gt;chain&lt;T&gt;::chain(const chain&lt;T&gt;&amp; theList) //复制构造函数{ listSize=theList.listSize; //链表为空 if(listSize==0) { firstNode=NULL; return ; } //链表不为空 chainNode&lt;T&gt;* sourceNode=theList.firstNode; firstNode=new chainNode&lt;T&gt;(sourceNode-&gt;element);//复制theList的首元素 sourceNode=sourceNode-&gt;next; chainNode&lt;T&gt;* targetNode=firstNode; while(sourceNode!=NULL) //复制剩余元素 { targetNode-&gt;next=new chainNode&lt;T&gt;(sourceNode-&gt;element); targetNode=targetNode-&gt;next; sourceNode=sourceNode-&gt;next; } targetNode-&gt;next=NULL; //尾结点}template &lt;class T&gt;chain&lt;T&gt;::~chain() //析构函数{ while(firstNode!=NULL) { chainNode&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;void chain&lt;T&gt;::insert(int idx,const T&amp; val) //插入操作{//在链表的idx位置插入元素val if(idx==0)//在链表头插入 { firstNode=new chainNode&lt;T&gt;(val,firstNode); } else { //寻找前驱 chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;idx-1;i++) p=p-&gt;next; //在p之后插入 p-&gt;next=new chainNode&lt;T&gt;(val,p-&gt;next); } listSize++;}template &lt;class T&gt;void chain&lt;T&gt;::erase(const T&amp; val) //删除操作{//删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 chainNode&lt;T&gt;* deleteNode; //要删除的节点 if(firstNode-&gt;element==val) //删除的是链表的首节点 { deleteNode=firstNode; firstNode=firstNode-&gt;next; } else //删除的不是链表的首节点 { chainNode&lt;T&gt;* previousNode=firstNode; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; previousNode=previousNode-&gt;next; } if(currentNode==NULL) //链表中不存在要删除的元素 { cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return ; } else //链表中存在要删除的元素 { deleteNode=currentNode; previousNode-&gt;next=currentNode-&gt;next; } } listSize--; delete deleteNode;}template &lt;class T&gt;void chain&lt;T&gt;::reverse() //原地逆置{ if(listSize==0) //链表为空 return ; else { chainNode&lt;T&gt;* currentNode=firstNode; //当前节点 while(currentNode-&gt;next) //当前节点还有后继元素 { chainNode&lt;T&gt;* p=currentNode-&gt;next; //储存当前节点的后继元素 currentNode-&gt;next=p-&gt;next; //将p断开 p-&gt;next=firstNode; //将p连在首节点的前面 firstNode=p; //设置p为首节点 } }}template &lt;class T&gt;int chain&lt;T&gt;::search(const T&amp; val) const //查询操作{//查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 chainNode&lt;T&gt;* currentNode=firstNode; int index=0; //当前节点的索引 while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; //移向下一个节点 index++; } //确定是否找到元素 if(currentNode!=NULL) return index; else { return -1; }}template &lt;class T&gt;int chain&lt;T&gt;::output() const //输出输出当前链表索引与元素的异或和{ int res=0,index=0; for(iterator i=this-&gt;begin();i!=this-&gt;end();i++) //通过迭代器遍历链表 { res+=index^*i; index++; } return res;}int main(){ int n,q; //n个整数 q行操作 int value; //读取初始链表的各个元素值 int instruction; //指令编号 int idx,val; //读入的索引、元素信息 cin&gt;&gt;n&gt;&gt;q; chain&lt;int&gt; A; //创建对象 for(int i=0;i&lt;n;i++) //将数据插入链表 { cin&gt;&gt;value; A.insert(i,value); } //执行各项操作 for(int i=0;i&lt;q;i++) { cin&gt;&gt;instruction; switch(instruction) { case 1: //插入操作 cin&gt;&gt;idx&gt;&gt;val; A.insert(idx,val); break; case 2: //删除操作 cin&gt;&gt;val; A.erase(val); break; case 3: //原地逆置 A.reverse(); break; case 4: //查询操作 cin&gt;&gt;val; cout&lt;&lt;A.search(val)&lt;&lt;endl; break; case 5: //输出操作 cout&lt;&lt;A.output()&lt;&lt;endl; break; } } return 0;} 结果分析 1.迭代器可以理解为广义的指针，在链表的一些操作中，使用迭代器会减少一些操作的时间复杂度。例如，在链表chain中，从左至右访问线性表的元素时，使用get方法和使用迭代器方法，在运行时间上的差别是很大的。如果一次考察一个元素，get方法的时间复杂度为O(n^2)，迭代器方法的时间复杂度为O(n)。 2.对chain类可以扩展一些ADT方法，比如clear（清除表中所有元素）和push_back(theElement)（将元素theElement插入表尾）。以chain类为基类，派生出extendedChain类，在extendedChain类中增加protected成员lastNode，实现方法clear和push_back，改进erase和insert方法。 P1006:链表合并 要求 1.使用题目“链表实现”中实现的链表类、迭代器类完成本题。 2.不得使用与题目实现相关的STL。 描述 给定两组整数序列，你需要分别创建两个有序链表，使用链表迭代器实现链表的合并，并分别输出这三个有序链表的索引与元素的异或和。 Note:给定序列是无序的，你需要首先得到一个有序的链表。 格式 输入 第一行两个整数N和M。 第二行N个整数，代表第一组整数序列。 第三行M个整数，代表第二组整数序列。 输出 三行整数。分别代表第一组数、第二组数对应的有序链表与合并后有序链表的索引与元素的异或和。 样例 输入 点击右上角可直接复制。 123 03 1 2 输出 123505 限制 1s 算法描述 使用已经封装的链表类和迭代器，增加方法getMax求链表元素的最大值，getMin求链表元素的最小值，binSort进行箱子排序，merge实现两个链表的归并。 binSort的两个参数为链表元素的最大值和最小值，首先判断是否是空表，若是空表直接返回。若不是空表，根据min和max的值判断链表中元素的正负，分为三种情况，均&gt;=0，均&lt;=0，有正有负，对应相应的range（范围）和offset（偏移量），再进行箱子排序。在分配箱子时，将对应元素分配到theBin+offset的箱子中，收集箱子时，按照theBin从0到range进行收集。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct chainNode //节点类{ //数据成员 T element; chainNode&lt;T&gt;* next; //方法 chainNode() {} chainNode(const T&amp; element) { this-&gt;element=element; } chainNode(const T&amp; element,chainNode&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};template &lt;class T&gt;class chain //链表类{protected: chainNode&lt;T&gt;* firstNode; //指向链表第一个节点的指针 int listSize; //线性表的元素个数public: chain(); //构造函数 chain(const chain&lt;T&gt;&amp; theList); //复制构造函数 ~chain(); //析构函数 //方法 void insert(int idx,const T&amp; val); //在链表的idx位置插入元素val void erase(const T&amp; val); //删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 void reverse(); //原地逆置链表 int search(const T&amp; val) const; //查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 int output() const; //输出当前链表索引与元素的异或和 int size() const {return listSize;} //返回链表的元素个数 int getMax() const; //求链表中元素的最大值 int getMin() const; //求链表中元素的最小值 void binSort(int max,int min); //箱子排序 void merge(const chain&lt;T&gt;&amp; a,const chain&lt;T&gt;&amp; b);//将链表a,b归并到当前链表中 //迭代器 class iterator { protected: chainNode&lt;T&gt;* node; public: //用C++的typedef语句实现前向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(chainNode&lt;T&gt;* theNode=NULL) //构造函数 { node=theNode; } //解引用操作符 T&amp; operator* () const {return node-&gt;element;} T* operator-&gt; () const {return &amp;node-&gt;element;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { node=node-&gt;next; return *this; } iterator operator++ (int)//后++ { iterator old=*this; node=node-&gt;next; return old; } //相等检验 bool operator!= (const iterator&amp; right) const { return node!=right.node; } bool operator== (const iterator&amp; right) const { return node==right.node; } }; iterator begin() const { return iterator(firstNode); } iterator end() const { return iterator(NULL); }};template &lt;class T&gt;chain&lt;T&gt;::chain() //构造函数{ firstNode=NULL; listSize=0;}template &lt;class T&gt;chain&lt;T&gt;::chain(const chain&lt;T&gt;&amp; theList) //复制构造函数{ listSize=theList.listSize; //链表为空 if(listSize==0) { firstNode=NULL; return ; } //链表不为空 chainNode&lt;T&gt;* sourceNode=theList.firstNode; firstNode=new chainNode&lt;T&gt;(sourceNode-&gt;element);//复制theList的首元素 sourceNode=sourceNode-&gt;next; chainNode&lt;T&gt;* targetNode=firstNode; while(sourceNode!=NULL) //复制剩余元素 { targetNode-&gt;next=new chainNode&lt;T&gt;(sourceNode-&gt;element); targetNode=targetNode-&gt;next; sourceNode=sourceNode-&gt;next; } targetNode-&gt;next=NULL; //尾结点}template &lt;class T&gt;chain&lt;T&gt;::~chain() //析构函数{ while(firstNode!=NULL) { chainNode&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;void chain&lt;T&gt;::insert(int idx,const T&amp; val) //插入操作{//在链表的idx位置插入元素val if(idx==0)//在链表头插入 { firstNode=new chainNode&lt;T&gt;(val,firstNode); } else { //寻找前驱 chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;idx-1;i++) p=p-&gt;next; //在p之后插入 p-&gt;next=new chainNode&lt;T&gt;(val,p-&gt;next); } listSize++;}template &lt;class T&gt;void chain&lt;T&gt;::erase(const T&amp; val) //删除操作{//删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 chainNode&lt;T&gt;* deleteNode; //要删除的节点 if(firstNode-&gt;element==val) //删除的是链表的首节点 { deleteNode=firstNode; firstNode=firstNode-&gt;next; } else //删除的不是链表的首节点 { chainNode&lt;T&gt;* previousNode=firstNode; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; previousNode=previousNode-&gt;next; } if(currentNode==NULL) //链表中不存在要删除的元素 { cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return ; } else //链表中存在要删除的元素 { deleteNode=currentNode; previousNode-&gt;next=currentNode-&gt;next; } } listSize--; delete deleteNode;}template &lt;class T&gt;void chain&lt;T&gt;::reverse() //原地逆置{ if(listSize==1) //链表只有一个元素 return ; else { chainNode&lt;T&gt;* currentNode=firstNode; //当前节点 while(currentNode-&gt;next) //当前节点还有后继元素 { chainNode&lt;T&gt;* p=currentNode-&gt;next; //储存当前节点的后继元素 currentNode-&gt;next=p-&gt;next; //将p断开 p-&gt;next=firstNode; //将第一个节点连在p的后面 firstNode=p; //设置p为第一个节点 } }}template &lt;class T&gt;int chain&lt;T&gt;::search(const T&amp; val) const //查询操作{//查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 chainNode&lt;T&gt;* currentNode=firstNode; int index=0; //当前节点的索引 while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; //移向下一个节点 index++; } //确定是否找到元素 if(currentNode!=NULL) return index; else { return -1; }}template &lt;class T&gt;int chain&lt;T&gt;::output() const //输出当前链表索引与元素的异或和{ int res=0,index=0; for(iterator i=this-&gt;begin();i!=this-&gt;end();i++) //通过迭代器遍历链表 { res+=index^*i; index++; } return res;}template &lt;class T&gt;int chain&lt;T&gt;::getMax() const //求当前链表中元素的最大值{ if(listSize==0) //空表 return 0; int max=firstNode-&gt;element; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL) { if(currentNode-&gt;element&gt;max) max=currentNode-&gt;element; currentNode=currentNode-&gt;next; } return max;}template &lt;class T&gt;int chain&lt;T&gt;::getMin() const //求当前链表中元素的最小值{ if(listSize==0) //空表 return 0; int min=firstNode-&gt;element; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL) { if(currentNode-&gt;element&lt;min) min=currentNode-&gt;element; currentNode=currentNode-&gt;next; } return min;}template &lt;class T&gt;void chain&lt;T&gt;::binSort(int max,int min) //箱子排序{ //空表 if(listSize==0) return ; //不是空表 int range=0,offset=0; //范围和偏移量 if(min&gt;=0) //链表所有元素均为非负整数 { range=max; offset=0; } else if(max&lt;=0) //链表所有元素均为非正整数 { range=-min; offset=-min; } else //链表元素有正有负 { range=max-min; offset=-min; } //创建并初始化箱子 chainNode&lt;T&gt; **bottom,**top; bottom=new chainNode&lt;T&gt;* [range+1]; top=new chainNode&lt;T&gt;* [range+1]; for(int i=0;i&lt;=range;i++) //初始化为空 bottom[i]=NULL; //把链表的节点分配到箱子 for(;firstNode!=NULL;firstNode=firstNode-&gt;next) {//把首节点firstNode加到箱子中 int theBin=firstNode-&gt;element; if(bottom[theBin+offset]==NULL) //箱子为空 bottom[theBin+offset]=top[theBin+offset]=firstNode; else //箱子不为空 { top[theBin+offset]-&gt;next=firstNode; top[theBin+offset]=firstNode; } } //把箱子中的节点收集到有序链表 chainNode&lt;T&gt; *y=NULL; for(int theBin=0;theBin&lt;=range;theBin++) { if(bottom[theBin]!=NULL) //箱子不空 { if(y==NULL) //收集的是第一个非空箱子 firstNode=bottom[theBin]; else //收集的不是第一个非空箱子 y-&gt;next=bottom[theBin]; y=top[theBin]; } } if(y!=NULL) //处理尾结点 y-&gt;next=NULL; delete [] bottom; delete [] top;}template &lt;class T&gt;void chain&lt;T&gt;::merge(const chain&lt;T&gt; &amp;a, const chain&lt;T&gt; &amp;b) //将链表a,b归并到当前链表中{ int index=0; iterator ia=a.begin(),ib=b.begin(); while(ia!=a.end() &amp;&amp; ib!=b.end()) { if(*ia&lt;*ib) //将*ia并入 { insert(index++,*ia); ia++; } else //将*ib并入 { insert(index++,*ib); ib++; } } //对a或b中剩余元素进行归并 while(ia!=a.end()) { insert(index++,*ia); ia++; } while(ib!=b.end()) { insert(index++,*ib); ib++; } listSize=a.size()+b.size();}int main(){ int n,m; //两个整数 int value; //读取初始链表的各个元素值 cin&gt;&gt;n&gt;&gt;m; chain&lt;int&gt; A,B,C; //创建对象 for(int i=0;i&lt;n;i++) //将数据插入链表A { cin&gt;&gt;value; A.insert(i,value); } for(int i=0;i&lt;m;i++) //将数据插入链表B { cin&gt;&gt;value; B.insert(i,value); } A.binSort(A.getMax(),A.getMin()); B.binSort(B.getMax(),B.getMin()); C.merge(A,B); cout&lt;&lt;A.output()&lt;&lt;endl; cout&lt;&lt;B.output()&lt;&lt;endl; cout&lt;&lt;C.output()&lt;&lt;endl; return 0;} 结果分析 1.一般情况的箱子排序只需要参数range，条件是链表中的元素值均为非负整数，而题目中链表元素值包括负数，因此需要根据链表中的最大值和最小值确定range和offset。 2.由箱子排序衍生出基数排序，所谓基数排序，是把数按照某种基数r分解为数字，然后对数字排序。例如，用基数10把十进制数928分解为9、2、8。利用箱子排序方法，从最低位开始依次到最高位，根据当前位的数字对数据进行排序。基数排序和箱子排序时间复杂度虽然相同，但使用基数排序极大地减少了程序的执行步数。单个的箱子排序实际上相当于r=1000的基数排序。基数排序的基数不同，总的执行步数也不同，根据实际数据确定基数减少执行步数。 3.箱子排序和基数排序都是稳定的。 4.箱子排序还有类外函数的实现方法，但执行了很多new和delete操作将节点从一个位置移动到另一个位置，虽然时间复杂度与成员函数相同，但效率比较低。","link":"/2020/10/14/DSA/DSA_4/"},{"title":"DSA：（六）栈","text":"数学表达式根据运算符和数字的相对位置可以分为前缀、中缀、后缀三种，前缀表达式又叫波兰表达式，后缀表达式又叫逆波兰表达式，这两种表达式都不含括号。中缀表达式可以转换为前缀表达式和后缀表达式，转换过程以及计算过程都需要用到栈结构。本文通过两种方法实现数学表达式的计算，方法一将中缀表达式转换为后缀表达式，然后进行计算，方法二直接对中缀表达式进行计算。 P1010:计算表达式 题目描述 创建栈类，采用数组描述。 计算数学表达式的值。 输入数学表达式，输出表达式的计算结果。数学表达式由单个数字和运算符 + 、 - 、 * 、 / 、 ( 、 ) 构成，例如 2 + 3 * ( 4 + 5 )- 6 / 4。假定表达式输入格式合法。 格式 输入 第一行一个整数n(1&lt;=n&lt;=100)，代表表达式的个数。 接下来n行，每行一个表达式，保证表达式内的数字为单个整数，表达式内各运算符和数字间没有空格，且表达式的长度不超过2000。 输出 每行表达式输出一个浮点数，要求保留两位小数，保证输入表达式合法。 注意 因为精度问题，请使用double存数据。 样例 输入 123431+6/1*7+2*1*4+9/1+2*0*9+9+7/(9*5)-1*6-0*8-7-9*2+6-(0-5-2*8-7-9*5*(6-5*5*2*6-2-7-5+6*7+6*9-1*0*0+3*0+2/1-6/6+5))0-4-1/6*(1-(6/7)-4+6+2+6*1)-1*7+2-8*2+0-(4+6-6*1+(3-8*6/4-6-5)*6/4/8+7-1*4/9*5)-0/6+1-0-2+7-2+6*4-3*6+2/8+6+1*6*25-3*9+5/1*5-9+1*8-6-8-4*1+5-2+9/3*2-2/5/(2-6)*2/7-9*0-2+4/6*6*7*8-8-8*6+8*9*(3+0*1/5/2*7*8+0-8*8-5+8/5*2-0) 输出 123-9197.84-3.47-4362.57 限制 1s, 65536KiB for each test case. 算法描述和实现 方法一 使用数组存储结构，封装栈类arrayStack，私有成员包括栈顶stackTop，栈容量arrayLength，元素数组stack。公有成员包括构造函数，析构函数，ADT方法包括判断栈是否为空，返回栈中元素个数，返回栈顶元素，删除栈顶元素，将元素压入栈顶。 封装calculator类，私有成员包括一个double类型的栈，字符串s。公有成员包括输入，将中缀表达式转换为后缀表达式，处理后缀表达式，取2个操作数，对2个操作数进行运算，返回运算符优先级，输出结果，将char类型的数字转换为double类型，每个方法的具体思想如下： input：读入表达式（中缀）到私有成员s中。 change：将中缀表达式转换为后缀表达式。使用char类型的栈临时存储运算符。声明string类型的变量_s，用来临时存储后缀表达式。引入标记字符’#’，将其插入到运算符栈中，并规定其优先级为最低，这样做可以不用对栈空的情况进行特殊考虑。遍历表达式中每个字符，根据字符类型进行对应操作。字符串s遍历完毕后，如果栈顶元素不为标记字符（即栈非空），按顺序依次弹出栈中的元素，插入到_s的末端。 运算数：直接插入到_s的末端。 四则运算符：将该运算符与栈顶运算符优先级进行比较，如果优先级高于栈顶运算符，表示该部分运算还不能进行，将其压入栈；如果优先级低于或等于（优先级相同从左到右运算）栈顶运算符，表示前面部分的运算可以进行，将栈顶运算符弹出并插入到_s的末端，然后继续与新的栈顶运算符进行比较，直到优先级大于栈顶运算符（栈空的情况已经包含，因为设置标记字符的优先级为最低）,再将该运算符入栈。 左括号：直接压入栈，入栈后优先级降到最低，保证其它运算符正常入栈。 右括号：依次弹出栈顶运算符，并插入到_s的末端，直到遇到左括号。最后将左括号从栈顶删除。 operate：处理后缀表达式。遍历后缀表达式中的每个字符，如果是数字则入操作数栈，如果是操作符则取数进行运算。 getTwoNumbers：获取两个操作数。 calculate：对两个操作数进行运算。先使用getTwoNumbers方法获取两个操作数，然后根据运算符的类型进行对应的运算，将结果压入numberStack栈中。 order：返回运算符优先级。加减为1，乘除为2，左括号为0，右括号为3，标记符号为0。 output：输出最终结果。按照2位小数输出操作数栈的栈顶元素。 charToDouble：将char类型的数字字符转换为double类型。返回数字字符与’0’的差。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;template &lt;class T&gt;class arrayStack{private: int stackTop; //栈顶 int arrayLength; //栈容量 T* stack; //元素数组public: //构造函数、析构函数 arrayStack(int initialCapacity=10); ~arrayStack() {delete []stack;} //ADT方法 bool empty() const {return stackTop==-1;} int size() const {return stackTop+1;} T&amp; top(); void pop(); void push(const T&amp; theElement);};template &lt;class T&gt;arrayStack&lt;T&gt;::arrayStack(int initialCapacity){ arrayLength=initialCapacity; stack=new T[arrayLength]; stackTop=-1;}template &lt;class T&gt;T&amp; arrayStack&lt;T&gt;::top(){ return stack[stackTop];}template &lt;class T&gt;void arrayStack&lt;T&gt;::pop(){ stack[stackTop--].~T();}template &lt;class T&gt;void arrayStack&lt;T&gt;::push(const T&amp; theElement){ if(stackTop==arrayLength-1) {//空间已满，容量加倍 T* newStack=new T[arrayLength*2]; arrayLength*=2; for(int i=0;i&lt;=stackTop;i++) newStack[i]=stack[i]; delete []stack; stack=newStack; } //在栈顶插入 stack[++stackTop]=theElement;}class calculator{private: arrayStack&lt;double&gt; numberStack; //操作数栈 string s; //存储中缀表达式和后缀表达式public: void input(); //读入中缀表达式 void change(); //将中缀表达式转换为后缀表达式 void operate(); //遍历后缀表达式中的每个字符，如果是数字则入栈，如果是操作符则取数进行运算 void getTwoNumbers(double &amp;num1,double &amp;num2); //获取两个操作数 void calculate(char op); //对两个操作数进行op运算 int order(char op); //运算符优先级 void output(); //输出最终结果 double charToDouble(char ch); //将char类型的数字字符转换为double类型};void calculator::input(){//读入中缀表达式 cin&gt;&gt;s;}void calculator::change(){//将中缀表达式转换为后缀表达式 arrayStack&lt;char&gt; operatorStack; //暂存运算符的栈 string _s; //暂存转换后的字符串 char ch; //当前的字符 operatorStack.push('#'); for(int i=0;i&lt;(int)s.size();i++) { ch=s.at(i); if(ch=='(') //左括号 { operatorStack.push(ch); } else if(ch==')') //右括号 { while(operatorStack.top()!='(') { _s.push_back(operatorStack.top()); operatorStack.pop(); } operatorStack.pop(); } else if(ch=='+'||ch=='-'||ch=='*'||ch=='/') //四则运算符 { char w=operatorStack.top(); if(order(w)&lt;order(ch)) { operatorStack.push(ch); } else { while(order(w)&gt;=order(ch)) { _s.push_back(w); operatorStack.pop(); w=operatorStack.top(); } operatorStack.push(ch); } } else//数字 { _s.push_back(ch); } } while(operatorStack.top()!='#') { _s.push_back(operatorStack.top()); operatorStack.pop(); } s=_s;}void calculator::getTwoNumbers(double &amp;num1,double &amp;num2){//获取两个操作数 num1=numberStack.top(); numberStack.pop(); num2=numberStack.top(); numberStack.pop();}void calculator::operate(){//遍历后缀表达式中的每个字符，如果是数字则入栈，如果是操作符则取数进行运算 for(int i=0;i&lt;(int)s.size();i++) { switch (s.at(i)) { case '-': case '+': case '*': case '/': calculate(s.at(i)); break; default: numberStack.push(charToDouble(s.at(i))); break; } }}void calculator::calculate(char op){//对两个操作数进行op运算 double number1,number2; getTwoNumbers(number1,number2); switch (op) { case '+':numberStack.push(number2+number1); break; case '-':numberStack.push(number2-number1); break; case '*':numberStack.push(number2*number1); break; case '/':numberStack.push(number2/number1); break; default: break; }}int calculator::order(char op){//运算符优先级 int val; if(op=='+'||op=='-') val=1; else if(op=='*'||op=='/') val=2; else if(op==')') val=3; else val=0; return val;}void calculator::output(){//输出最终结果 printf(&quot;%.2f\\n&quot;,numberStack.top());}double calculator::charToDouble(char ch){//将char类型的数字字符转换为double类型 double result=ch-'0'; return result;}int main(){ int n; //表达式个数 cin&gt;&gt;n; calculator c; for(int i=0;i&lt;n;i++) { c.input(); c.change(); c.operate(); c.output(); } return 0;} 方法二 使用数组存储结构，封装栈类arrayStack，私有成员包括栈顶stackTop，栈容量arrayLength，元素数组stack。公有成员包括构造函数，析构函数，ADT方法包括判断栈是否为空，返回栈中元素个数，返回栈顶元素，删除栈顶元素，将元素压入栈顶。 封装calculator类，私有成员包括一个double类型的操作数栈，一个char类型的运算符栈，字符串s。公有成员包括输入，遍历表达式进行相应处理，取2个操作数，对2个操作数进行运算，返回运算符优先级，输出结果，将char类型的数字转换为double类型，每个方法的具体思想如下： input：读入表达式到私有成员s中。 operate：遍历表达式中的每个字符，进行对应操作。operateStack栈存储运算符，首先将栈空的标记字符压入栈中，并规定其优先级为最低，这样做可以不用对栈空的情况进行特殊考虑。遍历表达式中每个字符，根据字符类型进行对应操作。 运算数：压入numberStack栈中。 四则运算符：将该运算符与操作符栈顶运算符优先级进行比较，如果优先级高于栈顶运算符，表示该部分运算还不能进行，将其压入栈；如果优先级低于或等于（优先级相同从左到右运算）栈顶运算符，表示前面部分的运算可以进行，取出栈顶运算符进行计算，完成计算后将栈顶运算符弹出，然后继续与新的栈顶运算符进行比较，直到优先级大于栈顶运算符（栈空的情况已经包含，因为设置标记字符的优先级为最低）,再将该运算符压入操作符栈。 左括号：直接压入栈，入栈后优先级降到最低，保证其它运算符正常入栈。 右括号：依次取栈顶运算符进行运算，直到遇到左括号为止。最后将左括号从栈顶删除。 字符串s遍历完毕后，如果栈顶元素不为标记字符（即栈非空），依次取出栈顶运算符进行计算，计算结果压入numberStack中。 getTwoNumbers：获取两个操作数。 calculate：对两个操作数进行运算。先使用getTwoNumbers方法获取两个操作数，然后根据运算符的类型进行对应的运算，将结果压入numberStack栈中。 order：返回运算符优先级。加减为1，乘除为2，左括号为0，右括号为3，标记符号为0。 output：输出最终结果。按照2位小数输出操作数栈的栈顶元素。 charToDouble：将char类型的数字字符转换为double类型。返回数字字符与’0’的差。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;template &lt;class T&gt;class arrayStack{private: int stackTop; //栈顶 int arrayLength; //栈容量 T* stack; //元素数组public: //构造函数、析构函数 arrayStack(int initialCapacity=10); ~arrayStack() {delete []stack;} //ADT方法 bool empty() const {return stackTop==-1;} int size() const {return stackTop+1;} T&amp; top(); void pop(); void push(const T&amp; theElement);};template &lt;class T&gt;arrayStack&lt;T&gt;::arrayStack(int initialCapacity){ arrayLength=initialCapacity; stack=new T[arrayLength]; stackTop=-1;}template &lt;class T&gt;T&amp; arrayStack&lt;T&gt;::top(){ return stack[stackTop];}template &lt;class T&gt;void arrayStack&lt;T&gt;::pop(){ stack[stackTop--].~T();}template &lt;class T&gt;void arrayStack&lt;T&gt;::push(const T&amp; theElement){ if(stackTop==arrayLength-1) {//空间已满，容量加倍 T* newStack=new T[arrayLength*2]; arrayLength*=2; for(int i=0;i&lt;=stackTop;i++) newStack[i]=stack[i]; delete []stack; stack=newStack; } //在栈顶插入 stack[++stackTop]=theElement;}class calculator{private: arrayStack&lt;double&gt; numberStack; //操作数栈 arrayStack&lt;char&gt; operatorStack; //操作符栈 string s; //存储表达式public: void input(); //读入表达式 void operate(); //遍历表达式中的每个字符，进行相应处理 void getTwoNumbers(double &amp;num1,double &amp;num2); //获取两个操作数 void calculate(char op); //对两个操作数进行op运算 int order(char op); //运算符优先级 void output(); //输出最终结果 double charToDouble(char ch); //将char类型的数字字符转换为double类型};void calculator::input(){//读入表达式 cin&gt;&gt;s;}void calculator::getTwoNumbers(double &amp;num1,double &amp;num2){//获取两个操作数 num1=numberStack.top(); numberStack.pop(); num2=numberStack.top(); numberStack.pop();}void calculator::operate(){//遍历表达式中的每个字符，进行对应操作 operatorStack.push('#'); //设置栈空的标记字符，优先级设为最低 for(int i=0;i&lt;(int)s.size();i++) //遍历每个字符 { char ch=s.at(i); //当前字符 if(ch&gt;='0' &amp;&amp; ch&lt;='9') //数字 numberStack.push(charToDouble(ch)); //转换类型后入操作数栈 else //运算符 { if(ch=='(') //左括号 operatorStack.push(ch); //压入操作符栈 else if(ch==')') //右括号 { while(operatorStack.top()!='(') //进行计算直到遇到左括号 { calculate(operatorStack.top()); operatorStack.pop(); } operatorStack.pop(); //删除左括号 } else //四则运算符 { if(order(ch)&gt;order(operatorStack.top())) //当前运算符优先级高于栈顶运算符优先级 operatorStack.push(ch); else //当前运算符优先级低于或等于栈顶运算符优先级 { while(order(ch)&lt;=order(operatorStack.top())) {//进行计算 calculate(operatorStack.top()); operatorStack.pop(); } operatorStack.push(ch); //当前运算符压入操作符栈 } } } } //栈不为空 while(operatorStack.top()!='#') { char op=operatorStack.top(); operatorStack.pop(); calculate(op); }}void calculator::calculate(char op){//对两个操作数进行op运算 double number1,number2; getTwoNumbers(number1,number2); switch (op) { case '+':numberStack.push(number2+number1); break; case '-':numberStack.push(number2-number1); break; case '*':numberStack.push(number2*number1); break; case '/':numberStack.push(number2/number1); break; default: break; }}int calculator::order(char op){//运算符优先级 int val; if(op=='+'||op=='-') val=1; else if(op=='*'||op=='/') val=2; else if(op==')') val=3; else val=0; return val;}void calculator::output(){//输出最终结果 printf(&quot;%.2f\\n&quot;,numberStack.top());}double calculator::charToDouble(char ch){//将char类型的数字字符转换为double类型 double result=ch-'0'; return result;}int main(){ int n; //表达式个数 cin&gt;&gt;n; calculator c; for(int i=0;i&lt;n;i++) { c.input(); c.operate(); c.output(); } return 0;} 结果分析 1.在操作符栈中压入标记字符，并将其优先级设置为最低，在后续的判断中不用考虑栈空的情况，减少比较次数，提高程序性能。 2.逆波兰表达式求值是递归的一道经典问题，也可采用递归进行求解。","link":"/2020/11/04/DSA/DSA_6/"},{"title":"DSA：（八）散列表","text":"散列表（哈希表）有两种实现方法，一种是线性探查，一种是链表散列。散列常作为字典的表示方法，通过哈希函数把字典的数对映射到散列表的具体位置，散列表的每一个位置叫做一个桶。散列表的最坏性能与线性表相同，因此性能很好，但是缺点是溢出后无法对散列表进行扩容（只能重新建立一个新的散列表）。所以在实际应用过程中散列表一般会开的比较大，保证不会溢出，同时需要选择一个好的除数减少冲突。本文的两个问题在实现过程中通过关键字模拟散列表的操作，即散列表每个位置的元素是关键字而不是数对。 P1012:线性开型寻址 描述 给定散列函数的除数D和操作数m，输出每次操作后的状态。 有以下三种操作： 1.插入x，若散列表已存在x，输出“Existed”，否则插入x到散列表中，输出所在的下标。 2.查询x，若散列表不含有x，输出“-1”，否则输出x对应下标。 3.删除x，若散列表不含有x，输出“Not Found”，否则输出删除x过程中移动元素的个数。 要求 使用线性开型寻址实现 格式 输入 第一行两个整数D，m。分别代表散列函数的除数D和操作数m。 接下来m行，每行两个整数opt和x，分别代表操作类型和操作数。 若opt为0，代表插入x。 若opt为1，代表查询x。 若opt为2，代表删除x。 输出 按要求输出。 样例 样例1 输入 123456789101112137 121 210 10 130 50 230 260 331 331 331 131 51 1 输出 123456789101112-116520333651 样例2 输入 1234567891011121314151617181920212223242526272829303120 300 840 150 542 152 841 542 540 891 890 130 482 890 600 241 130 61 240 312 602 480 490 91 61 130 332 490 601 62 91 60 输出 123456789101112131415161718192021222324252627282930415140014099138004136411009106131410600 限制 1s, 64MB for each test case. 算法描述 使用数组存储结构，封装散列表类hashTable，protected成员包括存储散列表的数组table，除数divisor，散列表的大小dSize，查询关键字的search方法，public成员包括构造函数，析构函数，empty方法，size方法，寻找关键字的find方法，插入关键字的insert方法，删除关键字的erase方法。 search：搜索散列表，查询关键字theKey，如果存在关键字返回其位置，否则返回该关键字可以插入的位置。从起始桶开始，判断table[i]是否为空或者指向的元素是否为theKey。 find：调用search方法搜索散列表得到位置b，通过table[b]是否为空或者指向的元素是否为theKey判断是否匹配，若不匹配输出-1，返回NULL，若匹配输出关键字在散列表的位置b，返回table[b]。 insert：调用search方法搜索散列表得到位置b，如果table[b]为NULL，插入该关键字，输出插入位置b，否则存在匹配的关键字（因为题目保证散列表不会溢出），输出“Existed”。 erase：调用search方法搜索散列表得到位置b，起始桶homeBucket保存b的位置，如果table[b]=NULL，则不存在该关键字，输出“Not Found”然后返回。否则存在该关键字，首先释放内存，将散列表的长度-1，moveTimes记录元素移动次数，然后进入外层循环，将位置b置空，使用gap记录删除的关键字的位置。进入内层循环，b移向下一个位置，如果table[b]为空或者b=homeBucket(即已经遍历散列表)，则不需要再判断元素是否需要移动，输出移动次数然后返回。否则需要判断元素是否需要移动，通过pos记录散列表当前位置的关键字的起始桶位置，不需要移动的条件是pos在gap和b之间，考虑有环和没有环的情况，通过三个条件给出限制，否则需要进行移动，跳出内层循环，用b填充gap，移动次数+1，然后继续进行下去，直到满足返回的条件。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class hashTable{protected: int search(const T&amp; theKey) const; //搜索散列表，查询关键字theKey，如果有存在该关键字，返回其位置，否则返回该关键字可以插入的位置 T** table; //散列表 int divisor; //散列函数的除数 int dSize; //散列表的大小public: hashTable(int theDivisor=11); //构造函数 ~hashTable() {delete []table;} //析构函数 bool empty() const {return dSize==0;} int size() const {return dSize;} T* find(const T&amp; theKey) const; //返回关键字theKey的指针，若不存在该关键字，则返回NULL void insert(const T&amp; theKey); //在散列表中插入关键字theKey，若存在相同的关键字则覆盖 void erase(const T&amp; theKey); //在散列表中删除关键字theKey，若不存在输出错误信息};template &lt;class T&gt;hashTable&lt;T&gt;::hashTable(int theDivisor){ divisor=theDivisor; dSize=0; //分配和初始化散列表数组 table=new T*[divisor]; for(int i=0;i&lt;divisor;i++) //将所有桶置空 table[i]=NULL;}template &lt;class T&gt;int hashTable&lt;T&gt;::search(const T&amp; theKey) const{//搜索散列表，查询关键字theKey //如果有存在该关键字，返回其位置，否则返回该关键字可以插入的位置 int i=theKey % divisor; //起始桶 int j=i; //从起始桶开始 do{ if(table[j]==NULL || *table[j]==theKey) return j; j=(j+1)%divisor; //下一个桶 }while(j!=i); return j;//表已经满}template &lt;class T&gt;T* hashTable&lt;T&gt;::find(const T&amp; theKey) const{//返回关键字theKey的指针，若不存在该关键字，则返回NULL //搜索散列表 int b=search(theKey); //判断table[b]是否匹配 if(table[b]==NULL || *table[b]!=theKey) //不匹配 { cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return NULL; } //匹配 cout&lt;&lt;b&lt;&lt;endl; return table[b];}template &lt;class T&gt;void hashTable&lt;T&gt;::insert(const T&amp; theKey){//在散列表中插入关键字theKey，若存在相同的关键字则覆盖 int b=search(theKey); //检查匹配的关键字是否存在 //没有匹配的关键字，且表不满，则插入该关键字 if(table[b]==NULL) { table[b]=new T(theKey); dSize++; cout&lt;&lt;b&lt;&lt;endl; } else //存在匹配的关键字 cout&lt;&lt;&quot;Existed&quot;&lt;&lt;endl;}template &lt;class T&gt;void hashTable&lt;T&gt;::erase(const T&amp; theKey){//在散列表中删除关键字theKey //若不存在输出错误信息 int b=search(theKey); int homeBucket=b; if(table[b]==NULL) //不存在该关键字 { cout&lt;&lt;&quot;Not Found&quot;&lt;&lt;endl; return ; } //存在该关键字 delete table[b]; //释放内存 dSize--; //散列表长度-1 int moveTimes=0; //元素移动次数 for(;;) { table[b]=NULL; //将散列表的位置b置空 int gap=b; //记录删除的关键字的位置 for(;;) { b=(b+1)%divisor; //b的下一个位置 if(table[b]==NULL||b==homeBucket) //不需要再进行移动，直接返回 { cout&lt;&lt;moveTimes&lt;&lt;endl; return ; } int pos=*table[b]%divisor; //当前关键字在散列表中的原始映射位置 //不受散列表中删除关键字的影响 //三个条件都限制了pos要在gap和b之间 if(gap&lt;pos &amp;&amp; pos&lt;=b) continue; if(gap&gt;b &amp;&amp; gap&lt;pos) continue; if(gap&gt;b &amp;&amp; pos&lt;=b) continue; //受到影响，跳出循环 break; } table[gap]=table[b]; //用b填充gap moveTimes++; }}int main(){ int D,m,instruction,x; cin&gt;&gt;D&gt;&gt;m; hashTable&lt;int&gt; H(D); for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch(instruction) { case 0: cin&gt;&gt;x; H.insert(x); break; case 1: cin&gt;&gt;x; H.find(x); break; case 2: cin&gt;&gt;x; H.erase(x); break; } } return 0;} P1013:链表散列 描述 给定散列函数的除数D和操作数m，输出每次操作后的状态。 有以下三种操作： 1.插入x，若散列表已存在x，输出&quot;Existed&quot;。 2.查询x，若散列表不含有x，输出&quot;Not Found&quot;，否则输出x所在的链表长度。 3.删除x，若散列表不含有x，输出&quot;Delete Failed&quot;，否则输出x所在链表删除x后的长度。 要求 使用链表散列方式 格式 输入 第一行两个整数D(1&lt;=D&lt;=3000)和m(1&lt;=m&lt;=3000)，其中D为散列函数的除数，m为操作数。 接下来的m行，每行两个整数opt和x，分别代表操作类型和操作数。 若opt为0，则代表向散列表中插入x； 若opt为1，代表查询散列表中x是否存在； 若opt为2，(如果散列表中含有x)，删除x。 数据保证散列表不会溢出。 输出 按要求输出。 样例 样例1 输入 123456789101112137 121 210 10 130 50 230 260 331 331 331 131 51 1 输出 123456Not Found33131 样例2 输入 123456789101112131415167 152 100 100 102 101 100 101 100 170 20 160 112 22 101 111 17 输出 123456789Delete FailedExisted0Not Found11111 限制 1s, 64MB for each test case. 数据范围 对于前60%的数据，只包含插入和查询操作。 对于后40%的数据，包含插入、查询与删除操作。 算法描述 使用链式存储结构，封装散列表类hashChains，protected成员包括有序链表数组table，散列函数的除数divisor，散列表的大小dSize，public成员包括构造函数，析构函数，empty方法，size方法，查询关键字的find方法，插入关键字的insert方法，删除关键字的erase方法。操作主要通过sortedChain类的方法来实现。 find：首先通过关键字确定起始桶的位置homeBucket，然后在起始桶中调用sortedChain类的find方法，根据返回值是否为空判断是否存在匹配的关键字，若不存在，输出“Not Found”，若存在，通过调用table[homeBucket]的size方法输出关键字所在链表的长度。 insert：首先通过关键字确定起始桶的位置homeBucket，homeSize表示homeBucket桶在插入前的链表长度，调用table[homeBucket]的insert方法，进行插入操作，若已经存在相同的关键字，输出“Existed”，否则进行关键字的插入，根据homeSize和插入后table[homeBucket]长度的比较，判断是否进行了插入（排除相同关键字的情况），对散列表的大小进行相应增加。 erase：首先通过关键字确定起始桶的位置homeBucket，然后调用table[homeBucket]的erase方法，若不存在关键字，输出“Delete Failed”，若存在进行相应删除操作，输出删除该关键字后的链表长度。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct node{ T element; node&lt;T&gt;* next; node() {} node(const T&amp; element) { this-&gt;element=element; } node(const T&amp; element,node&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};template &lt;class T&gt;class sortedChain{protected: node&lt;T&gt;* firstNode; //指向有序链表第一个节点的指针 int dSize; //有序链表的长度public: sortedChain(int initialCapacity=10); ~sortedChain(); bool empty() const {return dSize==0;} int size() const {return dSize;} T* find(const T&amp; theKey) const; //查询关键字theKey void insert(const T&amp; theKey); //插入关键字theKey，若已经存在关键字，输出Existed void erase(const T&amp; theKey); //删除关键字theKey，若不存在该关键字输出Delete Failed};template &lt;class T&gt;sortedChain&lt;T&gt;::sortedChain(int initialCapacity){ firstNode=NULL; dSize=0;}template &lt;class T&gt;sortedChain&lt;T&gt;::~sortedChain&lt;T&gt;(){ while (firstNode!=NULL) { node&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;T* sortedChain&lt;T&gt;::find(const T &amp;theKey) const {//查询关键字theKey，若不存在返回NULL，若存在返回节点数据域的地址 node&lt;T&gt;* currentNode=firstNode; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element&lt;theKey) currentNode=currentNode-&gt;next; if(currentNode!=NULL &amp;&amp; currentNode-&gt;element==theKey) return &amp;currentNode-&gt;element; return NULL;}template &lt;class T&gt;void sortedChain&lt;T&gt;::insert(const T &amp;theKey){//插入关键字theKey，若已经存在关键字，输出Existed node&lt;T&gt;* p=firstNode; node&lt;T&gt;* tp=NULL; while(p!=NULL &amp;&amp; p-&gt;element&lt;theKey) { tp=p; p=p-&gt;next; } if(p!=NULL &amp;&amp; p-&gt;element==theKey) { cout&lt;&lt;&quot;Existed&quot;&lt;&lt;endl; return ; } node&lt;T&gt;* newNode=new node&lt;T&gt;(theKey,p); if(tp==NULL) //插在首节点 firstNode=newNode; else tp-&gt;next=newNode; dSize++;}template &lt;class T&gt;void sortedChain&lt;T&gt;::erase(const T &amp;theKey){//删除关键字theKey，若不存在该关键字输出Delete Failed node&lt;T&gt;* p=firstNode; node&lt;T&gt;* tp=NULL; while(p!=NULL &amp;&amp; p-&gt;element&lt;theKey) { tp=p; p=p-&gt;next; } if((p!=NULL &amp;&amp; p-&gt;element&gt;theKey) || p==NULL) { cout&lt;&lt;&quot;Delete Failed&quot;&lt;&lt;endl; return ; } if(p!=NULL &amp;&amp; p-&gt;element==theKey) { if(tp==NULL) firstNode=p-&gt;next; else tp-&gt;next=p-&gt;next; delete p; dSize--; cout&lt;&lt;dSize&lt;&lt;endl; }}template &lt;class T&gt;class hashChains{protected: sortedChain&lt;T&gt;* table; //链表数组 int divisor; //散列函数的除数 int dSize; //散列表的大小public: hashChains(int theDivisor=11); ~hashChains() {delete []table;} bool empty() const {return dSize==0;} int size() const {return dSize;} void find(const T&amp; theKey) const; //查询关键字theKey，若不存在该关键字，输出Not Found，若存在输出所在链表的长度 void insert(const T&amp; theKey); //在散列表中插入关键字theKey，若存在相同的关键字则覆盖 void erase(const T&amp; theKey); //在散列表中删除关键字theKey，若不存在输出错误信息};template &lt;class T&gt;hashChains&lt;T&gt;::hashChains(int theDivisor){ divisor=theDivisor; dSize=0; table=new sortedChain&lt;T&gt;[divisor];}template &lt;class T&gt;void hashChains&lt;T&gt;::find(const T&amp; theKey) const{//返回关键字theKey匹配的数对的指针 int homeBucket=theKey % divisor; T* temp=table[homeBucket].find(theKey); if(temp==NULL) cout&lt;&lt;&quot;Not Found&quot;&lt;&lt;endl; else cout&lt;&lt;table[homeBucket].size()&lt;&lt;endl;}template &lt;class T&gt;void hashChains&lt;T&gt;::insert(const T&amp; theKey){//在字典中插入一个数对thePair，若存在关键字相同的数对，则覆盖 int homeBucket=theKey % divisor; int homeSize=table[homeBucket].size(); table[homeBucket].insert(theKey); if(table[homeBucket].size()&gt;homeSize) dSize++;}template &lt;class T&gt;void hashChains&lt;T&gt;::erase(const T&amp; theKey){//删除关键字为theKey的数对 int homeBucket=theKey % divisor; table[homeBucket].erase(theKey);}int main(){ int D,m,instruction,x; cin&gt;&gt;D&gt;&gt;m; hashChains&lt;int&gt; H(D); for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch(instruction) { case 0: cin&gt;&gt;x; H.insert(x); break; case 1: cin&gt;&gt;x; H.find(x); break; case 2: cin&gt;&gt;x; H.erase(x); break; } } return 0;} 结果分析 1.线性探查的删除操作的核心是在删除一个元素后，判断散列剩余的元素要不要进行移动，如果需要移动，移动到哪个位置。在实现中，gap表示需要进行填充的位置，如果不进行填充，会破坏散列表的组织，影响后序的搜索等操作，不需要进行移动的元素应该满足其起始桶位置在gap和b之间，这样在线性探查的过程中，不会遇到gap，不影响该元素的搜索，所以这样的元素不需要进行移动。 2.线性探查的删除操作也可以为每个桶增加一个neverUsed域，用来标识这个桶是否曾经存有元素然后该元素被删除，保证在探查过程中不会受到删除的影响。 3.散列在最坏情况下的复杂度与线性表在最坏情况下的复杂度相同，使用链表时的平均性能优于线性探查。 4.数对的表示可以通过pair&lt;const K,E&gt;，pair.first为关键字，pair.second为元素值。","link":"/2020/11/22/DSA/DSA_8/"},{"title":"DSA：（九）二叉树操作","text":"树型结构适合表示层次关系。本文通过链表实现二叉树的操作，包括前序遍历、中序遍历、后序遍历、层次遍历、计算节点数目和高度，以及通过前序序列和中序序列构造出二叉树。 P1014:二叉树基础 描述 创建二叉树类。二叉树的存储结构使用链表。提供操作:前序遍历、中序遍历、后序遍历、层次遍历、计算二叉树结点数目、计算二叉树高度。 格式 输入 第一行为一个数字n(10&lt;=n&lt;=100000)，表示这棵树有n个节点，编号为1 ~ n。 之后n行每行两个数字，第i行的两个数字a、b表示编号为i的节点的左孩子节点为a，右孩子节点为b，-1表示该位置没有节点。 保证数据有效，根节点为1。 输出 第一行，n个数字，表示该树的层次遍历。 第二行，n个数字，第i个数字表示以i节点为根的子树的节点数目。 第三行，n个数字，第i个数字表示以i节点为根的子树的高度。 样例 样例1 输入 12345652 34 5-1 -1-1 -1-1 -1 输出 1231 2 3 4 55 3 1 1 13 2 1 1 1 样例2 输入 12345653 2-1 -14 5-1 -1-1 -1 输出 1231 3 2 4 55 1 3 1 13 1 2 1 1 样例3 输入 1234567891011102 -14 36 -15 89 7-1 -1-1 -1-1 -110 -1-1 -1 输出 1231 2 4 3 5 8 6 9 7 10 10 9 2 6 4 1 1 1 2 1 6 5 2 4 3 1 1 1 2 1 Hint 请仔细读题，注意建树过程。 算法描述 封装二叉树类linkedBinaryTree，二叉树的存储结构使用链表，每个节点包括元素值element，左孩子leftChild，右孩子rightChild。节点类的构造函数有三个，默认构造函数，通过theElement构造，通过theElement，theLeftChild，theRightChild构造。二叉树类中，非静态的私有成员包括根节点root，树的节点个数treeSize，求以t为根节点的子树的高度height方法，求以t为根节点的子树的节点个数nodeNumber方法，静态的私有成员包括访问函数visit，前序遍历preOrder，中序遍历inOrder，后序遍历postOrder，删除t指向的节点dispose方法。公有成员包括构造函数，析构函数，empty方法，size方法，前序遍历，中序遍历，后序遍历，层次遍历，删除二叉树的erase方法，求二叉树的节点个数和高度，初始化二叉树initialize方法，输出以二叉树所有节点为根节点的子树的高度和节点个数。 前序遍历按照根、左、右的顺序访问二叉树的节点，中序遍历按照左、根、右的顺序访问二叉树的节点，后序遍历按照左、右、跟的顺序访问二叉树的节点。三种遍历方法都用递归实现。层次遍历利用队列的“先进先出”实现。 erase：删除整颗二叉树。通过后序遍历，对访问到的每一个节点调用dispose方法执行删除操作，最后将root置空，treeSize置零。 已知根节点求树的节点个数和高度，都用递归实现。求节点个数时，先求出左右子树的节点个数，相加再加一得到树的节点个数。求高度时，先求出左右子树的高度，二者的较大值加一得到树的高度。 初始化二叉树，首先将每个节点的左孩子和右孩子分别存入两个数组，然后利用层次遍历，对遍历到的当前的元素，根据左孩子和右孩子，构造相应的节点。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}template &lt;class T&gt;struct binaryTreeNode //二叉树节点类{ T element; binaryTreeNode&lt;T&gt; *leftChild, *rightChild; //三个构造函数 binaryTreeNode() {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement):element(theElement) {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement,binaryTreeNode&lt;T&gt;* theLeftChild,binaryTreeNode&lt;T&gt;* theRightChild):element(theElement) { leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class linkedBinaryTree{private: binaryTreeNode&lt;T&gt; *root; //根节点指针 int treeSize; //树的节点个数 static void (*visit)(binaryTreeNode&lt;T&gt; *); //访问函数 static void preOrder(binaryTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(binaryTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(binaryTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(binaryTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 int height(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的高度 int nodeNumber(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的节点个数public: linkedBinaryTree() {root=NULL; treeSize=0;} ~linkedBinaryTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void levelOrder(void(*)(binaryTreeNode&lt;T&gt;*)); //层次遍历 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } int Height() const {return height(root);} //计算二叉树的高度 int NodeNumber() const {return nodeNumber(root);} //计算二叉树的节点个数 void initialize(int num); //二叉树的初始化 void subtreeNodeNumber() const; //输出二叉树中所有节点为根的子树的节点个数 void subtreeHeight() const; //输出二叉树中所有节点为根的子树的高度};template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt;*)=NULL; //类的静态成员的初始化template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::preOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { linkedBinaryTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::inOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); linkedBinaryTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::postOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); linkedBinaryTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::height(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int hl=height(t-&gt;leftChild); int hr=height(t-&gt;rightChild); if(hl&gt;hr) return ++hl; else return ++hr;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::nodeNumber(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int nl=nodeNumber(t-&gt;leftChild); int nr=nodeNumber(t-&gt;rightChild); return nl+nr+1;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::levelOrder(void (*theVisit)(binaryTreeNode&lt;T&gt; *)){ binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; while (t!=NULL) { theVisit(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else return ; q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::initialize(int num){//二叉树的初始化 //这棵树有num个节点，编号为1~num，根节点为1 //读入编号为i的节点的左孩子a，右孩子b，-1表示该位置没有节点 root=new binaryTreeNode&lt;T&gt;(1); treeSize=num; int *left=new int[num+1]; //左孩子 int *right=new int[num+1]; //右孩子 binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; for(int i=1;i&lt;=num;i++) cin&gt;&gt;left[i]&gt;&gt;right[i]; int cur=t-&gt;element; //当前节点的element值 //利用层次遍历进行初始化 while (t!=NULL) { if(left[cur]!=-1) t-&gt;leftChild=new binaryTreeNode&lt;T&gt;(left[cur]); if(right[cur]!=-1) t-&gt;rightChild=new binaryTreeNode&lt;T&gt;(right[cur]); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //初始化完成 { delete []left; delete []right; return ; } q.pop(); cur=t-&gt;element; }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeNodeNumber() const{//输出二叉树中所有节点为根的子树的节点个数 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的节点个数 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=nodeNumber(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeHeight() const{//输出二叉树中所有节点为根的子树的高度 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的高度 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=height(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void output(binaryTreeNode&lt;T&gt;* t){//输出节点的element值 cout&lt;&lt;t-&gt;element&lt;&lt;&quot; &quot;;}int main(){ int n; linkedBinaryTree&lt;int&gt; BT; cin&gt;&gt;n; BT.initialize(n); BT.levelOrder(output); cout&lt;&lt;endl; BT.subtreeNodeNumber(); cout&lt;&lt;endl; BT.subtreeHeight(); cout&lt;&lt;endl; return 0;} P1015:二叉树遍历 描述 接收二叉树前序序列和中序序列(各元素各不相同)，输出该二叉树的后序序列。 格式 输入 输入有三行： 第一行为数字n。 第二行有n个数字，表示二叉树的前序遍历。 第三行有n个数字，表示二叉树的中序遍历。 输出 输出一行，表示该二叉树的后序遍历序列。 样例 输入 12351 2 4 5 34 2 5 1 3 输出 14 5 2 3 1 算法描述 在二叉树类linkedBinaryTree的基础上增加方法buildTree和update。buildTree的参数为前序序列pre，中序序列in，序列长度len，返回构造出的二叉树的根节点。buildTree通过递归实现，根据前序序列中的pre[0]，在中序序列中查找pre[0]的位置，根据pre[0]将中序序列分为左、根、右三部分，对于每一个部分，按照相同的方法进行构造，根据递归调用即可。update根据buildTree的返回值和序列长度，更新私有成员root和treeSize。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}template &lt;class T&gt;struct binaryTreeNode //二叉树节点类{ T element; binaryTreeNode&lt;T&gt; *leftChild, *rightChild; //三个构造函数 binaryTreeNode() {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement):element(theElement) {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement,binaryTreeNode&lt;T&gt;* theLeftChild,binaryTreeNode&lt;T&gt;* theRightChild):element(theElement) { leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class linkedBinaryTree{private: binaryTreeNode&lt;T&gt; *root; //根节点指针 int treeSize; //树的节点个数 static void (*visit)(binaryTreeNode&lt;T&gt; *); //访问函数 static void preOrder(binaryTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(binaryTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(binaryTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(binaryTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 static void output(binaryTreeNode&lt;T&gt; *t) {cout&lt;&lt;t-&gt;element&lt;&lt;&quot; &quot;;} //输出节点t的element值 int height(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的高度 int nodeNumber(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的节点个数public: linkedBinaryTree() {root=NULL; treeSize=0;} ~linkedBinaryTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void postOrderOutput() //后序输出序列 {postOrder(output);cout&lt;&lt;endl;} void levelOrder(void(*)(binaryTreeNode&lt;T&gt;*)); //层次遍历 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } int Height() const {return height(root);} //计算二叉树的高度 int NodeNumber() const {return nodeNumber(root);} //计算二叉树的节点个数 void initialize(int num); //二叉树的初始化 void subtreeNodeNumber() const; //输出二叉树中所有节点为根的子树的节点个数 void subtreeHeight() const; //输出二叉树中所有节点为根的子树的高度 binaryTreeNode&lt;T&gt;* buildTree(T* pre,T* in,int len); //通过前序序列pre和中序序列in构造一颗二叉树,len表示序列长度 void update(T* pre,T* in,int len); //将构造的二叉树放到对象中，即更新root和treeSize};template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt; *)=NULL; //类的静态成员的初始化template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::preOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { linkedBinaryTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::inOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); linkedBinaryTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::postOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); linkedBinaryTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::height(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int hl=height(t-&gt;leftChild); int hr=height(t-&gt;rightChild); if(hl&gt;hr) return ++hl; else return ++hr;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::nodeNumber(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int nl=nodeNumber(t-&gt;leftChild); int nr=nodeNumber(t-&gt;rightChild); return nl+nr+1;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::levelOrder(void (*theVisit)(binaryTreeNode&lt;T&gt; *)){ binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; while (t!=NULL) { theVisit(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else return ; q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::initialize(int num){//二叉树的初始化 //这棵树有num个节点，编号为1~num，根节点为1 //读入编号为i的节点的左孩子a，右孩子b，-1表示该位置没有节点 root=new binaryTreeNode&lt;T&gt;(1); treeSize=num; int *left=new int[num+1]; //左孩子 int *right=new int[num+1]; //右孩子 binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; for(int i=1;i&lt;=num;i++) cin&gt;&gt;left[i]&gt;&gt;right[i]; int cur=t-&gt;element; //当前节点的element值 //利用层次遍历进行初始化 while (t!=NULL) { if(left[cur]!=-1) t-&gt;leftChild=new binaryTreeNode&lt;T&gt;(left[cur]); if(right[cur]!=-1) t-&gt;rightChild=new binaryTreeNode&lt;T&gt;(right[cur]); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //初始化完成 { delete []left; delete []right; return ; } q.pop(); cur=t-&gt;element; }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeNodeNumber() const{//输出二叉树中所有节点为根的子树的节点个数 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的节点个数 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=nodeNumber(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeHeight() const{//输出二叉树中所有节点为根的子树的高度 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的高度 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=height(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;binaryTreeNode&lt;T&gt;* linkedBinaryTree&lt;T&gt;::buildTree(T *pre, T *in, int len){//根据前序序列pre和中序序列in构建二叉树 //len表示序列长度 //返回二叉树的根节点 //序列长度小于等于0，不需要继续构造 if(len&lt;=0) return NULL; binaryTreeNode&lt;T&gt;* subRoot=new binaryTreeNode&lt;T&gt;(pre[0]); //pre[0]为根节点 int index=0; //在中序序列中查找pre[0] for(int i=0;i&lt;len;i++) if(in[i]==pre[0]) { index=i; break; } //递归构造左子树和右子树 subRoot-&gt;leftChild=buildTree(pre+1,in,index); subRoot-&gt;rightChild=buildTree(pre+index+1,in+index+1,len-index-1); return subRoot;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::update(T* pre,T* in,int len){//将构造的二叉树放到对象中，即更新root和treeSize root=buildTree(pre, in, len); treeSize=len;}int main(){ linkedBinaryTree&lt;int&gt; BT; int n; cin&gt;&gt;n; int *pre=new int[n],*in=new int[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i]; BT.update(pre,in,n); BT.postOrderOutput(); delete []pre; delete []in; return 0;} 结果分析 1.初始化时需要注意第i行的两个数字a、b表示的是编号为i的节点的左孩子和右孩子，不是位置为i的节点，因此在利用层次遍历进行初始化时，首先将每个节点的左孩子和右孩子分别存入两个数组，然后根据当前节点的element值在数组中找到左孩子和右孩子。 2.类的静态数据成员需要在类内定义，在类外进行初始化，如果没有初始化，也就意味着没有对其分配内存，在连接时会因为找不到对应的内存单元导致连接报错。 函数指针的初始化的语法格式： 12template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt; *)=NULL;","link":"/2020/12/23/DSA/DSA_9/"},{"title":"DSA：（五）数组和矩阵","text":"本文通过单个线性表（三元组）按照行主次序将稀疏矩阵映射到一维数组中，提供重置、转置、加法、乘法、输入、输出操作。稀疏矩阵类sparseMatrix在arrayList类的基础上实现，对arrayList类的方法进行了一些扩充。在代码实现过程中需要注意OJ对时间复杂度的要求，对代码进行优化。 P1008:稀疏矩阵 题目描述 创建稀疏矩阵类（参照课本MatrixTerm三元组定义），采用行主顺序把稀疏矩阵非0元素映射到一维数组中，提供操作:两个稀疏矩阵相加、两个稀疏矩阵相乘、稀疏矩阵的转置、输出矩阵。 键盘输入矩阵的行数、列数，并按行优先顺序输入矩阵的各元素值，建立矩阵。 对建立的矩阵执行相加、相乘、转置的操作，输出操作的结果矩阵。 要求 1.数据类型请使用int，本题中所有运算的结果均视作对int型自然溢出。 2.可以使用vector等STL中的容器保存稀疏矩阵元素，减少不必要的bug。 3.各操作需在稀疏矩阵上进行，充分考虑数据的稀疏性，不得直接或间接转换为二维数组形式计算，否则取消成绩。 操作描述 格式 输入 第一行一个w代表操作个数，接下来若干行是各个操作，其中保证第一个操作一定为重置矩阵。 输出 当执行操作4时，输出矩阵P;当执行操作2或3时，若对应运算不合法，则输出-1。 样例 样例1 输入 12345678910111213141516171819202122232425715 52 1 0 0 00 0 -1 0 00 0 0 0 00 0 -1 0 00 0 0 0 035 542 2 53 5 84 4 25 3 4425 531 1 82 4 43 5 2454 输出 1234567891011121314151617185 52 1 0 0 0 0 5 -1 0 0 0 0 0 0 8 0 0 -1 2 0 0 0 4 0 0 5 516 0 0 4 0 0 0 0 20 -2 0 0 0 0 0 0 0 0 0 -2 0 0 0 0 8 5 516 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 20 0 0 0 0 -2 0 -2 8 样例2 输入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828940110 20-1 0 1 0 0 0 0 0 -1 0 0 0 -1 0 -1 0 0 -1 1 -10 0 2 -1 0 0 0 0 0 -1 0 0 0 0 0 0 0 1 -2 01 0 0 0 0 0 0 0 0 0 -1 -2 -1 0 -1 0 0 0 0 00 0 0 1 0 -1 -1 -1 0 0 1 0 0 0 0 0 0 0 -1 00 0 0 1 0 0 0 0 0 1 -1 1 0 0 0 0 -1 0 0 01 0 -1 1 2 0 0 0 1 0 0 0 0 -1 0 1 -1 1 -1 0-1 0 0 0 -1 0 0 0 0 0 -1 0 0 -1 2 0 0 -1 0 0-1 -1 -1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 00 0 0 0 0 0 -3 0 0 0 0 -1 -2 1 0 2 0 -1 -1 0-1 1 0 1 -1 0 0 0 -1 0 -1 0 0 0 0 1 0 0 -1 1210 2072 16 93 7 33 17 46 3 47 12 108 13 610 8 3210 2081 20 14 20 56 5 46 10 107 4 87 6 108 12 99 17 5210 2091 8 43 8 63 17 75 1 105 8 46 9 47 12 79 10 99 17 7310 2073 3 105 18 48 5 28 19 58 20 109 12 310 11 104210 2023 16 44 10 6210 2071 16 82 9 83 8 94 2 44 20 78 10 710 3 4210 2011 19 5210 20101 9 82 15 53 2 104 2 54 3 94 7 106 6 66 14 67 2 79 16 9210 2073 14 54 9 86 19 57 17 78 13 49 6 109 20 15220 1076 9 27 8 107 9 911 1 1012 5 618 4 820 6 4220 10213 2 517 5 10119 192 0 0 0 0 0 1 0 0 1 0 0 0 1 0 1 1 0 10 0 1 0 1 -3 0 0 -1 1 -2 0 -2 0 0 1 0 0 0-1 -1 0 0 1 0 0 1 0 -1 0 0 1 1 0 0 0 1 00 0 -1 0 0 -2 -1 0 0 0 1 0 0 1 2 -1 2 0 00 1 0 -1 0 0 -1 0 0 -1 0 0 0 -1 0 -1 0 -1 00 0 0 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 -11 0 -1 1 0 0 -1 0 1 1 0 0 0 0 1 0 1 0 -10 0 0 1 0 0 0 -1 0 0 0 0 0 0 0 0 -1 0 -10 -1 1 0 0 0 0 0 0 0 -1 0 0 0 -1 1 0 0 00 0 -1 0 0 0 0 1 0 -1 2 0 2 -1 -1 0 -1 0 01 0 0 -1 0 0 0 0 0 0 0 0 0 0 -1 1 0 0 00 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 -1-1 0 0 0 2 -1 2 -2 0 0 0 -1 1 0 0 0 0 0 00 0 1 0 0 -1 0 0 0 0 0 0 0 0 0 -1 0 0 -20 0 -1 0 0 1 0 0 1 -1 0 0 0 1 0 0 0 0 10 0 0 0 1 -1 -1 1 1 0 0 0 0 -1 0 0 0 0 00 -1 0 0 0 0 2 0 0 0 0 2 2 0 0 0 0 0 -10 0 0 -1 0 -1 0 0 0 0 0 -1 0 0 0 0 0 0 00 -1 -1 0 0 1 0 -1 1 0 -1 0 0 0 0 0 0 0 14219 1965 5 25 17 512 3 313 15 514 3 515 9 7219 1987 9 110 1 612 2 414 3 914 8 216 7 318 1 118 14 4219 1991 5 31 18 104 15 46 7 911 19 612 2 114 7 614 14 217 9 8219 1974 18 75 9 17 2 611 9 312 16 315 9 216 5 5219 1933 12 417 7 518 16 45219 19117 17 2319 19611 8 511 14 512 19 617 5 417 15 619 19 4219 1971 1 44 12 56 1 97 8 39 18 813 12 216 14 2219 1928 11 712 4 8319 1971 16 53 9 65 15 314 14 1015 9 615 14 315 19 7219 1961 19 25 8 66 16 69 6 610 18 915 7 555219 1966 7 110 7 613 5 515 16 617 9 1019 15 3219 1963 5 44 9 55 15 111 3 517 5 617 7 7219 19114 6 75219 1933 10 84 18 115 15 8219 1945 8 106 9 106 16 614 15 454219 1992 17 34 18 912 3 813 11 1013 19 714 12 415 4 917 8 919 4 5219 1917 17 6 输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061-1-1-110 200 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 6 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 5 10 0 0 0 0 0 0 0 0 0 9 0 3 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0 -1-1-1-1-1-1-119 192 0 0 0 0 0 1 0 0 1 0 0 0 1 0 1 1 0 1 0 0 1 0 1 -3 0 0 -1 1 -2 0 -2 0 0 1 0 0 0 -1 -1 0 0 1 0 0 1 0 -1 0 0 1 1 0 0 0 1 0 0 0 -1 0 0 -2 -1 0 0 0 1 0 0 1 2 -1 2 0 0 0 1 0 -1 0 0 -1 0 0 -1 0 0 0 -1 0 -1 0 -1 0 0 0 0 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 -1 1 0 -1 1 0 0 -1 0 1 1 0 0 0 0 1 0 1 0 -1 0 0 0 1 0 0 0 -1 0 0 0 0 0 0 0 0 -1 0 -1 0 -1 1 0 0 0 0 0 0 0 -1 0 0 0 -1 1 0 0 0 0 0 -1 0 0 0 0 1 0 -1 2 0 2 -1 -1 0 -1 0 0 1 0 0 -1 0 0 0 0 0 0 0 0 0 0 -1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 -1 -1 0 0 0 2 -1 2 -2 0 0 0 -1 1 0 0 0 0 0 0 0 0 1 0 0 -1 0 0 0 0 0 0 0 0 0 -1 0 0 -2 0 0 -1 0 0 1 0 0 1 -1 0 0 0 1 0 0 0 0 1 0 0 0 0 1 -1 -1 1 1 0 0 0 0 -1 0 0 0 0 0 0 -1 0 0 0 0 2 0 0 0 0 2 2 0 0 0 0 0 -1 0 0 0 -1 0 -1 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 -1 -1 0 0 1 0 -1 1 0 -1 0 0 0 0 0 0 0 1 19 190 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 样例3 输入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085092015 11-22324 -8307 9206 122 -7218 21649 -16209 11639 3813 12960 15895-6355 8061 -4443 9028 -2663 20150 6485 8100 -12939 -1189 -895417884 -3031 -10317 6894 9240 -1078 9344 -16194 -1543 -16063 -15494-19732 3868 -25565 1922 4300 8148 -13256 4611 2077 26163 1073810610 -2944 6357 4205 -12046 2795 13566 18396 11768 -5985 -345525 5251 1 11 2 21 3 21 4 21 5 32 1 12 2 12 3 32 4 22 5 23 1 13 2 13 3 33 4 23 5 14 1 24 2 14 3 34 4 24 5 25 1 25 2 25 3 35 4 25 5 2425 5251 1 21 2 11 3 21 4 11 5 22 1 32 2 22 3 12 4 32 5 13 1 13 2 13 3 13 4 23 5 34 1 24 2 14 3 24 4 34 5 35 1 25 2 25 3 25 4 15 5 325 5251 1 31 2 11 3 11 4 21 5 12 1 12 2 12 3 22 4 22 5 33 1 33 2 13 3 33 4 13 5 14 1 24 2 34 3 24 4 34 5 15 1 15 2 15 3 25 4 15 5 125 5251 1 21 2 21 3 11 4 31 5 22 1 12 2 32 3 32 4 12 5 13 1 23 2 23 3 23 4 13 5 34 1 34 2 14 3 14 4 24 5 25 1 25 2 25 3 15 4 15 5 325 5251 1 21 2 11 3 11 4 21 5 22 1 22 2 32 3 12 4 22 5 23 1 33 2 13 3 33 4 33 5 24 1 34 2 24 3 34 4 24 5 15 1 15 2 25 3 35 4 25 5 2425 5251 1 21 2 31 3 21 4 21 5 32 1 12 2 32 3 22 4 12 5 23 1 13 2 13 3 23 4 33 5 14 1 14 2 24 3 14 4 14 5 15 1 35 2 25 3 25 4 15 5 225 5251 1 31 2 21 3 21 4 31 5 22 1 32 2 22 3 22 4 22 5 33 1 33 2 33 3 13 4 33 5 14 1 24 2 34 3 14 4 34 5 15 1 35 2 35 3 35 4 35 5 235 5251 1 21 2 21 3 11 4 31 5 22 1 12 2 12 3 32 4 32 5 13 1 23 2 13 3 33 4 23 5 14 1 24 2 34 3 24 4 14 5 25 1 15 2 15 3 35 4 15 5 244212 131561 1 31 2 21 3 21 4 31 5 31 6 31 7 11 8 21 9 31 10 21 11 11 12 31 13 32 1 12 2 12 3 22 4 32 5 22 6 22 7 32 8 12 9 12 10 22 11 12 12 12 13 23 1 23 2 23 3 23 4 23 5 13 6 33 7 33 8 23 9 23 10 33 11 23 12 33 13 24 1 34 2 24 3 24 4 24 5 34 6 24 7 24 8 34 9 24 10 24 11 24 12 24 13 35 1 25 2 15 3 35 4 35 5 35 6 25 7 35 8 25 9 15 10 35 11 25 12 35 13 36 1 16 2 36 3 36 4 26 5 16 6 36 7 26 8 36 9 26 10 16 11 36 12 26 13 37 1 27 2 27 3 37 4 17 5 17 6 17 7 27 8 17 9 37 10 17 11 17 12 37 13 38 1 18 2 28 3 18 4 38 5 38 6 28 7 38 8 18 9 28 10 18 11 28 12 38 13 19 1 39 2 39 3 29 4 19 5 39 6 39 7 39 8 19 9 19 10 39 11 29 12 29 13 210 1 310 2 310 3 110 4 110 5 110 6 310 7 210 8 110 9 110 10 310 11 310 12 310 13 211 1 111 2 211 3 211 4 311 5 211 6 111 7 111 8 211 9 311 10 211 11 311 12 211 13 312 1 212 2 312 3 112 4 212 5 212 6 212 7 312 8 312 9 212 10 212 11 112 12 112 13 225 5251 1 11 2 31 3 31 4 11 5 32 1 22 2 22 3 32 4 22 5 13 1 33 2 13 3 13 4 23 5 14 1 14 2 34 3 14 4 14 5 35 1 35 2 25 3 15 4 25 5 125 5251 1 21 2 11 3 21 4 11 5 22 1 12 2 12 3 22 4 22 5 23 1 13 2 13 3 13 4 33 5 34 1 24 2 14 3 34 4 34 5 35 1 25 2 15 3 25 4 15 5 1425 5251 1 21 2 31 3 21 4 31 5 32 1 12 2 22 3 32 4 32 5 23 1 33 2 13 3 33 4 23 5 14 1 34 2 14 3 34 4 24 5 35 1 15 2 15 3 35 4 35 5 2425 5251 1 31 2 11 3 21 4 21 5 12 1 12 2 32 3 32 4 32 5 13 1 13 2 23 3 13 4 13 5 34 1 24 2 24 3 14 4 34 5 15 1 25 2 25 3 35 4 25 5 1 输出 123456789101112131415161718192021222324252627282930313233343536373839-15 51 2 2 2 3 1 1 3 2 2 1 1 3 2 1 2 1 3 2 2 2 2 3 2 2 5 516143 13975 16499 16583 13958 14052 12162 14360 14438 12152 12440 10759 12704 12777 10751 15373 13308 15713 15794 13293 17168 14856 17540 17632 14838 5 51945386 1782533 1254468 1903751 1285027 1693395 1551629 1091979 1657151 1118577 1498468 1373016 966290 1466390 989824 1852660 1697571 1194674 1813009 1223776 2068355 1895207 1333773 2024085 1366260 5 51945386 1782533 1254468 1903751 1285027 1693395 1551629 1091979 1657151 1118577 1498468 1373016 966290 1466390 989824 1852660 1697571 1194674 1813009 1223776 2068355 1895207 1333773 2024085 1366260 -1-15 516 11 20 22 23 15 10 19 22 24 14 8 17 15 18 14 9 18 16 17 15 9 19 17 20 5 5192 135 260 234 202 187 130 255 229 198 150 108 202 184 156 156 111 208 188 160 167 119 225 204 173 限制 2s, 64MB for each test case. 算法描述 定义结构体matrixTerm，成员为矩阵元素所在的行row，矩阵元素所在的列col，矩阵元素的值value。 在数组描述线性表arrayList的基础上增加方法reSet,set,clear。reSet方法把线性表元素个数改为newSize，必要时增大数组容量，set方法使元素theElement成为表中索引为theIndex的元素，clear方法使表的元素个数为0。增加赋值运算符重载方法，实现一个线性表对当前线性表的赋值。 使用数组存储结构，按照行主映射，封装稀疏矩阵类sparseMatrix，私有成员包括矩阵的行数rows和列数cols，非0项表terms。公有成员包括构造函数，复制构造函数，析构函数，对赋值运算符的重载，重置矩阵，矩阵转置，矩阵相加，矩阵相乘，输入矩阵，输出矩阵。每个方法的具体思想如下： reSet：重置矩阵。清空terms表，首先读入矩阵的行数和列数，然后按照行列读入元素值，读入后判断元素值是否为0，若不为0，对三元组mTerm的row，col，value赋值，将mTerm插入到terms中的合适位置。 transpose：矩阵转置。创建稀疏矩阵类的对象b用来保存* this的转置，设置转置矩阵的特征，通过colSize和rowNext找出b中每一行的起点，利用迭代器遍历* this的terms表中的每个元素，通过rowNext的记录将b中对应位置的元素设置为mTerm，最后将b赋值给* this。 add：矩阵相加。创建稀疏矩阵类的对象b，调用input方法读入稀疏矩阵。根据矩阵加法的定义判断* this和b是否可以相加，若不能输出-1然后返回，若能，创建稀疏矩阵类的对象c存储相加结果，设置c的特征，首先通过循环利用迭代器遍历* this和b，把相关的项相加，每次相加分为三种情况进行考虑，b项在后，t项在后，两项在同一个位置。循环结束后对* this或b中剩余的元素进行处理，将其插入到c中terms表的合适位置。最后将c赋值给* this。 multiply：矩阵相乘。创建稀疏矩阵类的对象b，调用input方法读入稀疏矩阵。根据矩阵乘法的定义判断* this和b是否可以相乘，若不能输出-1然后返回，若能，创建稀疏矩阵类的对象c存储相乘结果，设置c的特征。与矩阵转置类似，先通过循环寻找b中每一行的项的数目和每一行的起点。通过循环利用迭代器遍历* this，根据rowNext和rowSize在内部嵌套一层循环把相关的项相乘，两层循环结束后将非零元素插入到c中terms表的合适位置。最后将c赋值给* this。 input：输入矩阵。首先输入矩阵的特征rows，cols，numberOfTerms，调用terms的reSet方法，确定terms的长度，然后循环读入每个非零元素，通过terms的set方法将terms对应位置的值设置为mTerm。 output：输出矩阵。首先输出矩阵的行数和列数，然后定义迭代器i和iEnd，设计两层循环，判断当前位置是否是i所指的三元组的位置，若是则表明当前位置是非零元素，输出三元组对应位置的value值，然后i++，若不是则输出0。 C++实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;iterator&gt;using namespace std;template &lt;class T&gt;class arrayList{protected: int listSize; //线性表的元素个数 int arrayLength; //一维数组的容量 T* element; //存储线性表的一维数组public: arrayList(int initialCapacity=10); //构造函数 arrayList(const arrayList&amp; theList); //复制构造函数 ~arrayList(); //析构函数 //ADT方法 bool empty() const {return listSize==0;} //判断线性表是否为空 int size() const {return listSize;} //返回线性表的大小 T&amp; get(int theIndex) const; //返回索引为theIndex的元素 int indexOf(const T&amp; theElement) const; //返回元素theElement第一次出现时的索引，若不存在返回-1 void erase(int theIndex); //删除索引为theIndex的元素 void insert(int theIndex,const T&amp; theElement);//在索引为theIndex处插入元素theElement void output(ostream&amp; out) const; //把线性表插入输入流 //其他方法 int capacity() const {return arrayLength;} //返回一维数组容量的大小 //运算符重载 arrayList&lt;T&gt;&amp; operator=(const arrayList&lt;T&gt;&amp; a) {//赋值运算符重载，使用前必须先调用reSet方法 copy(a.element,a.element+a.listSize,element); return *this; } //扩展方法 //用于稀疏矩阵的方法 void reSet(int newSize); //把线性表元素个数改为newSize，必要时增大数组容量 void set(int theIndex,const T&amp; theElement); //使元素theElement成为表中索引为theIndex的元素 void clear(); //使表的元素个数为0 //迭代器 class iterator { protected: T* position; //指向表元素的指针 public: //用C++的typedef语句实现双向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(T* thePosition=0) //构造函数 { position=thePosition; } //解引用操作符 T&amp; operator* () const {return *position;} T* operator-&gt; () const {return &amp;*position;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { ++position; return *this; } iterator operator++ (int)//后++ { iterator old=*this; ++position; return old; } //迭代器减法操作 iterator&amp; operator-- ()//前-- { --position; return *this; } iterator operator-- (int)//后-- { iterator old=*this; --position; return old; } //相等检验 bool operator!= (const iterator right) const { return position!=right.position; } bool operator== (const iterator right) const { return position==right.position; } }; iterator begin() const {return iterator(element);} iterator end() const {return iterator(element+listSize);} //iterator setIterator(int offset) const {return iterator(element+offset);}};template&lt;class T&gt;arrayList&lt;T&gt;::arrayList(int initialCapacity){//构造函数 arrayLength=initialCapacity; element=new T[arrayLength]; listSize=0;}template&lt;class T&gt;arrayList&lt;T&gt;::arrayList(const arrayList&amp; theList){//复制构造函数 arrayLength=theList.arrayLength; listSize=theList.listSize; element=new T[arrayLength]; copy(theList.element,theList.element+listSize,element);}template&lt;class T&gt;arrayList&lt;T&gt;::~arrayList(){//析构函数 delete []element;}template&lt;class T&gt;T&amp; arrayList&lt;T&gt;::get(int theIndex) const{//返回索引为theIndex的元素 return element[theIndex];}template&lt;class T&gt;int arrayList&lt;T&gt;::indexOf(const T&amp; theElement) const{//返回元素theElement第一次出现时的索引，若不存在返回-1 //查找元素theElement int theIndex=(int) (find(element,element+listSize,theElement)-element); //确定元素theElement是否找到 if(theIndex==listSize) //没有找到 return -1; else //已经找到 return theIndex;}template&lt;class T&gt;void arrayList&lt;T&gt;::erase(int theIndex){//删除索引为theIndex的元素 //移动其索引大于theIndex的元素 copy(element+theIndex+1,element+listSize,element+theIndex); element[--listSize].~T(); //调用析构函数}template&lt;class T&gt;void arrayList&lt;T&gt;::insert(int theIndex,const T&amp; theElement){//在索引为theIndex处插入元素theElement if(listSize==arrayLength) //确定数组是否已满 { T* Nelement=new T[arrayLength*2]; arrayLength=arrayLength*2; copy(element,element+listSize,Nelement); delete []element; element=Nelement; } //把元素向右移动一个位置 copy_backward(element+theIndex,element+listSize,element+listSize+1); element[theIndex]=theElement; listSize++;}template&lt;class T&gt;void arrayList&lt;T&gt;::output(ostream&amp; out) const{//把线性表插入输入流 copy(element,element+listSize,ostream_iterator&lt;T&gt;(cout,&quot; &quot;));}template&lt;class T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out,const arrayList&lt;T&gt;&amp; x){//重载&lt;&lt; x.output(out); return out;}template &lt;class T&gt;void arrayList&lt;T&gt;::reSet(int newSize){//把线性表元素个数改为newSize，必要时增大数组容量 if(newSize==0) //设置为空表 { for(int i=0;i&lt;listSize;i++) element[i].~T(); listSize=0; return ; } if(listSize==newSize) ; else if(listSize&gt;newSize) { for(int i=newSize;i&lt;listSize;i++) element[i].~T(); listSize=newSize; } else //listSize&lt;newSize { if(arrayLength&gt;=newSize) //数组容量足够 { listSize=newSize; } else //数组容量不够 { T* Nelement=new T[newSize]; delete []element; element=Nelement; arrayLength=newSize; listSize=newSize; } }}template &lt;class T&gt;void arrayList&lt;T&gt;::set(int theIndex,const T&amp; theElement){//使元素theElement成为表中索引为theIndex的元素 element[theIndex]=theElement;}template &lt;class T&gt;void arrayList&lt;T&gt;::clear(){//使表的元素个数为0 for(int i=0;i&lt;listSize;i++) element[i].~T(); listSize=0;}template &lt;class T&gt;struct matrixTerm //三元组{ int row,col; //矩阵元素所在行和所在列 T value; //矩阵元素的值};template &lt;class T&gt;class sparseMatrix{private: int rows,cols; //矩阵的行数和列数 arrayList&lt;matrixTerm&lt;T&gt;&gt; terms; //非0项表public: //构造函数、复制构造函数和析构函数 sparseMatrix() {} sparseMatrix(const sparseMatrix&lt;T&gt;&amp; x):terms(x.terms),rows(x.rows),cols(x.cols) {} ~sparseMatrix() {} //方法 void reSet(); //重置矩阵 void transpose(); //矩阵转置 void add(); //矩阵相加 void mul(); //矩阵相乘 void input(); //输入矩阵 void output(); //输出矩阵 //运算符重载 sparseMatrix&lt;T&gt;&amp; operator=(const sparseMatrix&lt;T&gt;&amp; x);};template &lt;class T&gt;void sparseMatrix&lt;T&gt;::reSet(){//重置矩阵 terms.clear(); //清空表 int value; //输入的矩阵元素值 int mSize=0; //插入三元组线性表的位置 matrixTerm&lt;T&gt; mTerm; cin&gt;&gt;rows&gt;&gt;cols; for(int i=1;i&lt;=rows;i++) { for(int j=1;j&lt;=cols;j++) { cin&gt;&gt;value; if(value!=0) //非零元素插入线性表 { mTerm.row=i; mTerm.col=j; mTerm.value=value; terms.insert(mSize,mTerm); mSize++; } } }}template&lt;class T&gt;void sparseMatrix&lt;T&gt;::transpose(){//b保存*this的转置，再将b赋值给*this sparseMatrix&lt;T&gt; b; //保存*this的转置 //设置转置矩阵的特征 b.cols=rows; b.rows=cols; b.terms.reSet(terms.size()); //初始化以实现转置 int* colSize=new int[cols+1]; int* rowNext=new int[cols+1]; //寻找*this中每一列的项的数目 for(int i=1;i&lt;=cols;i++)//初始化 colSize[i]=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=terms.begin();i!=terms.end();i++) colSize[(*i).col]++; //寻找b中每一行的起点 rowNext[1]=0; for(int i=2;i&lt;=cols;i++) rowNext[i]=rowNext[i-1]+colSize[i-1]; //实施从*this到b的转置复制 matrixTerm&lt;T&gt; mTerm; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=terms.begin();i!=terms.end();i++) { int j=rowNext[(*i).col]++; //b中的位置 mTerm.row=(*i).col; mTerm.col=(*i).row; mTerm.value=(*i).value; b.terms.set(j,mTerm); } delete []colSize; delete []rowNext; *this=b;}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::add(){//计算c=(*this)+b，再将c赋值给*this sparseMatrix&lt;T&gt; b; //和*this做加法的矩阵 b.input(); //不满足矩阵相加的条件 if(rows!=b.rows||cols!=b.cols) { *this=b; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; //printf(&quot;-1\\n&quot;); return ; } //可以进行矩阵相加 sparseMatrix&lt;T&gt; c; //结果矩阵 //设置结果为矩阵c的特征 c.rows=rows; c.cols=cols; c.terms.clear(); int cSize=0; //定义*this和b的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator it=terms.begin(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.begin(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator itEnd=terms.end(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ibEnd=b.terms.end(); //遍历*this和b，把相关的项相加 while(it!=itEnd &amp;&amp; ib!=ibEnd) { //行主索引加上每一行的列数 int tIndex=(*it).row*cols+(*it).col; int bIndex=(*ib).row*cols+(*ib).col; if(tIndex&lt;bIndex) {//b项在后 c.terms.insert(cSize++,*it); it++; } else if(tIndex==bIndex) {//两项在同一个位置 //仅当相加后不为0时加入c if((*it).value+(*ib).value!=0) { matrixTerm&lt;T&gt; mTerm; mTerm.row=(*it).row; mTerm.col=(*it).col; mTerm.value=(*it).value+(*ib).value; c.terms.insert(cSize++,mTerm); } it++; ib++; } else //t项在后 { c.terms.insert(cSize++,*ib); ib++; } } //复制剩余项 for(;it!=itEnd;it++) c.terms.insert(cSize++,*it); for(;ib!=ibEnd;ib++) c.terms.insert(cSize++,*ib); *this=c;}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::mul(){//计算c=(*this)*b，再将c赋值给*this sparseMatrix&lt;T&gt; b; //和*this做乘法的矩阵 b.input(); //不满足矩阵相乘的条件 if(cols!=b.rows) { *this=b; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; //printf(&quot;-1\\n&quot;); return ; } //可以进行矩阵相乘 sparseMatrix&lt;T&gt; c; //结果矩阵 //设置结果为矩阵c的特征 c.rows=rows; c.cols=b.cols; c.terms.clear(); int cSize = 0; //rowSize表示第i行元素的数目，rowNext表示第i行首元素的位置，0号位置不用 int* rowSize=new int[b.rows+1]; int* rowNext=new int[b.rows+1]; //寻找b中每一行的项的数目 for(int i=1;i&lt;=b.rows;i++) //初始化 rowSize[i]=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=b.terms.begin();i!=b.terms.end();i++) rowSize[(*i).row]++; //寻找b中每一行的起点 rowNext[1]=0; for(int i=2;i&lt;=cols;i++) rowNext[i]=rowNext[i-1]+rowSize[i-1]; //定义*this的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator itEnd=terms.end(); matrixTerm&lt;T&gt; sumTerm[c.rows*c.cols]; //保存计算结果 for(int i=0;i&lt;c.rows*c.cols;i++) //初始化 sumTerm[i].value=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator it=terms.begin();it!=itEnd;it++) { /*方法一：定义指向线性表首元素的迭代器，根据rowNext的值移动迭代器到合适位置 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.begin(); for(int i=0;i&lt;rowNext[(*it).col];i++) //移动迭代器 ib++; */ /*方法二：在arrayList中增加方法setIterator，可直接声明指向线性表任意位置的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.setIterator(rowNext[(*it).col]); */ /*方法一和方法二实现相乘 for(int k=0;k&lt;rowSize[(*it).col];k++) //相关的两个元素相乘 { sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].value+=(*it).value * (*ib).value; //确定行数和列数 sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].row=(*it).row; sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].col=(*ib).col; ib++; }*/ //方法三：使用terms的get方法 int iib=rowNext[(*it).col]; for(int k=0;k&lt;rowSize[(*it).col];k++) { sumTerm[(((*it).row-1) * c.cols) + b.terms.get(iib).col-1].value+=(*it).value * b.terms.get(iib).value; //确定行数和列数 sumTerm[(((*it).row-1) * c.cols) + b.terms.get(iib).col-1].row=(*it).row; sumTerm[(((*it).row-1) * c.cols) + b.terms.get(iib).col-1].col=b.terms.get(iib).col; iib++; } } for(int i=0;i&lt;c.rows*c.cols;i++) { if(sumTerm[i].value!=0) //非零元素插入到三元组的线性表中 { c.terms.insert(cSize++, sumTerm[i]); } } delete []rowSize; delete []rowNext; /*矩阵乘法O(n^4)实现方法 //定义*this和b的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator itEnd=terms.end(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ibEnd=b.terms.end(); matrixTerm&lt;T&gt; sumTerm[c.rows*c.cols]; //保存计算结果 for(int i=0;i&lt;c.rows*c.cols;i++) //初始化 sumTerm[i].value=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator it=terms.begin();it!=itEnd;it++) { for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.begin();ib!=ibEnd;ib++) { if((*it).col==(*ib).row) //相关的两个元素相乘 { sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].value+=(*it).value * (*ib).value; //确定行数和列数 sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].row=(*it).row; sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].col=(*ib).col; } } } for(int i=0;i&lt;c.rows*c.cols;i++) { if(sumTerm[i].value!=0) //非零元素插入到三元组的线性表中 { c.terms.insert(cSize++, sumTerm[i]); } }*/ *this=c;}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::input(){//输入一个稀疏矩阵 //输入矩阵特征 int numberOfTerms; //非零元素个数 cin&gt;&gt;rows&gt;&gt;cols&gt;&gt;numberOfTerms; terms.reSet(numberOfTerms); matrixTerm&lt;T&gt; mTerm; for(int i=0;i&lt;numberOfTerms;i++) { cin&gt;&gt;mTerm.row&gt;&gt;mTerm.col&gt;&gt;mTerm.value; terms.set(i,mTerm); }}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::output(){//输出一个稀疏矩阵 cout&lt;&lt;rows&lt;&lt;&quot; &quot;&lt;&lt;cols&lt;&lt;endl; //输出矩阵的行数和列数 //printf(&quot;%d %d\\n&quot;,rows,cols); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=terms.begin(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator iEnd=terms.end(); int val; //元素值 for(int k=1;k&lt;=rows;k++) { for(int j=1;j&lt;=cols;j++) { val=0; if(k==(*i).row &amp;&amp; j==(*i).col &amp;&amp;i!=iEnd) //不是非零元素 { val=(*i).value; //非零元素的值 i++; } cout&lt;&lt;val&lt;&lt;&quot; &quot;; //printf(&quot;%d &quot;,val); } cout&lt;&lt;endl; //printf(&quot;\\n&quot;); }}template &lt;class T&gt;sparseMatrix&lt;T&gt;&amp; sparseMatrix&lt;T&gt;::operator=(const sparseMatrix&lt;T&gt; &amp;x){//赋值运算符重载 if(this==&amp;x) //自我复制 return *this; terms.reSet(x.terms.size()); terms=x.terms; rows=x.rows; cols=x.cols; return *this;}int main(){ int w; //操作个数 int instruction; //指令编号 sparseMatrix&lt;int&gt; s; //创建对象 cin&gt;&gt;w; for(int i=0;i&lt;w;i++) { cin&gt;&gt;instruction; switch(instruction) { case 1: s.reSet(); break; case 2: s.mul(); break; case 3: s.add(); break; case 4: s.output(); break; case 5: s.transpose(); break; } } return 0;} 结果分析 1.本题时间限制为2s，只有当稀疏矩阵乘法的时间复杂度为O(n3)(n为矩阵的行数)时才能保证不超时，O(n4)最后2个节点会超时。 如果对于* this中的每一个元素，遍历b中每一个元素，比较所在行和列判断是否需要相乘，时间复杂度是O(n^4)，n为矩阵行数。优化方法与矩阵转置中的思想类似，先通过循环寻找b中每一行的元素个数和每一行的起点，对于* this中的某一个元素，由* this所在的列直接找出b中对应的行，该行的所有元素即为需要与其相乘的元素，循环次数为b中对应行的元素个数，这样时间复杂度是O(n^3)。 2.对“=”的运算符重载实现一个对象赋值给当前对象，不能使用默认的赋值运算符重载函数，因为arrayList类的成员中涉及到T类型的指针element，需要深复制，重新申请内存将element所指的数组中各个元素的值依次复制过来，而默认的运算符重载实现的是浅复制，只复制指针，不能复制指针指向的数组。 PS:最后五个节点是矩阵不稀疏的情况，最大数据量为100次询问，操作为100 * 100矩阵的乘法、加法、转置（大部分是乘法）。","link":"/2020/10/21/DSA/DSA_5/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"简单算法","slug":"简单算法","link":"/tags/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","link":"/tags/Visual-Studio-Code/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Computer Networks","slug":"Computer-Networks","link":"/tags/Computer-Networks/"},{"name":"树型结构","slug":"树型结构","link":"/tags/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84/"},{"name":"索引二叉搜索树","slug":"索引二叉搜索树","link":"/tags/%E7%B4%A2%E5%BC%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"稀疏矩阵","slug":"稀疏矩阵","link":"/tags/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"}],"categories":[{"name":"Data Structures,Algorithms,and Applications","slug":"Data-Structures-Algorithms-and-Applications","link":"/categories/Data-Structures-Algorithms-and-Applications/"},{"name":"Configuring the Environment","slug":"Configuring-the-Environment","link":"/categories/Configuring-the-Environment/"},{"name":"Hello world","slug":"Hello-world","link":"/categories/Hello-world/"},{"name":"Programming Thinking and Practice","slug":"Programming-Thinking-and-Practice","link":"/categories/Programming-Thinking-and-Practice/"},{"name":"Recording","slug":"Recording","link":"/categories/Recording/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"}]}