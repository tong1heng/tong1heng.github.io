<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Avocado Pear</title>
  
  <subtitle>Trust Your Trust</subtitle>
  <link href="https://tongyiheng.top/atom.xml" rel="self"/>
  
  <link href="https://tongyiheng.top/"/>
  <updated>2022-04-16T14:01:34.652Z</updated>
  <id>https://tongyiheng.top/</id>
  
  <author>
    <name>TongYiheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SwapKV：A Hotness Aware In-memory Key-Value Store for Hybrid Memory Systems</title>
    <link href="https://tongyiheng.top/2022/04/16/Embedded/SwapKV-TKDE21/"/>
    <id>https://tongyiheng.top/2022/04/16/Embedded/SwapKV-TKDE21/</id>
    <published>2022-04-16T13:58:20.000Z</published>
    <updated>2022-04-16T14:01:34.652Z</updated>
    
    <content type="html"><![CDATA[<p>This paper presents SwapKV, which strives to retain both the advantages of DRAM and PMEM, aiming to achieve both high performance and large capacity simultaneously.</p><span id="more"></span><center><embed src="/slides/SwapKV-TKDE21.pdf" width="850" height="600"></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;This paper presents SwapKV, which strives to retain both the advantages of DRAM and PMEM, aiming to achieve both high performance and large capacity simultaneously.&lt;/p&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    <category term="KV store" scheme="https://tongyiheng.top/categories/Embedded/KV-store/"/>
    
    
    <category term="paper reading" scheme="https://tongyiheng.top/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>Enabling Low Tail Latency on Multicore Key-Value Stores</title>
    <link href="https://tongyiheng.top/2022/04/05/Embedded/p1091-lersch/"/>
    <id>https://tongyiheng.top/2022/04/05/Embedded/p1091-lersch/</id>
    <published>2022-04-05T13:18:16.000Z</published>
    <updated>2022-04-05T13:22:58.048Z</updated>
    
    <content type="html"><![CDATA[<p>We present RStore to enable low and predictable latency (i.e. low tail latency) and efficient use of hardware resources such as CPU, memory and storage through the following design points:</p><ul><li>Asynchronous execution</li><li>Hybrid DRAM+NVM architecture</li><li>Log-structured storage</li><li>User-space networking</li></ul><span id="more"></span><center><embed src="/slides/p1091-lersch.pdf" width="850" height="600"></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;We present RStore to enable low and predictable latency (i.e. low tail latency) and efficient use of hardware resources such as CPU, memory and storage through the following design points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Asynchronous execution&lt;/li&gt;
&lt;li&gt;Hybrid DRAM+NVM architecture&lt;/li&gt;
&lt;li&gt;Log-structured storage&lt;/li&gt;
&lt;li&gt;User-space networking&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    <category term="KV store" scheme="https://tongyiheng.top/categories/Embedded/KV-store/"/>
    
    
    <category term="paper reading" scheme="https://tongyiheng.top/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>DFS Techniques</title>
    <link href="https://tongyiheng.top/2022/03/29/Embedded/dfs-techniques/"/>
    <id>https://tongyiheng.top/2022/03/29/Embedded/dfs-techniques/</id>
    <published>2022-03-29T11:14:02.000Z</published>
    <updated>2022-03-29T15:47:49.975Z</updated>
    
    <content type="html"><![CDATA[<p>Introduce two key techniques of distributed file system.</p><span id="more"></span><center><embed src="/slides/dfs-techniques.pdf" width="850" height="600"></center><h2 id="speech"><a class="markdownIt-Anchor" href="#speech"></a> Speech</h2><p>下面我来给大家介绍分布式文件系统中另外两个核心技术。</p><ul><li><p>首先是Scalability&amp;Usability也就是DFS的可扩展性和可用性。</p><ol><li>高可用的metadata<ul><li>DFS的metadata主要包括文件的命名空间、每个文件不同副本的位置、副本的的版本号等等。</li><li>在DFS中，metadata的存储主要有两种方式，一种是集中存储，把所有的元数据都存在一个metadata server，统一管理所有的元数据；另一种是将metadata分布到多个节点进行存储。这两种方式相比，集中存储更常用，将元数据和数据分离，整个系统拥有较高的吞吐量，便于实现。</li><li>以GFS为例，GFS的metadata主要包括三部分内容：<strong>命名空间、文件到chunk的映射关系、chunk的位置。</strong> 元数据存在唯一的GFS master中，文件按chunk进行划分，每个chunk的大小为64MB，每一个chunk会在多个chunk server中保存副本（默认为3个），chunk server将chunk作为Linux file保存在本地磁盘上。</li><li>如何根据metadata进行读操作：<ul><li>应用程序调用GFS client提供的接口，表明要读取的文件名、偏移、长度。</li><li>GFS Client将偏移按照规则翻译成chunk序号，发送给master。</li><li>master将chunk id与chunk的副本位置告诉GFS client。</li><li>GFS client向最近的持有副本的Chunkserver发出读请求，请求中包含chunk id与范围。</li><li>ChunkServer读取相应的文件，然后将文件内容发给GFS client。</li></ul></li></ul></li><li>Namespace delegation<br />DFS的命名空间主要是指DFS对文件目录的统一管理。分布式文件系统中，需要考虑并发在同一个目录下创建文件的情况。为了防止冲突，使用锁机制保证对命名空间的互斥访问。<ul><li>锁分为读锁和写锁，分别对应读操作和写操作。</li><li>e.g.<ul><li>如果对 /d1/d2/…/dn/leaf 进行操作</li><li>需要获得 /d1, /d1/d2, /d1/d2/…/dn 的读锁</li><li>需要 /d1/d2/…/dn/leaf 的读锁或者写锁</li></ul></li><li>通过命名空间锁可以允许在相同目录发生并发的变化。比如多个文件在同一个目录被并发创建，每个创建会申请此目录的读锁和各自文件的写锁，不会导致冲突。目录的读锁可以保护在创建时此目录不会被删除、重命名或者执行快照。对相同文件的创建请求，由于写锁的保护，也只会导致此文件被串行的创建两次。因为命名空间的节点不少，全量分配读写锁有点浪费资源，所以它们都是lazy分配、用完即删。而且锁申请不是随意的，为了防止死锁，一个操作必须按特定的顺序来申请锁：首先按命名空间树的层级排序，在相同层级再按字典序。</li></ul></li><li>可扩展性<br />DFS有很强的可扩展性，需要注意的问题：<ul><li>如何控制不同server之间的负载均衡</li><li>如何保证新加入的节点不会因短期负载压力过大而崩溃</li><li>如何更新元数据</li></ul></li></ol></li><li><p>然后是Fault-tolerance也就是容错性，DFS通过多副本机制保证容错性，副本之间要保证一致性。</p><ol><li>Checkpointing—metadata的崩溃一致性：metadata存在master的内存中，operation log记录重要的元数据变化的历史信息，是metadata的持久化记录，我们将它重复存在多个远程机器上，直到日志记录被flush到本地磁盘以及远程机器之后才会回复客户端。</li><li>Leases—租赁机制：保证数据修改时的一致性。<ul><li>由master指定primary replica和secondary replicas，60s后过期重新指定。</li><li>写操作流程：<ul><li>Client向master请求Chunk的副本信息，以及哪个副本（Replica）是Primary</li><li>master回复client，client缓存这些信息在本地</li><li>client将数据（Data）链式推送到所有副本</li><li>Client通知Primary提交</li><li>primary在自己成功提交后，通知所有Secondary提交</li><li>Secondary向Primary回复提交结果</li><li>primary回复client提交结果</li></ul></li></ul></li><li>Data的一致性：<ul><li>两种状态：consistent和defined，目的是在所有的replicas的执行相同的串行化操作序列保证file region的defined。</li><li>Handshake检测故障停机</li><li>Checksum检测数据可靠性</li><li>Version控制数据一致性</li><li>返回哪个副本给Client</li></ul></li></ol></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Introduce two key techniques of distributed file system.&lt;/p&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    
    <category term="distributed" scheme="https://tongyiheng.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>Less is More：De-amplifying I/Os for Key-value Stores with a Log-assisted LSM-tree</title>
    <link href="https://tongyiheng.top/2022/03/11/Embedded/ICDE21-huang/"/>
    <id>https://tongyiheng.top/2022/03/11/Embedded/ICDE21-huang/</id>
    <published>2022-03-11T11:35:56.000Z</published>
    <updated>2022-04-16T14:01:41.201Z</updated>
    
    <content type="html"><![CDATA[<p>We present a novel scheme, called Log-assisted LSM-tree (L2SM), which adopts a small-size, multi-level log structure to isolate selected key-value items that have a disruptive effect on the tree structure, accumulates and absorbs the repeated updates in a highly efficient manner, and removes obsolete and deleted key-value items at an early stage.</p><span id="more"></span><center><embed src="/slides/ICDE21-huang.pdf" width="850" height="600"></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;We present a novel scheme, called Log-assisted LSM-tree (L2SM), which adopts a small-size, multi-level log structure to isolate selected key-value items that have a disruptive effect on the tree structure, accumulates and absorbs the repeated updates in a highly efficient manner, and removes obsolete and deleted key-value items at an early stage.&lt;/p&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    <category term="KV store" scheme="https://tongyiheng.top/categories/Embedded/KV-store/"/>
    
    
    <category term="paper reading" scheme="https://tongyiheng.top/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://tongyiheng.top/2022/03/07/Web/HTML/"/>
    <id>https://tongyiheng.top/2022/03/07/Web/HTML/</id>
    <published>2022-03-07T12:45:09.000Z</published>
    <updated>2022-03-07T13:07:35.466Z</updated>
    
    <content type="html"><![CDATA[<p>One hour fast learning.</p><span id="more"></span><h2 id="what-is-html"><a class="markdownIt-Anchor" href="#what-is-html"></a> What is HTML?</h2><p>HTML 是用来描述网页的一种语言。</p><ul><li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li><li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用标记标签来<strong>描述</strong>网页</li><li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li><li>HTML文档也叫做 <strong>web 页面</strong></li></ul><h2 id="html速查列表"><a class="markdownIt-Anchor" href="#html速查列表"></a> HTML速查列表</h2><h3 id="html-基本文档"><a class="markdownIt-Anchor" href="#html-基本文档"></a> HTML 基本文档</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">可见文本...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基本标签basic-tags"><a class="markdownIt-Anchor" href="#基本标签basic-tags"></a> 基本标签（Basic Tags）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>最大的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>最小的标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> （换行）</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> （水平线）</span><br><span class="line"><span class="comment">&lt;!-- 这是注释 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文本格式化formatting"><a class="markdownIt-Anchor" href="#文本格式化formatting"></a> 文本格式化（Formatting）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>计算机代码<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调文本<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体文本<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>键盘输入<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>预格式化文本<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>更小的文本<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>重要的文本<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">abbr</span>&gt;</span> （缩写）</span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span> （联系信息）</span><br><span class="line"><span class="tag">&lt;<span class="name">bdo</span>&gt;</span> （文字方向）</span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> （从另一个源引用的部分）</span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span> （工作的名称）</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span> （删除的文本）</span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span> （插入的文本）</span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span> （下标文本）</span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span> （上标文本）</span><br></pre></td></tr></table></figure><h3 id="链接links"><a class="markdownIt-Anchor" href="#链接links"></a> 链接（Links）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">普通的链接：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">图像链接： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;替换文本&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">邮件链接： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:webmaster@example.com&quot;</span>&gt;</span>发送e-mail<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">书签：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;tips&quot;</span>&gt;</span>提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#tips&quot;</span>&gt;</span>跳到提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片images"><a class="markdownIt-Anchor" href="#图片images"></a> 图片（Images）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;替换文本&quot;</span> <span class="attr">height</span>=<span class="string">&quot;42&quot;</span> <span class="attr">width</span>=<span class="string">&quot;42&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="样式区块stylessections"><a class="markdownIt-Anchor" href="#样式区块stylessections"></a> 样式/区块（Styles/Sections）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>文档中的块级元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>文档中的内联元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>项目<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>项目<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义列表"><a class="markdownIt-Anchor" href="#定义列表"></a> 定义列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>项目 1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项目 1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>项目 2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项目 2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表格tables"><a class="markdownIt-Anchor" href="#表格tables"></a> 表格（Tables）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格数据<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格数据<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="框架iframe"><a class="markdownIt-Anchor" href="#框架iframe"></a> 框架（Iframe）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单forms"><a class="markdownIt-Anchor" href="#表单forms"></a> 表单（Forms）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo_form.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post/get&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">size</span>=<span class="string">&quot;40&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>樱桃<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;60&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实体entities"><a class="markdownIt-Anchor" href="#实体entities"></a> 实体（Entities）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span> 等同于 &lt;</span><br><span class="line"><span class="symbol">&amp;gt;</span> 等同于 &gt;</span><br><span class="line"><span class="symbol">&amp;#169;</span> 等同于 ©</span><br></pre></td></tr></table></figure><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://www.runoob.com/html/html-quicklist.html">https://www.runoob.com/html/html-quicklist.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;One hour fast learning.&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://tongyiheng.top/categories/Web/"/>
    
    
    <category term="html" scheme="https://tongyiheng.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://tongyiheng.top/2021/12/22/CS/OperatingSystem/"/>
    <id>https://tongyiheng.top/2021/12/22/CS/OperatingSystem/</id>
    <published>2021-12-22T09:18:42.000Z</published>
    <updated>2022-04-07T02:43:52.561Z</updated>
    
    <content type="html"><![CDATA[<p>What is the definition of <strong>“Operating System”</strong> ?</p><span id="more"></span><h2 id="第1章-导论"><a class="markdownIt-Anchor" href="#第1章-导论"></a> 第1章 导论</h2><ul><li>特权指令</li></ul><h2 id="第2章-操作系统结构"><a class="markdownIt-Anchor" href="#第2章-操作系统结构"></a> 第2章 操作系统结构</h2><ul><li><mark>System call</mark>: <strong>系统调用</strong>。运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。 系统调用提供了用户程序与操作系统之间的接口。<strong>系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理结果返回给应用程序。</strong></li><li><mark>API</mark>: <strong>应用编程接口</strong>，系统和应用程序通过这个接口，可在执行中访问系统中的资源和取得 OS 的服务，它也是程序能取得操作系统服务的唯一途径。大多数操作系统的程序接口是由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序 。</li></ul><h2 id="第3章-进程"><a class="markdownIt-Anchor" href="#第3章-进程"></a> 第3章 进程</h2><h3 id="进程概念"><a class="markdownIt-Anchor" href="#进程概念"></a> 进程概念</h3><ul><li><p><mark>进程（process）</mark>：进程是正在执行的程序，进程实体包括代码段、数据段、堆、栈、程序计数器、寄存器等。进程通过PCB表示。进程是系统中独立获得资源和独立调度（在不支持多线程的系统中）的基本单位。</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231543448.png" alt="" /></p></li><li><p>状态转换图</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231546527.png" alt="" /></p></li><li><p><strong>PCB</strong>包含的信息有进程状态、程序计数器、CPU寄存器、CPU调度信息、内存管理信息、记账信息、I/O状态信息。</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231551017.png" alt="" /></p></li></ul><h3 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h3><ul><li><p>队列图</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231601696.png" alt="" /></p></li><li><p><mark>长期调度程序</mark>：**从进程的缓冲池中选择进程，加载到内存执行。**控制多道程序程序（内存中进程的数量）。应该选择I/O密集型和CPU密集型的合理进程组合。</p></li><li><p><mark>中期调度程序</mark>：<strong>可将进程从内存中移出，从而降低多道程序程度。之后进程可被重新调入内存，并从中断处继续执行。</strong></p></li><li><p><mark>短期调度程序</mark>：<strong>从准备执行的进程中选择进程，并分配CPU。</strong></p></li><li><p>长期调度程序和短期调度程序的主要区别是<strong>执行频率</strong>，短期调度程序必须经常为CPU选择新的进程（通常每100ms至少执行一次），长期调度程序只有在进程离开系统时才需要，执行并不频繁。</p></li><li><p><mark>上下文切换</mark>：**切换CPU到另一个进程需要保存当前进程的状态和恢复另一个进程的状态。**进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。</p></li></ul><h3 id="进程运行"><a class="markdownIt-Anchor" href="#进程运行"></a> 进程运行</h3><ul><li><p>进程创建的三种情况</p><ul><li>系统初始化</li><li>用户请求创建新的进程</li><li>正在执行系统调用创建进程的API</li></ul></li><li><p>UNIX进程树</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231617961.png" alt="" /></p><ul><li><strong>0进程</strong>：是一个特殊进程，它是在系统引导时被创建的；</li><li><strong>1进程</strong>：当0进程创建了一个子进程1后，0进程就变成对换进程(swapper)；</li><li><strong>1进程被称为init进程</strong>，是系统中其他每个进程的祖先；</li><li>进程0是系统中唯一不通过fork()创建的进程；</li></ul></li><li><p><strong>fork系统调用</strong></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231620774.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231621664.png" alt="" /></p><ul><li><p>几个要点</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231622445.png" alt="" /></p></li><li><p>进一步讨论</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231622396.png" alt="" /></p></li></ul></li></ul><h3 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h3><ul><li>共享内存</li><li>消息队列</li></ul><h2 id="第4章-多线程编程"><a class="markdownIt-Anchor" href="#第4章-多线程编程"></a> 第4章 多线程编程</h2><ul><li><mark>线程（thread）</mark>: 线程是CPU调度与分派的基本单位。线程隶属于进程，不能脱离进程而独立存在。一个进程至少需要一个线程，线程运行在所属进程的上下文中。隶属于同一个进程的多个线程共享该进程的代码、数据、堆、打开的文件等I/O资源，不能共享进程的栈。线程只拥有其运行所必须的资源，如寄存器、栈等。</li></ul><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112222045087.png" alt="" /></p><ul><li><p>用户线程与核心线程</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231701989.png" alt="" /></p></li><li><p>多线程模型</p><ul><li>多对一模型</li><li>一对一模型</li><li>多对多模型、双层模型</li></ul></li><li><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231707095.png" alt="" /></p></li><li><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231708473.png" alt="" /></p></li></ul><h2 id="第5章-进程调度"><a class="markdownIt-Anchor" href="#第5章-进程调度"></a> 第5章 进程调度</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><ul><li><p><mark>抢先调度</mark></p></li><li><p><mark>非抢先调度</mark></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231716020.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231717052.png" alt="" /></p></li><li><p>结合状态转换图</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231723150.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231723456.png" alt="" /></p></li></ul><h3 id="调度准则"><a class="markdownIt-Anchor" href="#调度准则"></a> 调度准则</h3><ul><li>CPU使用率</li><li>吞吐量：一个时间单元内进程完成的数量。</li><li>周转时间：从进程提交到进程完成的时间段。</li><li>等待时间：在就绪队列中等待所花时间之和。</li><li>响应时间：从提交请求到产生第一响应的时间。</li><li>最大化CPU使用率和吞吐量，并且最小化周转时间、等待时间和响应时间。</li></ul><h3 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h3><ul><li><p><strong>先到先服务（FCFS）</strong></p><ul><li><p>缺点：平均等待时间往往很长、护航效果（所有其他进程等待一个大进程释放CPU，convoy effect）</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231725451.png" alt="" /></p></li><li><p>非抢占</p></li></ul></li><li><p><strong>最短作业优先调度（SJF）</strong></p><ul><li>可以是非抢占也可以是抢占（<strong>最短剩余时间优先，SRTF</strong>）</li><li><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231726014.png" alt="" /></li></ul></li><li><p><strong>优先级调度（priority-scheduling）</strong></p><ul><li>具有最高优先级的进程会分配到CPU，具有相同优先级的进程按FCFS</li><li>I/O密集型优先级比CPU密集型高，让CPU与I/O设备并行运行，提高吞吐量</li><li>可以是抢占也可以是非抢占</li><li>缺点：饥饿（解决办法：老化）</li></ul></li><li><p><strong>轮转调度（RR）</strong></p><ul><li>循环整个就绪队列，为每个进程分配不超过一个时间片的CPU</li><li>抢占</li><li><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231732598.png" alt="" /></li></ul></li><li><p><strong>多级队列调度</strong></p><ul><li>将就绪队列分为多个单独队列，每个队列有自己的调度算法</li><li>e.g. 前台队列RR算法，后台队列FCFS算法</li><li>队列之间的调度<ul><li>固定优先级，如前台队列比后台队列有绝对的优先</li><li>在队列之间划分时间片，如前台队列有80%的CPU时间，后台队列有20%的CPU时间</li></ul></li></ul></li><li><p><strong>多级反馈队列调度</strong></p><ul><li><p>允许进程在队列之间迁移。如果进程使用过多的CPU时间，它会被移到更低的优先级队列。这种方案将I/O密集型和交互进程放在更高优先队列上。此外，在较低优先级队列中等待过长的进程会被移到更高优先级队列，老化阻止饥饿发生。</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231738321.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231739792.png" alt="" /></p></li></ul></li><li><p>一道选择题</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231728911.png" alt="" /></p><p><strong>Answer: A</strong></p><ul><li><p>对于A，进程执行完自己的时间片，可能该进程的优先级比较高，而且此时引起进程调度，可以重新计算各进程的优先级，因此选A。</p></li><li><p>对于B、C应该提升进程的优先级。</p></li><li><p>对于D，进程刚被调度选中运行，不会重新引起进程调度，不是调整优先级的好时机，且进程的剩余时间等因素尚不明了。</p></li></ul></li></ul><h2 id="第6章-同步"><a class="markdownIt-Anchor" href="#第6章-同步"></a> 第6章 同步</h2><ul><li><p>原子操作、原语</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112230958476.png" alt="" /></p></li><li><p><mark>Race Condition</mark>: <strong>多个进程并发访问和操作同一数据并且执行结果与特定访问顺序有关，称为竞争条件。</strong></p></li><li><p><mark>同步</mark>：并发执行环境下，保持操作之间偏序关系的行为，称为同步。</p></li><li><p><mark>临界资源</mark>：在一段时间内只允许一个进程访问的资源。临界资源要求互斥访问。</p></li><li><p><mark>临界区</mark>：在程序中访问临界资源的那段代码称为临界区，进程对临界区必须互斥访问。</p></li><li><p><mark>解决临界区问题的三个要求</mark></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231003418.png" alt="" /></p></li><li><p><mark>互斥</mark>：临界资源不能同时访问，互斥是对操作之间并发执行的约束。</p></li><li><p><mark>Peterson’s Solution</mark></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231113392.png" alt="" /></p></li><li><p><mark>Test and Set</mark></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231113880.png" alt="" /></p></li><li><p><mark>Swap</mark></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231114429.png" alt="" /></p></li></ul><h2 id="第7章-死锁"><a class="markdownIt-Anchor" href="#第7章-死锁"></a> 第7章 死锁</h2><h3 id="系统模型"><a class="markdownIt-Anchor" href="#系统模型"></a> 系统模型</h3><ul><li><p><mark>死锁</mark>：<strong>死锁是指一组处于等待（阻塞）状态的进程，每一个进程持有其它进程所需要的资源，而又等待使用其它进程所拥有的资源，致使这组进程互相等待，均无法向前推进。</strong></p></li><li><p>死锁是指一组处于等待（阻塞）状态的进程，互相等待只有这组进程才能产生的事件，致使这组进程都无法往前推进，这些永远在互相等待的进程称为死锁进程。</p></li><li><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其它进程才能引发的事件，那么该进程集合就是死锁的，我们称这些进程处于死锁状态，这些进程是死锁进程。</p></li><li><p>死锁产生的原因</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231929027.png" alt="" /></p></li></ul><h3 id="死锁特征"><a class="markdownIt-Anchor" href="#死锁特征"></a> 死锁特征</h3><ul><li><p>必要条件</p><ul><li><strong>互斥</strong>：至少有一个资源必须处于非共享模式，即一次只有一个进程可使用。如果另一进程申请该资源，那么申请进程应等到该资源释放为止。</li><li><strong>占有并等待</strong>：一个进程应占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。</li><li><strong>非抢占</strong>：资源不能被抢占，即资源只能被进程在完成任务后自愿释放。</li><li><strong>循环等待</strong>：有一组进程{P0,P1,…,Pn}，P0等待的资源为P1所占有，P1等待的资源为P2所占有，…，Pn-1等待的资源为Pn所占有，Pn等待的资源为P0所占有。</li></ul><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231933818.png" alt="" /></p></li><li><p>资源分配图（resource-allocation graph, RAG）</p><ul><li>矩形表示资源类型Rj，矩形内的点的数量表示实例数量。</li><li>圆表示进程Pi。</li><li>申请边：Pi --&gt; Rj</li><li>分配边：Rj --&gt; Pi</li></ul></li><li><p>如果资源分配图没有环，那么系统就没有死锁进程；如果分配图有环，那么可能存在死锁。</p></li><li><p>单实例，有环存在死锁；多实例，有环不一定死锁。</p></li></ul><h3 id="死锁处理方法"><a class="markdownIt-Anchor" href="#死锁处理方法"></a> 死锁处理方法</h3><ul><li><p>死锁预防</p></li><li><p>死锁避免</p></li><li><p>死锁检测、恢复</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232102168.png" alt="" /></p></li></ul><h3 id="死锁预防"><a class="markdownIt-Anchor" href="#死锁预防"></a> 死锁预防</h3><ul><li><p>确保至少一个必要条件不成立</p><ul><li>互斥：必须成立</li><li>持有且等待<ul><li>占有不等待：每个进程在执行前申请并获得所有资源。</li><li>等待不占有：进程在申请更多资源之前，必须释放现已分配的所有资源。</li><li>优点：简单，易于实现，安全。</li><li>缺点：资源利用率低，饥饿。很多进程直到运行时才知道需要多少资源。</li></ul></li><li>无抢占<ul><li>如果一个进程持有资源并申请另一个不能立即分配的资源（也就是说，这个进程应等待），那么它现在分配的资源都可被抢占。</li><li>通常用于状态可以保存和恢复的资源，如CPU寄存器和内存。一般不适用于其他资源，如互斥锁和信号量。</li></ul></li><li>循环等待<ul><li>对所有资源类型进行完全排序，而且要求每个进程按递增顺序来申请资源。</li></ul></li></ul></li><li><p>计算</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231958706.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112231959792.png" alt="" /></p></li></ul><h3 id="死锁避免"><a class="markdownIt-Anchor" href="#死锁避免"></a> 死锁避免</h3><ul><li><p>安全状态、非安全状态</p><ul><li>安全状态不是死锁状态，死锁状态是非安全状态。</li></ul></li><li><p>总体思想：当进程提出资源请求时，系统进行<strong>假分配</strong>，然后检测假分配之后的状态是否安全，如果不安全，则不满足系统的请求；否则，满足本次进程的资源请求。</p></li><li><p>单实例：资源分配图算法</p><ul><li><p>需求边：Pi --&gt; Rj 虚线表示</p></li><li><p>如果有环，则是非安全状态。</p></li><li><p>算法描述</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232027304.png" alt="" /></p></li></ul></li><li><p>多实例：银行家算法</p><ul><li><p>打破循环等待</p></li><li><p>Available、Max、Allocation、Need</p></li><li><p>安全算法</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232055125.png" alt="" /></p></li><li><p>资源请求算法</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232056550.png" alt="" /></p></li></ul></li></ul><h3 id="死锁检测"><a class="markdownIt-Anchor" href="#死锁检测"></a> 死锁检测</h3><ul><li><p>单实例：等待图</p><ul><li><p>当且仅当等待图中有一个环，系统死锁。</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232105172.png" alt="" /></p></li></ul></li><li><p>多实例：类似于银行家算法</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232106852.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232106710.png" alt="" /></p></li></ul><h3 id="死锁恢复"><a class="markdownIt-Anchor" href="#死锁恢复"></a> 死锁恢复</h3><ul><li>进程终止<ul><li>中止所有死锁进程</li><li>一次中止一个进程，直到消除死锁循环为止。</li></ul></li><li>资源抢占<ul><li>选择牺牲进程</li><li>回滚</li><li>饥饿</li></ul></li></ul><h2 id="第8章-内存管理策略"><a class="markdownIt-Anchor" href="#第8章-内存管理策略"></a> 第8章 内存管理策略</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><ul><li><p>地址绑定</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232118874.png" alt="" /></p></li><li><p>链接</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232120650.png" alt="" /></p></li></ul><h3 id="交换"><a class="markdownIt-Anchor" href="#交换"></a> 交换</h3><ul><li>不能换出等待I/O处理的进程。</li><li>I/O操作的执行只能使用操作系统的缓冲。</li></ul><h3 id="连续内存分配"><a class="markdownIt-Anchor" href="#连续内存分配"></a> 连续内存分配</h3><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232128921.png" alt="" /></p><ul><li><p>静态分区</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232131410.png" alt="" /></p></li><li><p>动态分区</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232132089.png" alt="" /></p><ul><li>首次适应：分配首个足够大的孔。</li><li>最优适应：分配最小的足够大的孔。</li><li>最差适应：分配最大的孔。</li></ul></li><li><p>碎片</p><ul><li>内部碎片</li><li>外部碎片</li></ul><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232138391.png" alt="" /></p></li><li><p>共享？</p></li><li><p>分区管理的特点</p><ul><li>整个的作业或进程存放在一段连续的内存区域；</li><li>管理简单；</li><li>对于比较大的作业，有时找到一个足够大的连续区域比较困难；</li></ul><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232143036.png" alt="" /></p></li></ul><h3 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h3><ul><li><p>基本方法</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112240958130.png" alt="" /></p></li><li><p>硬件支持</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241000244.png" alt="" /></p></li></ul><h3 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h3><ul><li><p>基本方法</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232145596.png" alt="" /></p></li><li><p>地址变换过程</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232151180.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232201528.png" alt="" /></p></li><li><p>硬件支持</p><p><img src="E:/Typora/image-20211223220057399.png" alt="image-20211223220057399" /></p></li><li><p>保护</p><ul><li><p>检查页号是否超出了自己的地址空间所定义的范围（要访问的是否是非法页面，即非法地址）</p><ul><li><p>valid-invalid位</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232205871.png" alt="" /></p></li></ul></li><li><p>检查对该页框（帧）的访问许可：只读、读写、执行等</p><ul><li>在页表中设置相应的位表示该页框的访问许可</li></ul></li></ul></li><li><p>共享</p><ul><li>可重入代码或纯代码</li><li>Shared code must appear in same location in the logical address space of all processes.</li></ul></li></ul><h3 id="页表结构"><a class="markdownIt-Anchor" href="#页表结构"></a> 页表结构</h3><ul><li><p>层次页表</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112232223250.png" alt="" /></p></li><li><p>哈希页表</p></li><li><p>倒置页表</p></li></ul><h2 id="第9章-虚拟内存管理"><a class="markdownIt-Anchor" href="#第9章-虚拟内存管理"></a> 第9章 虚拟内存管理</h2><ul><li><p>基本思想</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241008108.png" alt="" /></p></li><li><p>要点</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241009623.png" alt="" /></p></li></ul><h3 id="请求调页"><a class="markdownIt-Anchor" href="#请求调页"></a> 请求调页</h3><ul><li><p>区分内存页面和磁盘页面</p></li><li><p>缺页错误</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241016414.png" alt="" /></p></li><li><p>有效访问时间</p></li></ul><h3 id="写时复制"><a class="markdownIt-Anchor" href="#写时复制"></a> 写时复制</h3><ul><li>fork()系统调用<strong>不真正复制</strong>父进程到子进程的空间，而仅仅是建立一个引用。</li><li>只有被修改了的页面才进行复制，实现父子进程地址空间的真正分离。</li></ul><h3 id="页面置换"><a class="markdownIt-Anchor" href="#页面置换"></a> 页面置换</h3><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241020540.png" alt="" /></p><ul><li>FIFO<ul><li>Belady异常<ul><li>e.g. 1 2 3 4 1 2 5 1 2 3 4 5</li><li>4帧的缺页错误数（10）比3帧的缺页错误数（9）还要大。</li></ul></li></ul></li><li>最优页面置换<ul><li>置换最长时间不会使用的页面</li><li>作为baseline</li></ul></li><li>LRU</li><li>近似LRU<ul><li>额外引用位算法</li><li>第二次机会算法</li></ul></li><li>基于计数的页面置换<ul><li>LFU</li><li>MFU</li></ul></li><li>页面缓冲算法</li></ul><h3 id="帧分配"><a class="markdownIt-Anchor" href="#帧分配"></a> 帧分配</h3><ul><li><p>分配算法</p><ul><li>平均分配</li><li>比例分配</li></ul></li><li><p>全局分配与局部分配</p></li><li><p>抖动</p><ul><li><p>高度的页面调度活动。如果一个进程的调页时间多于它的执行时间，那么这个进程在抖动。</p></li><li><p>产生原因</p><ul><li>为提高CPU利用率，需要装入更多的程序以提高系统的多道程序度，从而提高CPU的利用率；</li><li>当多道程序度过度增加时，每个进程所分配的内存不足以支持进程的运行，页面错误就会频繁发生；</li><li>系统在页面置换上所花费的时间多于进程的运行时间，导致CPU的利用率急剧下降。</li></ul></li><li><p>工作集模型</p><ul><li>工作集：最近△个页面引用的页面集合。</li></ul></li><li><p>缺页错误频率</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241055080.png" alt="" /></p></li></ul></li></ul><h2 id="第10章-文件系统"><a class="markdownIt-Anchor" href="#第10章-文件系统"></a> 第10章 文件系统</h2><h2 id="第11章-文件系统实现"><a class="markdownIt-Anchor" href="#第11章-文件系统实现"></a> 第11章 文件系统实现</h2><ul><li><mark>虚拟文件系统</mark>：虚拟文件系统（VFS）是物理文件系统与文件系统服务之间的一个接口层（VFS Interface），它对每个物理文件系统的所有细节进行抽象，并为这些不同的文件系统提供了一个统一的系统调用接口。</li></ul><h2 id="第12章-大容量存储结构"><a class="markdownIt-Anchor" href="#第12章-大容量存储结构"></a> 第12章 大容量存储结构</h2><h3 id="磁盘调度"><a class="markdownIt-Anchor" href="#磁盘调度"></a> 磁盘调度</h3><ul><li>FCFS</li><li>SSTF</li><li>SCAN C-SCAN</li><li>LOOK C-LOOK</li></ul><h3 id="raid结构"><a class="markdownIt-Anchor" href="#raid结构"></a> RAID结构</h3><ul><li><mark>RAID</mark>: <strong>磁盘冗余阵列</strong>，用于处理磁盘的性能与可靠性问题。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。根据选择的版本不同，RAID 比单硬盘有以下好处：增强数据集成度，增强容错功能，增加处理量或容量。另外，磁盘阵列对于计算机来说，看起来就像一个单独的硬盘或逻辑存储单元。简单来说，RAID 把多个硬盘组合成为一个逻辑扇区，因此，操作系统只会把它当作一个硬盘。RAID 常被用在服务器计算机上，并且常使用完全相同的硬盘作为组合。</li><li>通过冗余提高可靠性，通过并行处理提高性能。</li><li>RAID级别</li></ul><h2 id="第13章-io系统"><a class="markdownIt-Anchor" href="#第13章-io系统"></a> 第13章 I/O系统</h2><ul><li><p><mark>Device Driver</mark>: <strong>设备驱动程序</strong>，是一个允许高级计算机软件与硬件交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线或其它沟通子系统与硬件形成连接的机制，这样的机制使得硬件设备上的数据交换成为可能，使得操作系统能够控制硬件设备。<strong>设备驱动程序为内核I/O子系统隐藏设备控制器之间的差异。</strong></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112222106134.png" alt="" /></p></li><li><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241717935.png" alt="" /></p></li><li><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241718307.png" alt="" /></p></li><li><p>spooling</p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/OperatingSystem/202112241720231.png" alt="" /></p></li></ul><h2 id="第14章-系统保护"><a class="markdownIt-Anchor" href="#第14章-系统保护"></a> 第14章 系统保护</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;What is the definition of &lt;strong&gt;“Operating System”&lt;/strong&gt; ?&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://tongyiheng.top/categories/Computer-Science/"/>
    
    <category term="Operating System" scheme="https://tongyiheng.top/categories/Computer-Science/Operating-System/"/>
    
    
    <category term="operating system" scheme="https://tongyiheng.top/tags/operating-system/"/>
    
  </entry>
  
  <entry>
    <title>Snappy Algorithm</title>
    <link href="https://tongyiheng.top/2021/10/18/Embedded/snappy/"/>
    <id>https://tongyiheng.top/2021/10/18/Embedded/snappy/</id>
    <published>2021-10-18T14:18:42.000Z</published>
    <updated>2022-04-07T02:43:43.680Z</updated>
    
    <content type="html"><![CDATA[<p>How to analyse the source codes of snappy ? In this blog, the pseudocode of compression and uncompression using snappy is given, which is aimed to help you understand snappy algorithm.</p><span id="more"></span><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p>Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression. For instance,      compared to the fastest mode of zlib, Snappy is an order of magnitude faster for most inputs, but the resulting compressed files are anywhere from 20% to 100% bigger. (For more information, see “Performance”, below.)</p><p>Snappy has the following properties:</p><ul><li>Fast: Compression speeds at 250 MB/sec and beyond, with no assembler code. See “Performance” below.</li><li>Stable: Over the last few years, Snappy has compressed and decompressed petabytes of data in Google’s production environment. The Snappy bitstream format is stable and will not change between versions.</li><li>Robust: The Snappy decompressor is designed not to crash in the face of corrupted or malicious input.</li><li>Free and open source software: Snappy is licensed under a BSD-type license. For more information, see the included COPYING file.</li></ul><p>Snappy has previously been called “Zippy” in some Google presentations and the like.</p><h2 id="snappy-in-rocksdb"><a class="markdownIt-Anchor" href="#snappy-in-rocksdb"></a> Snappy in RocksDB</h2><ul><li><p>How to link: <a href="https://github.com/facebook/rocksdb/blob/main/build_tools/build_detect_platform">https://github.com/facebook/rocksdb/blob/main/build_tools/build_detect_platform</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! test $ROCKSDB_DISABLE_SNAPPY; then</span><br><span class="line">        # Test whether Snappy library is installed</span><br><span class="line">        <span class="meta"># http:<span class="comment">//code.google.com/p/snappy/</span></span></span><br><span class="line">        $CXX $PLATFORM_CXXFLAGS -x c++ - -o /dev/null <span class="number">2</span>&gt;/dev/null  &lt;&lt;EOF</span><br><span class="line">          <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;snappy.h&gt;</span></span></span><br><span class="line">          <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Where to use: <a href="https://github.com/facebook/rocksdb/blob/main/util/compression.h">https://github.com/facebook/rocksdb/blob/main/util/compression.h</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Snappy_Compress</span><span class="params">(<span class="type">const</span> CompressionInfo&amp; <span class="comment">/*info*/</span>, <span class="type">const</span> <span class="type">char</span>* input,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">size_t</span> length, ::std::string* output)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SNAPPY</span></span><br><span class="line">  output-&gt;<span class="built_in">resize</span>(snappy::<span class="built_in">MaxCompressedLength</span>(length));</span><br><span class="line">  <span class="type">size_t</span> outlen;</span><br><span class="line">  snappy::<span class="built_in">RawCompress</span>(input, length, &amp;(*output)[<span class="number">0</span>], &amp;outlen);</span><br><span class="line">  output-&gt;<span class="built_in">resize</span>(outlen);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)input;</span><br><span class="line">  (<span class="type">void</span>)length;</span><br><span class="line">  (<span class="type">void</span>)output;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> CacheAllocationPtr <span class="title">Snappy_Uncompress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* input, <span class="type">size_t</span> length, <span class="type">size_t</span>* uncompressed_size,</span></span></span><br><span class="line"><span class="params"><span class="function">    MemoryAllocator* allocator = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SNAPPY</span></span><br><span class="line">  <span class="type">size_t</span> uncompressed_length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!snappy::<span class="built_in">GetUncompressedLength</span>(input, length, &amp;uncompressed_length)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CacheAllocationPtr output = <span class="built_in">AllocateBlock</span>(uncompressed_length, allocator);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!snappy::<span class="built_in">RawUncompress</span>(input, length, output.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *uncompressed_size = uncompressed_length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)input;</span><br><span class="line">  (<span class="type">void</span>)length;</span><br><span class="line">  (<span class="type">void</span>)uncompressed_size;</span><br><span class="line">  (<span class="type">void</span>)allocator;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocksDB主要调用了两个接口<code>RawCompress</code>和<code>RawUncompress</code>。</p></li></ul><h2 id="snappy"><a class="markdownIt-Anchor" href="#snappy"></a> Snappy</h2><p>Source: <a href="https://github.com/google/snappy/">https://github.com/google/snappy/</a></p><p>首先看一下Format，然后分别从RawCompress和RawUncompress入手分析Snappy的压缩和解压过程。</p><h3 id="format"><a class="markdownIt-Anchor" href="#format"></a> Format</h3><p><code>format_description.txt</code>说明了一些编码格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">Snappy compressed format description</span><br><span class="line">Last revised: 2011-10-05</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is not a formal specification, but should suffice to explain most</span><br><span class="line">relevant parts of how the Snappy format works. It is originally based on</span><br><span class="line">text by Zeev Tarantov.</span><br><span class="line"></span><br><span class="line">Snappy is a LZ77-type compressor with a fixed, byte-oriented encoding.</span><br><span class="line">There is no entropy encoder backend nor framing layer -- the latter is</span><br><span class="line">assumed to be handled by other parts of the system.</span><br><span class="line"></span><br><span class="line">This document only describes the format, not how the Snappy compressor nor</span><br><span class="line">decompressor actually works. The correctness of the decompressor should not</span><br><span class="line">depend on implementation details of the compressor, and vice versa.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Preamble</span><br><span class="line"></span><br><span class="line">The stream starts with the uncompressed length (up to a maximum of 2^32 - 1),</span><br><span class="line">stored as a little-endian varint. Varints consist of a series of bytes,</span><br><span class="line">where the lower 7 bits are data and the upper bit is set iff there are</span><br><span class="line">more bytes to be read. In other words, an uncompressed length of 64 would</span><br><span class="line">be stored as 0x40, and an uncompressed length of 2097150 (0x1FFFFE)</span><br><span class="line">would be stored as 0xFE 0xFF 0x7F.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. The compressed stream itself</span><br><span class="line"></span><br><span class="line">There are two types of elements in a Snappy stream: Literals and</span><br><span class="line">copies (backreferences). There is no restriction on the order of elements,</span><br><span class="line">except that the stream naturally cannot start with a copy. (Having</span><br><span class="line">two literals in a row is never optimal from a compression point of</span><br><span class="line">view, but nevertheless fully permitted.) Each element starts with a tag byte,</span><br><span class="line">and the lower two bits of this tag byte signal what type of element will</span><br><span class="line">follow:</span><br><span class="line"></span><br><span class="line">  00: Literal</span><br><span class="line">  01: Copy with 1-byte offset</span><br><span class="line">  10: Copy with 2-byte offset</span><br><span class="line">  11: Copy with 4-byte offset</span><br><span class="line"></span><br><span class="line">The interpretation of the upper six bits are element-dependent.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.1. Literals (00)</span><br><span class="line"></span><br><span class="line">Literals are uncompressed data stored directly in the byte stream.</span><br><span class="line">The literal length is stored differently depending on the length</span><br><span class="line">of the literal:</span><br><span class="line"></span><br><span class="line"> - For literals up to and including 60 bytes in length, the upper</span><br><span class="line">   six bits of the tag byte contain (len-1). The literal follows</span><br><span class="line">   immediately thereafter in the bytestream.</span><br><span class="line"> - For longer literals, the (len-1) value is stored after the tag byte,</span><br><span class="line">   little-endian. The upper six bits of the tag byte describe how</span><br><span class="line">   many bytes are used for the length; 60, 61, 62 or 63 for</span><br><span class="line">   1-4 bytes, respectively. The literal itself follows after the</span><br><span class="line">   length.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2. Copies</span><br><span class="line"></span><br><span class="line">Copies are references back into previous decompressed data, telling</span><br><span class="line">the decompressor to reuse data it has previously decoded.</span><br><span class="line">They encode two values: The _offset_, saying how many bytes back</span><br><span class="line">from the current position to read, and the _length_, how many bytes</span><br><span class="line">to copy. Offsets of zero can be encoded, but are not legal;</span><br><span class="line">similarly, it is possible to encode backreferences that would</span><br><span class="line">go past the end of the block (offset &gt; current decompressed position),</span><br><span class="line">which is also nonsensical and thus not allowed.</span><br><span class="line"></span><br><span class="line">As in most LZ77-based compressors, the length can be larger than the offset,</span><br><span class="line">yielding a form of run-length encoding (RLE). For instance,</span><br><span class="line">&quot;xababab&quot; could be encoded as</span><br><span class="line"></span><br><span class="line">  &lt;literal: &quot;xab&quot;&gt; &lt;copy: offset=2 length=4&gt;</span><br><span class="line"></span><br><span class="line">Note that since the current Snappy compressor works in 32 kB</span><br><span class="line">blocks and does not do matching across blocks, it will never produce</span><br><span class="line">a bitstream with offsets larger than about 32768. However, the</span><br><span class="line">decompressor should not rely on this, as it may change in the future.</span><br><span class="line"></span><br><span class="line">There are several different kinds of copy elements, depending on</span><br><span class="line">the amount of bytes to be copied (length), and how far back the</span><br><span class="line">data to be copied is (offset).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2.1. Copy with 1-byte offset (01)</span><br><span class="line"></span><br><span class="line">These elements can encode lengths between [4..11] bytes and offsets</span><br><span class="line">between [0..2047] bytes. (len-4) occupies three bits and is stored</span><br><span class="line">in bits [2..4] of the tag byte. The offset occupies 11 bits, of which the</span><br><span class="line">upper three are stored in the upper three bits ([5..7]) of the tag byte,</span><br><span class="line">and the lower eight are stored in a byte following the tag byte.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2.2. Copy with 2-byte offset (10)</span><br><span class="line"></span><br><span class="line">These elements can encode lengths between [1..64] and offsets from</span><br><span class="line">[0..65535]. (len-1) occupies six bits and is stored in the upper</span><br><span class="line">six bits ([2..7]) of the tag byte. The offset is stored as a</span><br><span class="line">little-endian 16-bit integer in the two bytes following the tag byte.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2.3. Copy with 4-byte offset (11)</span><br><span class="line"></span><br><span class="line">These are like the copies with 2-byte offsets (see previous subsection),</span><br><span class="line">except that the offset is stored as a 32-bit integer instead of a</span><br><span class="line">16-bit integer (and thus will occupy four bytes).</span><br></pre></td></tr></table></figure><h3 id="compress"><a class="markdownIt-Anchor" href="#compress"></a> Compress</h3><ul><li><p><code>RawCompress</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RawCompress</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input, <span class="type">size_t</span> input_length, <span class="type">char</span>* compressed,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">size_t</span>* compressed_length)</span> </span>&#123;</span><br><span class="line">  <span class="function">ByteArraySource <span class="title">reader</span><span class="params">(input, input_length)</span></span>;</span><br><span class="line">  <span class="function">UncheckedByteArraySink <span class="title">writer</span><span class="params">(compressed)</span></span>;</span><br><span class="line">  <span class="built_in">Compress</span>(&amp;reader, &amp;writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute how many bytes were added</span></span><br><span class="line">  *compressed_length = (writer.<span class="built_in">CurrentDestination</span>() - compressed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据参数创建<code>reader</code>，<code>writer</code>，然后调用<code>Compress</code>进行压缩，最后计算<code>compressed_length</code>。</p><p>下面看一下<code>reader</code>和<code>writer</code>的结构。</p></li><li><p><code>ByteArraySource</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Source is an interface that yields a sequence of bytes</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Source</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Source</span>() &#123; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Source</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the number of bytes left to read from the source</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">Available</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Peek at the next flat region of the source.  Does not reposition</span></span><br><span class="line">  <span class="comment">// the source.  The returned region is empty iff Available()==0.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns a pointer to the beginning of the region and store its</span></span><br><span class="line">  <span class="comment">// length in *len.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The returned region is valid until the next call to Skip() or</span></span><br><span class="line">  <span class="comment">// until this object is destroyed, whichever occurs first.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The returned region may be larger than Available() (for example</span></span><br><span class="line">  <span class="comment">// if this ByteSource is a view on a substring of a larger source).</span></span><br><span class="line">  <span class="comment">// The caller is responsible for ensuring that it only reads the</span></span><br><span class="line">  <span class="comment">// Available() bytes.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">(<span class="type">size_t</span>* len)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip the next n bytes.  Invalidates any buffer returned by</span></span><br><span class="line">  <span class="comment">// a previous call to Peek().</span></span><br><span class="line">  <span class="comment">// REQUIRES: Available() &gt;= n</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Skip</span><span class="params">(<span class="type">size_t</span> n)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// No copying</span></span><br><span class="line">  <span class="built_in">Source</span>(<span class="type">const</span> Source&amp;);</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Source&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Source implementation that yields the contents of a flat array</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteArraySource</span> : <span class="keyword">public</span> Source &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ByteArraySource</span>(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">size_t</span> n) : <span class="built_in">ptr_</span>(p), <span class="built_in">left_</span>(n) &#123; &#125;</span><br><span class="line">  ~<span class="built_in">ByteArraySource</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Available</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">(<span class="type">size_t</span>* len)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Skip</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr_;</span><br><span class="line">  <span class="type">size_t</span> left_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Available</code>: 表示还有多少个字节剩余。</li><li><code>Peek</code>: 返回前面可以窥探到的字节流，并且返回长度。返回的buffer必须持续有效直到<code>Skip</code>。</li><li><code>Skip</code>: 告诉Source某个部分的字节流已经不需要被使用了，将这一部分跳过。</li></ul></li><li><p><code>UncheckedByteArraySink</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Sink is an interface that consumes a sequence of bytes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sink</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Sink</span>() &#123; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Sink</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append &quot;bytes[0,n-1]&quot; to this.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bytes, <span class="type">size_t</span> n)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns a writable buffer of the specified length for appending.</span></span><br><span class="line">  <span class="comment">// May return a pointer to the caller-owned scratch buffer which</span></span><br><span class="line">  <span class="comment">// must have at least the indicated length.  The returned buffer is</span></span><br><span class="line">  <span class="comment">// only valid until the next operation on this Sink.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// After writing at most &quot;length&quot; bytes, call Append() with the</span></span><br><span class="line">  <span class="comment">// pointer returned from this function and the number of bytes</span></span><br><span class="line">  <span class="comment">// written.  Many Append() implementations will avoid copying</span></span><br><span class="line">  <span class="comment">// bytes if this function returned an internal buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If a non-scratch buffer is returned, the caller may only pass a</span></span><br><span class="line">  <span class="comment">// prefix of it to Append().  That is, it is not correct to pass an</span></span><br><span class="line">  <span class="comment">// interior pointer of the returned array to Append().</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The default implementation always returns the scratch buffer.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">GetAppendBuffer</span><span class="params">(<span class="type">size_t</span> length, <span class="type">char</span>* scratch)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For higher performance, Sink implementations can provide custom</span></span><br><span class="line">  <span class="comment">// AppendAndTakeOwnership() and GetAppendBufferVariable() methods.</span></span><br><span class="line">  <span class="comment">// These methods can reduce the number of copies done during</span></span><br><span class="line">  <span class="comment">// compression/decompression.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append &quot;bytes[0,n-1] to the sink. Takes ownership of &quot;bytes&quot;</span></span><br><span class="line">  <span class="comment">// and calls the deleter function as (*deleter)(deleter_arg, bytes, n)</span></span><br><span class="line">  <span class="comment">// to free the buffer. deleter function must be non NULL.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The default implementation just calls Append and frees &quot;bytes&quot;.</span></span><br><span class="line">  <span class="comment">// Other implementations may avoid a copy while appending the buffer.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AppendAndTakeOwnership</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">char</span>* bytes, <span class="type">size_t</span> n, <span class="type">void</span> (*deleter)(<span class="type">void</span>*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">size_t</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">void</span> *deleter_arg)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns a writable buffer for appending and writes the buffer&#x27;s capacity to</span></span><br><span class="line">  <span class="comment">// *allocated_size. Guarantees *allocated_size &gt;= min_size.</span></span><br><span class="line">  <span class="comment">// May return a pointer to the caller-owned scratch buffer which must have</span></span><br><span class="line">  <span class="comment">// scratch_size &gt;= min_size.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The returned buffer is only valid until the next operation</span></span><br><span class="line">  <span class="comment">// on this ByteSink.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// After writing at most *allocated_size bytes, call Append() with the</span></span><br><span class="line">  <span class="comment">// pointer returned from this function and the number of bytes written.</span></span><br><span class="line">  <span class="comment">// Many Append() implementations will avoid copying bytes if this function</span></span><br><span class="line">  <span class="comment">// returned an internal buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If the sink implementation allocates or reallocates an internal buffer,</span></span><br><span class="line">  <span class="comment">// it should use the desired_size_hint if appropriate. If a caller cannot</span></span><br><span class="line">  <span class="comment">// provide a reasonable guess at the desired capacity, it should set</span></span><br><span class="line">  <span class="comment">// desired_size_hint = 0.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If a non-scratch buffer is returned, the caller may only pass</span></span><br><span class="line">  <span class="comment">// a prefix to it to Append(). That is, it is not correct to pass an</span></span><br><span class="line">  <span class="comment">// interior pointer to Append().</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The default implementation always returns the scratch buffer.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">GetAppendBufferVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> min_size, <span class="type">size_t</span> desired_size_hint, <span class="type">char</span>* scratch,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> scratch_size, <span class="type">size_t</span>* allocated_size)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// No copying</span></span><br><span class="line">  <span class="built_in">Sink</span>(<span class="type">const</span> Sink&amp;);</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Sink&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Sink implementation that writes to a flat array without any bound checks.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UncheckedByteArraySink</span> : <span class="keyword">public</span> Sink &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UncheckedByteArraySink</span><span class="params">(<span class="type">char</span>* dest)</span> : dest_(dest) &#123;</span> &#125;</span><br><span class="line">  ~<span class="built_in">UncheckedByteArraySink</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">GetAppendBuffer</span><span class="params">(<span class="type">size_t</span> len, <span class="type">char</span>* scratch)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">GetAppendBufferVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> min_size, <span class="type">size_t</span> desired_size_hint, <span class="type">char</span>* scratch,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> scratch_size, <span class="type">size_t</span>* allocated_size)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AppendAndTakeOwnership</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">char</span>* bytes, <span class="type">size_t</span> n, <span class="type">void</span> (*deleter)(<span class="type">void</span>*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">size_t</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">void</span> *deleter_arg)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current output pointer so that a caller can see how</span></span><br><span class="line">  <span class="comment">// many bytes were produced.</span></span><br><span class="line">  <span class="comment">// Note: this is not a Sink method.</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">CurrentDestination</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> dest_; &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* dest_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Append</code>: 将bytes[0,n-1]这个字节流写入。</li><li><code>getAppendBuffer</code>: 交出一块length的buffer，这块length的buffer的话必须一直有效直到<code>Append</code>被调用。当然我们也可以直接返回scratch(外围框架分配的内存)。</li></ul></li><li><p><code>Compress</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Compress</span><span class="params">(Source* reader, Sink* writer)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> N = reader-&gt;<span class="built_in">Available</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> uncompressed_size = N;</span><br><span class="line">  <span class="type">char</span> ulength[Varint::kMax32];</span><br><span class="line">  <span class="type">char</span>* p = Varint::<span class="built_in">Encode32</span>(ulength, N);</span><br><span class="line">  writer-&gt;<span class="built_in">Append</span>(ulength, p - ulength);</span><br><span class="line">  written += (p - ulength);</span><br><span class="line"></span><br><span class="line">  <span class="function">internal::WorkingMemory <span class="title">wmem</span><span class="params">(N)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Get next block to compress (without copying if possible)</span></span><br><span class="line">    <span class="type">size_t</span> fragment_size;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* fragment = reader-&gt;<span class="built_in">Peek</span>(&amp;fragment_size);</span><br><span class="line">    <span class="built_in">assert</span>(fragment_size != <span class="number">0</span>);  <span class="comment">// premature end of input</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> num_to_read = std::<span class="built_in">min</span>(N, kBlockSize);</span><br><span class="line">    <span class="type">size_t</span> bytes_read = fragment_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pending_advance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt;= num_to_read) &#123;</span><br><span class="line">      <span class="comment">// Buffer returned by reader is large enough</span></span><br><span class="line">      pending_advance = num_to_read;</span><br><span class="line">      fragment_size = num_to_read;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">char</span>* scratch = wmem.<span class="built_in">GetScratchInput</span>();</span><br><span class="line">      std::<span class="built_in">memcpy</span>(scratch, fragment, bytes_read);</span><br><span class="line">      reader-&gt;<span class="built_in">Skip</span>(bytes_read);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (bytes_read &lt; num_to_read) &#123;</span><br><span class="line">        fragment = reader-&gt;<span class="built_in">Peek</span>(&amp;fragment_size);</span><br><span class="line">        <span class="type">size_t</span> n = std::<span class="built_in">min</span>&lt;<span class="type">size_t</span>&gt;(fragment_size, num_to_read - bytes_read);</span><br><span class="line">        std::<span class="built_in">memcpy</span>(scratch + bytes_read, fragment, n);</span><br><span class="line">        bytes_read += n;</span><br><span class="line">        reader-&gt;<span class="built_in">Skip</span>(n);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">assert</span>(bytes_read == num_to_read);</span><br><span class="line">      fragment = scratch;</span><br><span class="line">      fragment_size = num_to_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(fragment_size == num_to_read);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get encoding table for compression</span></span><br><span class="line">    <span class="type">int</span> table_size;</span><br><span class="line">    <span class="type">uint16_t</span>* table = wmem.<span class="built_in">GetHashTable</span>(num_to_read, &amp;table_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compress input_fragment and append to dest</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_output = <span class="built_in">MaxCompressedLength</span>(num_to_read);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need a scratch buffer for the output, in case the byte sink doesn&#x27;t</span></span><br><span class="line">    <span class="comment">// have room for us directly.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since we encode kBlockSize regions followed by a region</span></span><br><span class="line">    <span class="comment">// which is &lt;= kBlockSize in length, a previously allocated</span></span><br><span class="line">    <span class="comment">// scratch_output[] region is big enough for this iteration.</span></span><br><span class="line">    <span class="type">char</span>* dest = writer-&gt;<span class="built_in">GetAppendBuffer</span>(max_output, wmem.<span class="built_in">GetScratchOutput</span>());</span><br><span class="line">    <span class="type">char</span>* end = internal::<span class="built_in">CompressFragment</span>(fragment, fragment_size, dest, table,</span><br><span class="line">                                           table_size);</span><br><span class="line">    writer-&gt;<span class="built_in">Append</span>(dest, end - dest);</span><br><span class="line">    written += (end - dest);</span><br><span class="line"></span><br><span class="line">    N -= num_to_read;</span><br><span class="line">    reader-&gt;<span class="built_in">Skip</span>(pending_advance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Report</span>(<span class="string">&quot;snappy_compress&quot;</span>, written, uncompressed_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>头部是原始串长度，使用变长整数方式<code>Encode</code>来编码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Varint::Encode32</span><span class="params">(<span class="type">char</span>* sptr, <span class="type">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="type">uint8_t</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(sptr);</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v &gt;&gt; <span class="number">7</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((v &gt;&gt; <span class="number">7</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v &gt;&gt; <span class="number">14</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((v &gt;&gt; <span class="number">7</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((v &gt;&gt; <span class="number">14</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v &gt;&gt; <span class="number">21</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((v&gt;&gt;<span class="number">7</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((v&gt;&gt;<span class="number">14</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((v&gt;&gt;<span class="number">21</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v &gt;&gt; <span class="number">28</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取<code>fragment</code>和<code>fragmentsize</code>。</p></li><li><p>调用<code>CompressFragment</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flat array compression that does not emit the &quot;uncompressed length&quot;</span></span><br><span class="line"><span class="comment">// prefix. Compresses &quot;input&quot; string to the &quot;*op&quot; buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;input&quot; is at most &quot;kBlockSize&quot; bytes long.</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;op&quot; points to an array of memory that is at least</span></span><br><span class="line"><span class="comment">// &quot;MaxCompressedLength(input.size())&quot; in size.</span></span><br><span class="line"><span class="comment">// REQUIRES: All elements in &quot;table[0..table_size-1]&quot; are initialized to zero.</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;table_size&quot; is a power of two</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns an &quot;end&quot; pointer into &quot;op&quot; buffer.</span></span><br><span class="line"><span class="comment">// &quot;end - op&quot; is the compressed size of &quot;input&quot;.</span></span><br><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">CompressFragment</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input, <span class="type">size_t</span> input_size, <span class="type">char</span>* op,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">uint16_t</span>* table, <span class="type">const</span> <span class="type">int</span> table_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// &quot;ip&quot; is the input pointer, and &quot;op&quot; is the output pointer.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ip = input;</span><br><span class="line">  <span class="built_in">assert</span>(input_size &lt;= kBlockSize);</span><br><span class="line">  <span class="built_in">assert</span>((table_size &amp; (table_size - <span class="number">1</span>)) == <span class="number">0</span>);  <span class="comment">// table must be power of two</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> mask = table_size - <span class="number">1</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ip_end = input + input_size;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* base_ip = ip;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> kInputMarginBytes = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_TRUE</span>(input_size &gt;= kInputMarginBytes)) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip_limit = input + input_size - kInputMarginBytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> preload = LittleEndian::<span class="built_in">Load32</span>(ip + <span class="number">1</span>);;) &#123;</span><br><span class="line">      <span class="comment">// Bytes in [next_emit, ip) will be emitted as literal bytes.  Or</span></span><br><span class="line">      <span class="comment">// [next_emit, ip_end) after the main loop.</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* next_emit = ip++;</span><br><span class="line">      <span class="type">uint64_t</span> data = LittleEndian::<span class="built_in">Load64</span>(ip);</span><br><span class="line">      <span class="comment">// The body of this loop calls EmitLiteral once and then EmitCopy one or</span></span><br><span class="line">      <span class="comment">// more times.  (The exception is that when we&#x27;re close to exhausting</span></span><br><span class="line">      <span class="comment">// the input we goto emit_remainder.)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// In the first iteration of this loop we&#x27;re just starting, so</span></span><br><span class="line">      <span class="comment">// there&#x27;s nothing to copy, so calling EmitLiteral once is</span></span><br><span class="line">      <span class="comment">// necessary.  And we only start a new iteration when the</span></span><br><span class="line">      <span class="comment">// current iteration has determined that a call to EmitLiteral will</span></span><br><span class="line">      <span class="comment">// precede the next call to EmitCopy (if any).</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Step 1: Scan forward in the input looking for a 4-byte-long match.</span></span><br><span class="line">      <span class="comment">// If we get close to exhausting the input then goto emit_remainder.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Heuristic match skipping: If 32 bytes are scanned with no matches</span></span><br><span class="line">      <span class="comment">// found, start looking only at every other byte. If 32 more bytes are</span></span><br><span class="line">      <span class="comment">// scanned (or skipped), look at every third byte, etc.. When a match is</span></span><br><span class="line">      <span class="comment">// found, immediately go back to looking at every byte. This is a small</span></span><br><span class="line">      <span class="comment">// loss (~5% performance, ~0.1% density) for compressible data due to more</span></span><br><span class="line">      <span class="comment">// bookkeeping, but for non-compressible data (such as JPEG) it&#x27;s a huge</span></span><br><span class="line">      <span class="comment">// win since the compressor quickly &quot;realizes&quot; the data is incompressible</span></span><br><span class="line">      <span class="comment">// and doesn&#x27;t bother looking for matches everywhere.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The &quot;skip&quot; variable keeps track of how many bytes there are since the</span></span><br><span class="line">      <span class="comment">// last match; dividing it by 32 (ie. right-shifting by five) gives the</span></span><br><span class="line">      <span class="comment">// number of bytes to move ahead for each iteration.</span></span><br><span class="line">      <span class="type">uint32_t</span> skip = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* candidate;</span><br><span class="line">      <span class="keyword">if</span> (ip_limit - ip &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> delta = ip - base_ip;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">4</span> * j + k;</span><br><span class="line">            <span class="comment">// These for-loops are meant to be unrolled. So we can freely</span></span><br><span class="line">            <span class="comment">// special case the first iteration to use the value already</span></span><br><span class="line">            <span class="comment">// loaded in preload.</span></span><br><span class="line">            <span class="type">uint32_t</span> dword = i == <span class="number">0</span> ? preload : <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data);</span><br><span class="line">            <span class="built_in">assert</span>(dword == LittleEndian::<span class="built_in">Load32</span>(ip + i));</span><br><span class="line">            <span class="type">uint32_t</span> hash = <span class="built_in">HashBytes</span>(dword, mask);</span><br><span class="line">            candidate = base_ip + table[hash];</span><br><span class="line">            <span class="built_in">assert</span>(candidate &gt;= base_ip);</span><br><span class="line">            <span class="built_in">assert</span>(candidate &lt; ip + i);</span><br><span class="line">            table[hash] = delta + i;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(LittleEndian::<span class="built_in">Load32</span>(candidate) == dword)) &#123;</span><br><span class="line">              *op = LITERAL | (i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">              <span class="built_in">UnalignedCopy128</span>(next_emit, op + <span class="number">1</span>);</span><br><span class="line">              ip += i;</span><br><span class="line">              op = op + i + <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">goto</span> emit_match;</span><br><span class="line">            &#125;</span><br><span class="line">            data &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          data = LittleEndian::<span class="built_in">Load64</span>(ip + <span class="number">4</span> * j + <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ip += <span class="number">16</span>;</span><br><span class="line">        skip += <span class="number">16</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(ip));</span><br><span class="line">        <span class="type">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        <span class="type">uint32_t</span> bytes_between_hash_lookups = skip &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        skip += bytes_between_hash_lookups;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* next_ip = ip + bytes_between_hash_lookups;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(next_ip &gt; ip_limit)) &#123;</span><br><span class="line">          ip = next_emit;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        <span class="built_in">assert</span>(candidate &gt;= base_ip);</span><br><span class="line">        <span class="built_in">assert</span>(candidate &lt; ip);</span><br><span class="line"></span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data) ==</span><br><span class="line">                                LittleEndian::<span class="built_in">Load32</span>(candidate))) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data = LittleEndian::<span class="built_in">Load32</span>(next_ip);</span><br><span class="line">        ip = next_ip;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 2: A 4-byte match has been found.  We&#x27;ll later see if more</span></span><br><span class="line">      <span class="comment">// than 4 bytes match.  But, prior to the match, input</span></span><br><span class="line">      <span class="comment">// bytes [next_emit, ip) are unmatched.  Emit them as &quot;literal bytes.&quot;</span></span><br><span class="line">      <span class="built_in">assert</span>(next_emit + <span class="number">16</span> &lt;= ip_end);</span><br><span class="line">      op = <span class="built_in">EmitLiteral</span>&lt;<span class="comment">/*allow_fast_path=*/</span><span class="literal">true</span>&gt;(op, next_emit, ip - next_emit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 3: Call EmitCopy, and then see if another EmitCopy could</span></span><br><span class="line">      <span class="comment">// be our next move.  Repeat until we find no match for the</span></span><br><span class="line">      <span class="comment">// input immediately after what was consumed by the last EmitCopy call.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// If we exit this loop normally then we need to call EmitLiteral next,</span></span><br><span class="line">      <span class="comment">// though we don&#x27;t yet know how big the literal will be.  We handle that</span></span><br><span class="line">      <span class="comment">// by proceeding to the next iteration of the main loop.  We also can exit</span></span><br><span class="line">      <span class="comment">// this loop via goto if we get close to exhausting the input.</span></span><br><span class="line">    emit_match:</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// We have a 4-byte match at ip, and no need to emit any</span></span><br><span class="line">        <span class="comment">// &quot;literal bytes&quot; prior to ip.</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* base = ip;</span><br><span class="line">        std::pair&lt;<span class="type">size_t</span>, <span class="type">bool</span>&gt; p =</span><br><span class="line">            <span class="built_in">FindMatchLength</span>(candidate + <span class="number">4</span>, ip + <span class="number">4</span>, ip_end, &amp;data);</span><br><span class="line">        <span class="type">size_t</span> matched = <span class="number">4</span> + p.first;</span><br><span class="line">        ip += matched;</span><br><span class="line">        <span class="type">size_t</span> offset = base - candidate;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span> == <span class="built_in">memcmp</span>(base, candidate, matched));</span><br><span class="line">        <span class="keyword">if</span> (p.second) &#123;</span><br><span class="line">          op = <span class="built_in">EmitCopy</span>&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">true</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          op = <span class="built_in">EmitCopy</span>&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">false</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(ip &gt;= ip_limit)) &#123;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Expect 5 bytes to match</span></span><br><span class="line">        <span class="built_in">assert</span>((data &amp; <span class="number">0xFFFFFFFFFF</span>) ==</span><br><span class="line">               (LittleEndian::<span class="built_in">Load64</span>(ip) &amp; <span class="number">0xFFFFFFFFFF</span>));</span><br><span class="line">        <span class="comment">// We are now looking for a 4-byte match again.  We read</span></span><br><span class="line">        <span class="comment">// table[Hash(ip, shift)] for that.  To improve compression,</span></span><br><span class="line">        <span class="comment">// we also update table[Hash(ip - 1, mask)] and table[Hash(ip, mask)].</span></span><br><span class="line">        table[<span class="built_in">HashBytes</span>(LittleEndian::<span class="built_in">Load32</span>(ip - <span class="number">1</span>), mask)] = ip - base_ip - <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="comment">// Measurements on the benchmarks have shown the following probabilities</span></span><br><span class="line">        <span class="comment">// for the loop to exit (ie. avg. number of iterations is reciprocal).</span></span><br><span class="line">        <span class="comment">// BM_Flat/6  txt1    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/7  txt2    p = 0.35</span></span><br><span class="line">        <span class="comment">// BM_Flat/8  txt3    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/9  txt3    p = 0.34-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/10 pb      p = 0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/11 gaviota p = 0.1</span></span><br><span class="line">        <span class="comment">// BM_Flat/12 cp      p = 0.5</span></span><br><span class="line">        <span class="comment">// BM_Flat/13 c       p = 0.3</span></span><br><span class="line">      &#125; <span class="keyword">while</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(candidate));</span><br><span class="line">      <span class="comment">// Because the least significant 5 bytes matched, we can utilize data</span></span><br><span class="line">      <span class="comment">// for the next iteration.</span></span><br><span class="line">      preload = data &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">emit_remainder:</span><br><span class="line">  <span class="comment">// Emit the remaining bytes as a literal</span></span><br><span class="line">  <span class="keyword">if</span> (ip &lt; ip_end) &#123;</span><br><span class="line">    op = <span class="built_in">EmitLiteral</span>&lt;<span class="comment">/*allow_fast_path=*/</span><span class="literal">false</span>&gt;(op, ip, ip_end - ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// end namespace internal</span></span><br></pre></td></tr></table></figure><ul><li><p>核心代码是<code>for (uint32_t preload = LittleEndian::Load32(ip + 1);;)</code>控制的大循环。</p></li><li><p>j和k控制两层for循环，指针每次向后移动1个byte（即内层循环k每次加1，data右移8位），对于当前指针指向的4bytes内容dword，将其放入hashtable中。</p></li><li><p>如果在循环中出现了<code>candidata==dword</code>的情况，则将从next_emit开始的16个bytes作为literal写入op，然后<code>goto emit_match</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(LittleEndian::<span class="built_in">Load32</span>(candidate) == dword)) &#123;</span><br><span class="line">              *op = LITERAL | (i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">              <span class="built_in">UnalignedCopy128</span>(next_emit, op + <span class="number">1</span>);</span><br><span class="line">              ip += i;</span><br><span class="line">              op = op + i + <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">goto</span> emit_match;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li><li><p>否则，进入下面的while循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(ip));</span><br><span class="line">        <span class="type">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        <span class="type">uint32_t</span> bytes_between_hash_lookups = skip &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        skip += bytes_between_hash_lookups;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* next_ip = ip + bytes_between_hash_lookups;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(next_ip &gt; ip_limit)) &#123;</span><br><span class="line">          ip = next_emit;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        <span class="built_in">assert</span>(candidate &gt;= base_ip);</span><br><span class="line">        <span class="built_in">assert</span>(candidate &lt; ip);</span><br><span class="line"></span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data) ==</span><br><span class="line">                                LittleEndian::<span class="built_in">Load32</span>(candidate))) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data = LittleEndian::<span class="built_in">Load32</span>(next_ip);</span><br><span class="line">        ip = next_ip;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这就是注释中提到的启发式搜索，skip右移5位作为检查标准，不超过32bytes逐字节检查，超过32bytes不超过64bytes每两个字节检查一次…以此类推，bytes_between_hash_lookups的含义就是每多少个字节检查一次。最终会出现两种情况，一种是next_ip大于ip_limit，直接将其作为literal。另一种是data等于candidate，break跳出循环。</p></li><li><p>while循环结束后，我们得到了4bytes的match，先将match对应的literal写入op。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(next_emit + <span class="number">16</span> &lt;= ip_end);</span><br><span class="line">op = <span class="built_in">EmitLiteral</span>&lt;<span class="comment">/*allow_fast_path=*/</span><span class="literal">true</span>&gt;(op, next_emit, ip - next_emit);</span><br></pre></td></tr></table></figure></li><li><p>然后进入<code>emit_match</code>这个label标记的程序段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">emit_match:</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// We have a 4-byte match at ip, and no need to emit any</span></span><br><span class="line">        <span class="comment">// &quot;literal bytes&quot; prior to ip.</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* base = ip;</span><br><span class="line">        std::pair&lt;<span class="type">size_t</span>, <span class="type">bool</span>&gt; p =</span><br><span class="line">            <span class="built_in">FindMatchLength</span>(candidate + <span class="number">4</span>, ip + <span class="number">4</span>, ip_end, &amp;data);</span><br><span class="line">        <span class="type">size_t</span> matched = <span class="number">4</span> + p.first;</span><br><span class="line">        ip += matched;</span><br><span class="line">        <span class="type">size_t</span> offset = base - candidate;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span> == <span class="built_in">memcmp</span>(base, candidate, matched));</span><br><span class="line">        <span class="keyword">if</span> (p.second) &#123;</span><br><span class="line">          op = <span class="built_in">EmitCopy</span>&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">true</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          op = <span class="built_in">EmitCopy</span>&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">false</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(ip &gt;= ip_limit)) &#123;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Expect 5 bytes to match</span></span><br><span class="line">        <span class="built_in">assert</span>((data &amp; <span class="number">0xFFFFFFFFFF</span>) ==</span><br><span class="line">               (LittleEndian::<span class="built_in">Load64</span>(ip) &amp; <span class="number">0xFFFFFFFFFF</span>));</span><br><span class="line">        <span class="comment">// We are now looking for a 4-byte match again.  We read</span></span><br><span class="line">        <span class="comment">// table[Hash(ip, shift)] for that.  To improve compression,</span></span><br><span class="line">        <span class="comment">// we also update table[Hash(ip - 1, mask)] and table[Hash(ip, mask)].</span></span><br><span class="line">        table[<span class="built_in">HashBytes</span>(LittleEndian::<span class="built_in">Load32</span>(ip - <span class="number">1</span>), mask)] = ip - base_ip - <span class="number">1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="comment">// Measurements on the benchmarks have shown the following probabilities</span></span><br><span class="line">        <span class="comment">// for the loop to exit (ie. avg. number of iterations is reciprocal).</span></span><br><span class="line">        <span class="comment">// BM_Flat/6  txt1    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/7  txt2    p = 0.35</span></span><br><span class="line">        <span class="comment">// BM_Flat/8  txt3    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/9  txt3    p = 0.34-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/10 pb      p = 0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/11 gaviota p = 0.1</span></span><br><span class="line">        <span class="comment">// BM_Flat/12 cp      p = 0.5</span></span><br><span class="line">        <span class="comment">// BM_Flat/13 c       p = 0.3</span></span><br><span class="line">      &#125; <span class="keyword">while</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(candidate));</span><br><span class="line">      <span class="comment">// Because the least significant 5 bytes matched, we can utilize data</span></span><br><span class="line">      <span class="comment">// for the next iteration.</span></span><br><span class="line">      preload = data &gt;&gt; <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><code>FindMatchLength</code>求出最大的match长度，将offset和matched写入op，最后更新hashtable。如果data和candidate不相等，退出循环。</p></li></ul></li><li><p><code>CompressFragment</code>结束后，回到<code>Compress</code>中，最后通过<code>writer-&gt;Append(dest, end - dest)</code>写入writer。</p></li></ul></li></ul><h3 id="uncompress"><a class="markdownIt-Anchor" href="#uncompress"></a> Uncompress</h3><ul><li><p><code>RawUncompress</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RawUncompress</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* compressed, <span class="type">size_t</span> compressed_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">char</span>* uncompressed)</span> </span>&#123;</span><br><span class="line">  <span class="function">ByteArraySource <span class="title">reader</span><span class="params">(compressed, compressed_length)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RawUncompress</span>(&amp;reader, uncompressed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造ByteArraySource，将reader作为参数调用重载的<code>RawUncompress</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RawUncompress</span><span class="params">(Source* compressed, <span class="type">char</span>* uncompressed)</span> </span>&#123;</span><br><span class="line">  <span class="function">SnappyArrayWriter <span class="title">output</span><span class="params">(uncompressed)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InternalUncompress</span>(compressed, &amp;output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造SnappyArrayWriter，将output作为参数调用<code>InternalUncompress</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Writer&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">InternalUncompress</span><span class="params">(Source* r, Writer* writer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Read the uncompressed length from the front of the compressed input</span></span><br><span class="line">  <span class="function">SnappyDecompressor <span class="title">decompressor</span><span class="params">(r)</span></span>;</span><br><span class="line">  <span class="type">uint32_t</span> uncompressed_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!decompressor.<span class="built_in">ReadUncompressedLength</span>(&amp;uncompressed_len)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InternalUncompressAllTags</span>(&amp;decompressor, writer, r-&gt;<span class="built_in">Available</span>(),</span><br><span class="line">                                   uncompressed_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过source构造decompressor，获取uncompressed_len，调用<code>InternalUncompressAllTags</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Writer&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">InternalUncompressAllTags</span><span class="params">(SnappyDecompressor* decompressor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Writer* writer, <span class="type">uint32_t</span> compressed_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span> uncompressed_len)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Report</span>(<span class="string">&quot;snappy_uncompress&quot;</span>, compressed_len, uncompressed_len);</span><br><span class="line"></span><br><span class="line">  writer-&gt;<span class="built_in">SetExpectedLength</span>(uncompressed_len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process the entire input</span></span><br><span class="line">  decompressor-&gt;<span class="built_in">DecompressAllTags</span>(writer);</span><br><span class="line">  writer-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">  <span class="keyword">return</span> (decompressor-&gt;<span class="built_in">eof</span>() &amp;&amp; writer-&gt;<span class="built_in">CheckLength</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在writer中设置uncompressed_len，通过decompressor的<code>DecompressAllTags(writer)</code>进行解压。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">  <span class="title">DecompressAllTags</span><span class="params">(Writer* writer)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = ip_;</span><br><span class="line">    <span class="built_in">ResetLimit</span>(ip);</span><br><span class="line">    <span class="keyword">auto</span> op = writer-&gt;<span class="built_in">GetOutputPtr</span>();</span><br><span class="line">    <span class="comment">// We could have put this refill fragment only at the beginning of the loop.</span></span><br><span class="line">    <span class="comment">// However, duplicating it at the end of each branch gives the compiler more</span></span><br><span class="line">    <span class="comment">// scope to optimize the &lt;ip_limit_ - ip&gt; expression based on the local</span></span><br><span class="line">    <span class="comment">// context, which overall increases speed.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAYBE_REFILL()                                      \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (SNAPPY_PREDICT_FALSE(ip &gt;= ip_limit_min_maxtaglen_)) &#123; \</span></span><br><span class="line"><span class="meta">    ip_ = ip;                                               \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (SNAPPY_PREDICT_FALSE(!RefillTag())) goto exit;       \</span></span><br><span class="line"><span class="meta">    ip = ip_;                                               \</span></span><br><span class="line"><span class="meta">    ResetLimit(ip);                                         \</span></span><br><span class="line"><span class="meta">  &#125;                                                         \</span></span><br><span class="line"><span class="meta">  preload = static_cast<span class="string">&lt;uint8_t&gt;</span>(*ip)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At the start of the for loop below the least significant byte of preload</span></span><br><span class="line">    <span class="comment">// contains the tag.</span></span><br><span class="line">    <span class="type">uint32_t</span> preload;</span><br><span class="line">    <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">ptrdiff_t</span> op_limit_min_slop;</span><br><span class="line">        <span class="keyword">auto</span> op_base = writer-&gt;<span class="built_in">GetBase</span>(&amp;op_limit_min_slop);</span><br><span class="line">        <span class="keyword">if</span> (op_base) &#123;</span><br><span class="line">          <span class="keyword">auto</span> res =</span><br><span class="line">              <span class="built_in">DecompressBranchless</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(ip),</span><br><span class="line">                                   <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(ip_limit_),</span><br><span class="line">                                   op - op_base, op_base, op_limit_min_slop);</span><br><span class="line">          ip = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(res.first);</span><br><span class="line">          op = op_base + res.second;</span><br><span class="line">          <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint8_t</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(preload);</span><br><span class="line">      ip++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ratio of iterations that have LITERAL vs non-LITERAL for different</span></span><br><span class="line">      <span class="comment">// inputs.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// input          LITERAL  NON_LITERAL</span></span><br><span class="line">      <span class="comment">// -----------------------------------</span></span><br><span class="line">      <span class="comment">// html|html4|cp   23%        77%</span></span><br><span class="line">      <span class="comment">// urls            36%        64%</span></span><br><span class="line">      <span class="comment">// jpg             47%        53%</span></span><br><span class="line">      <span class="comment">// pdf             19%        81%</span></span><br><span class="line">      <span class="comment">// txt[1-4]        25%        75%</span></span><br><span class="line">      <span class="comment">// pb              24%        76%</span></span><br><span class="line">      <span class="comment">// bin             24%        76%</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>((c &amp; <span class="number">0x3</span>) == LITERAL)) &#123;</span><br><span class="line">        <span class="type">size_t</span> literal_length = (c &gt;&gt; <span class="number">2</span>) + <span class="number">1u</span>;</span><br><span class="line">        <span class="keyword">if</span> (writer-&gt;<span class="built_in">TryFastAppend</span>(ip, ip_limit_ - ip, literal_length, &amp;op)) &#123;</span><br><span class="line">          <span class="built_in">assert</span>(literal_length &lt; <span class="number">61</span>);</span><br><span class="line">          ip += literal_length;</span><br><span class="line">          <span class="comment">// <span class="doctag">NOTE:</span> There is no MAYBE_REFILL() here, as TryFastAppend()</span></span><br><span class="line">          <span class="comment">// will not return true unless there&#x27;s already at least five spare</span></span><br><span class="line">          <span class="comment">// bytes in addition to the literal.</span></span><br><span class="line">          preload = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(*ip);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(literal_length &gt;= <span class="number">61</span>)) &#123;</span><br><span class="line">          <span class="comment">// Long literal.</span></span><br><span class="line">          <span class="type">const</span> <span class="type">size_t</span> literal_length_length = literal_length - <span class="number">60</span>;</span><br><span class="line">          literal_length =</span><br><span class="line">              <span class="built_in">ExtractLowBytes</span>(LittleEndian::<span class="built_in">Load32</span>(ip), literal_length_length) +</span><br><span class="line">              <span class="number">1</span>;</span><br><span class="line">          ip += literal_length_length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> avail = ip_limit_ - ip;</span><br><span class="line">        <span class="keyword">while</span> (avail &lt; literal_length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Append</span>(ip, avail, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line">          literal_length -= avail;</span><br><span class="line">          reader_-&gt;<span class="built_in">Skip</span>(peeked_);</span><br><span class="line">          <span class="type">size_t</span> n;</span><br><span class="line">          ip = reader_-&gt;<span class="built_in">Peek</span>(&amp;n);</span><br><span class="line">          avail = n;</span><br><span class="line">          peeked_ = avail;</span><br><span class="line">          <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">goto</span> exit;</span><br><span class="line">          ip_limit_ = ip + avail;</span><br><span class="line">          <span class="built_in">ResetLimit</span>(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Append</span>(ip, literal_length, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line">        ip += literal_length;</span><br><span class="line">        <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>((c &amp; <span class="number">3</span>) == COPY_4_BYTE_OFFSET)) &#123;</span><br><span class="line">          <span class="type">const</span> <span class="type">size_t</span> copy_offset = LittleEndian::<span class="built_in">Load32</span>(ip);</span><br><span class="line">          <span class="type">const</span> <span class="type">size_t</span> length = (c &gt;&gt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">          ip += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!writer-&gt;<span class="built_in">AppendFromSelf</span>(copy_offset, length, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">const</span> <span class="type">ptrdiff_t</span> entry = kLengthMinusOffset[c];</span><br><span class="line">          preload = LittleEndian::<span class="built_in">Load32</span>(ip);</span><br><span class="line">          <span class="type">const</span> <span class="type">uint32_t</span> trailer = <span class="built_in">ExtractLowBytes</span>(preload, c &amp; <span class="number">3</span>);</span><br><span class="line">          <span class="type">const</span> <span class="type">uint32_t</span> length = entry &amp; <span class="number">0xff</span>;</span><br><span class="line">          <span class="built_in">assert</span>(length &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// copy_offset/256 is encoded in bits 8..10.  By just fetching</span></span><br><span class="line">          <span class="comment">// those bits, we get copy_offset (since the bit-field starts at</span></span><br><span class="line">          <span class="comment">// bit 8).</span></span><br><span class="line">          <span class="type">const</span> <span class="type">uint32_t</span> copy_offset = trailer - entry + length;</span><br><span class="line">          <span class="keyword">if</span> (!writer-&gt;<span class="built_in">AppendFromSelf</span>(copy_offset, length, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line"></span><br><span class="line">          ip += (c &amp; <span class="number">3</span>);</span><br><span class="line">          <span class="comment">// By using the result of the previous load we reduce the critical</span></span><br><span class="line">          <span class="comment">// dependency chain of ip to 4 cycles.</span></span><br><span class="line">          preload &gt;&gt;= (c &amp; <span class="number">3</span>) * <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">if</span> (ip &lt; ip_limit_min_maxtaglen_) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> MAYBE_REFILL</span></span><br><span class="line">  exit:</span><br><span class="line">    writer-&gt;<span class="built_in">SetOutputPtr</span>(op);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="pseudocode"><a class="markdownIt-Anchor" href="#pseudocode"></a> Pseudocode</h3><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/Embedded/202110202113481.png" alt="" /></p><h3 id="performance"><a class="markdownIt-Anchor" href="#performance"></a> Performance</h3><p>Snappy is intended to be fast. On a single core of a Core i7 processor in 64-bit mode, it compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more. (These numbers are for the slowest inputs in our benchmark suite; others are much faster.) In our tests, Snappy usually is faster than algorithms in the same class (e.g. LZO, LZF, QuickLZ, etc.) while achieving comparable compression ratios.</p><p>Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and other already-compressed data. Similar numbers for zlib in its fastest mode are 2.6-2.8x, 3-7x and 1.0x, respectively. More sophisticated algorithms are capable of achieving yet higher compression rates, although usually at the expense of speed. Of course, compression ratio will vary significantly with the input.</p><p>Although Snappy should be fairly portable, it is primarily optimized for 64-bit x86-compatible processors, and may run slower in other environments.<br />In particular:</p><ul><li>Snappy uses 64-bit operations in several places to process more data at once than would otherwise be possible.</li><li>Snappy assumes unaligned 32 and 64-bit loads and stores are cheap. On some platforms, these must be emulated with single-byte loads and stores, which is much slower.</li><li>Snappy assumes little-endian throughout, and needs to byte-swap data in several places if running on a big-endian platform.</li></ul><p>Experience has shown that even heavily tuned code can be improved. Performance optimizations, whether for 64-bit x86 or other platforms, are of course most welcome; see “Contact”, below.</p><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://github.com/google/snappy">https://github.com/google/snappy</a></li><li><a href="https://dirtysalt.github.io/html/snappy.html">https://dirtysalt.github.io/html/snappy.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;How to analyse the source codes of snappy ? In this blog, the pseudocode of compression and uncompression using snappy is given, which is aimed to help you understand snappy algorithm.&lt;/p&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    <category term="KV store" scheme="https://tongyiheng.top/categories/Embedded/KV-store/"/>
    
    
    <category term="RocksDB" scheme="https://tongyiheng.top/tags/RocksDB/"/>
    
    <category term="cpp" scheme="https://tongyiheng.top/tags/cpp/"/>
    
    <category term="compression" scheme="https://tongyiheng.top/tags/compression/"/>
    
  </entry>
  
  <entry>
    <title>RocksDB和db_bench安装与配置</title>
    <link href="https://tongyiheng.top/2021/10/14/Embedded/db-bench/"/>
    <id>https://tongyiheng.top/2021/10/14/Embedded/db-bench/</id>
    <published>2021-10-14T10:47:59.000Z</published>
    <updated>2021-10-20T13:00:48.142Z</updated>
    
    <content type="html"><![CDATA[<p>Start from a new Ubuntu OS.</p><span id="more"></span><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p>After remaking N times, I made this blog finally.</p><p>Let’s start from <strong>a new Ubuntu</strong> now.</p><h2 id="steps"><a class="markdownIt-Anchor" href="#steps"></a> Steps</h2><h3 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1</h3><p>首先安装gcc、g++等工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><p>然后安装一些必要的库，用于RocksDB的Compression。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsnappy-dev zlib1g-dev libbz2-dev liblz4-dev libzstd-dev libgflags-dev</span><br></pre></td></tr></table></figure><h3 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h3><p>下载RocksDB源码并解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/facebook/rocksdb/archive/v6.25.1.zip</span><br><span class="line">unzip rocksdb-6.25.1.zip</span><br></pre></td></tr></table></figure><p>Tips:</p><ul><li>版本号可自己选择，下面涉及到版本号的命令需要对应更改。e.g. v6.6.4 (2020-01-31)</li><li>此过程需要的时间可能较长，可以通过其他方法下载zip压缩包，拷贝至Ubuntu系统。<strong>(Recommended)</strong></li><li>如果压缩包名字略有不同，自行更改。</li></ul><h3 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> Step 3</h3><p>编译生成动态链接库和静态链接库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rocksdb-6.25.1</span><br><span class="line">make shared_lib &amp;&amp; sudo make install-shared</span><br><span class="line">make static_lib &amp;&amp; sudo make install-static</span><br></pre></td></tr></table></figure><p>Tips:</p><ul><li><p>如果先生成静态链接库再生成动态链接库，在生成动态链接库的时候会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make static_lib &amp;&amp; sudo make install-static</span><br><span class="line">make shared_lib &amp;&amp; sudo make install-shared</span><br></pre></td></tr></table></figure><p>解决办法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make shared_lib</span><br><span class="line">make static_lib</span><br></pre></td></tr></table></figure></li><li><p>此过程需要的时间较长（约10min）。</p></li></ul><p>最后执行<code>sudo make install</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="step-4"><a class="markdownIt-Anchor" href="#step-4"></a> Step 4</h3><p>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#echo &quot;/usr/local/lib&quot; |sudo tee /etc/ld.so.conf.d/rocksdb-x86_64.confsudo ldconfig -v</span><br><span class="line">make shared_lib &amp;&amp; sudo make install-shared</span><br><span class="line">sudo ldconfig -v</span><br></pre></td></tr></table></figure><p>Tips:</p><ul><li><code>#echo &quot;/usr/local/lib&quot; |sudo tee /etc/ld.so.conf.d/rocksdb-x86_64.confsudo ldconfig -v</code>: refresh the ldconfig cacheINSTALL_PATH=/usr</li><li><code>sudo ldconfig -v</code>: refresh the ldconfig cache</li></ul><h2 id="test"><a class="markdownIt-Anchor" href="#test"></a> Test</h2><p>新建测试程序<code>rocksdbtest.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rocksdb/db.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rocksdb/slice.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rocksdb/options.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> rocksdb;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string PATH = <span class="string">&quot;/tmp/rocksdb_tmp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DB* db;</span><br><span class="line">    Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    Status status = DB::<span class="built_in">Open</span>(options, PATH, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="function">Slice <span class="title">key</span><span class="params">(<span class="string">&quot;foo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Slice <span class="title">value</span><span class="params">(<span class="string">&quot;bar&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::string get_value;</span><br><span class="line">    status = db-&gt;<span class="built_in">Put</span>(<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">    <span class="keyword">if</span>(status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        status = db-&gt;<span class="built_in">Get</span>(<span class="built_in">ReadOptions</span>(), key, &amp;get_value);</span><br><span class="line">        <span class="keyword">if</span>(status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get %s success!!\n&quot;</span>, get_value.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get failed\n&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;put failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -o rocksdbtest rocksdbtest.cpp -lrocksdb  -lpthread</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rocksdbtest</span><br></pre></td></tr></table></figure><p>正确结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get bar success!!</span><br></pre></td></tr></table></figure><h2 id="db_bench"><a class="markdownIt-Anchor" href="#db_bench"></a> db_bench</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make db_bench</span><br><span class="line">./db_bench</span><br></pre></td></tr></table></figure><p>Tips:</p><ul><li>运行db_bench时设置参数<br />e.g.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./db_bench -benchmarks=<span class="string">&quot;fillrandom,stats&quot;</span> -statistics -key_size=16 -value_size=65536 -db=./test_db1 -wal_dir=./test_db1 -duration=6000 -level0_file_num_compaction_trigger=1 -enable_pipelined_write=<span class="literal">true</span> -compression_type=None -stats_per_interval=1 -stats_interval_seconds=10 -max_write_buffer_number=6</span><br></pre></td></tr></table></figure></li></ul><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://blog.51cto.com/u_15081048/2592774">https://blog.51cto.com/u_15081048/2592774</a></li><li><a href="https://www.jianshu.com/p/575b2e27b028">https://www.jianshu.com/p/575b2e27b028</a></li><li><a href="https://blog.csdn.net/zhangpeterx/article/details/96869454">https://blog.csdn.net/zhangpeterx/article/details/96869454</a></li><li><a href="https://www.cxyzjd.com/article/zhangpeterx/96869454">https://www.cxyzjd.com/article/zhangpeterx/96869454</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Start from a new Ubuntu OS.&lt;/p&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    <category term="KV store" scheme="https://tongyiheng.top/categories/Embedded/KV-store/"/>
    
    
    <category term="RocksDB" scheme="https://tongyiheng.top/tags/RocksDB/"/>
    
    <category term="db_bench" scheme="https://tongyiheng.top/tags/db-bench/"/>
    
  </entry>
  
  <entry>
    <title>The Use of &quot;(void)val&quot;</title>
    <link href="https://tongyiheng.top/2021/10/11/Tricks/void/"/>
    <id>https://tongyiheng.top/2021/10/11/Tricks/void/</id>
    <published>2021-10-11T02:09:14.000Z</published>
    <updated>2021-10-19T07:17:39.184Z</updated>
    
    <content type="html"><![CDATA[<p>Have you ever seen “(void)val” in codes ?</p><span id="more"></span><p><strong>Why <code>(void)val</code></strong></p><p>作用是避免编译器警告。如果声明/定义了但未使用的变量，在编译时会生成warning。如果项目里打开了-Werror选项，会将warning视为error，这样的话无法通过编译，所以需要用这种方法绕过无关紧要的warning。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Have you ever seen “(void)val” in codes ?&lt;/p&gt;</summary>
    
    
    
    <category term="Tricks" scheme="https://tongyiheng.top/categories/Tricks/"/>
    
    
    <category term="cpp" scheme="https://tongyiheng.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg</title>
    <link href="https://tongyiheng.top/2021/09/27/Tools/ffmpeg/"/>
    <id>https://tongyiheng.top/2021/09/27/Tools/ffmpeg/</id>
    <published>2021-09-27T10:41:55.000Z</published>
    <updated>2021-10-19T04:13:12.110Z</updated>
    
    <content type="html"><![CDATA[<p>ffmpeg常用命令。</p><span id="more"></span><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><ul><li><p>查看媒体文件详细信息<br /><code>$ ffmpeg -i video.mp4</code></p></li><li><p>转换视频格式flv-&gt;mp4<br /><code>$ ffmpeg -i input.flv output.mp4</code></p></li><li><p>从一个媒体文件移除视频流<br /><code>$ ffmpeg -i input.mp4 -vn output.mp3</code></p></li><li><p>从一个视频文件移除音频流<br /><code>$ ffmpeg -i input.mp4 -an output.mp4</code></p></li><li><p>预览或测试视频或音频文件<br /><code>$ ffplay video.mp4</code><br /><code>$ ffplay audio.mp3</code></p></li><li><p>增加视频播放速度<br /><code>$ ffmpeg -i input.mp4 -vf &quot;setpts=0.5*PTS&quot; output.mp4</code></p></li><li><p>减少视频播放速度<br /><code>$ ffmpeg -i input.mp4 -vf &quot;setpts=4.0*PTS&quot; output.mp4</code></p></li><li><p>获取帮助<br /><code>$ man ffmpeg</code></p></li></ul><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/67878761">https://zhuanlan.zhihu.com/p/67878761</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ffmpeg常用命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://tongyiheng.top/categories/Tools/"/>
    
    
    <category term="ffmpeg" scheme="https://tongyiheng.top/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>RocksDB Compaction源码分析</title>
    <link href="https://tongyiheng.top/2021/09/24/Embedded/rocksdb-compaction/"/>
    <id>https://tongyiheng.top/2021/09/24/Embedded/rocksdb-compaction/</id>
    <published>2021-09-24T12:30:00.000Z</published>
    <updated>2021-10-19T07:18:29.853Z</updated>
    
    <content type="html"><![CDATA[<p>  RocksDB的Compaction过程整体可分为三个部分，prepare keys、process keys、write keys。</p><span id="more"></span><ul><li>入口：<code>db/db_impl_compaction_flush.cc</code>中的<code>BackgroundCompaction()</code></li></ul><h2 id="prepare-keys"><a class="markdownIt-Anchor" href="#prepare-keys"></a> Prepare keys</h2><h3 id="触发条件"><a class="markdownIt-Anchor" href="#触发条件"></a> 触发条件</h3><ul><li><p>RocksDB的compaction都是后台运行，通过线程<code>BGWorkCompaction</code>进行compaction的调度。Compaction分为两种：</p><ul><li>Manual compaction by <code>CompactFiles()</code></li><li>Auto compaction by <code>BackgroundCompaction()</code></li></ul></li><li><p><code>MaybeScheduleFlushOrCompaction</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (bg_compaction_scheduled_ &lt; bg_job_limits.max_compactions &amp;&amp;</span><br><span class="line">       unscheduled_compactions_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  CompactionArg* ca = <span class="keyword">new</span> CompactionArg;</span><br><span class="line">  ca-&gt;db = <span class="keyword">this</span>;</span><br><span class="line">  ca-&gt;prepicked_compaction = <span class="literal">nullptr</span>;</span><br><span class="line">  bg_compaction_scheduled_++; <span class="comment">//正在被调度的compaction线程数目</span></span><br><span class="line">  unscheduled_compactions_--; <span class="comment">//待调度的线程个数，及待调度的cfd的长度</span></span><br><span class="line">  <span class="comment">//调度BGWorkCompaction线程</span></span><br><span class="line">  env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkCompaction, ca, Env::Priority::LOW, <span class="keyword">this</span>,</span><br><span class="line">                 &amp;DBImpl::UnscheduleCompactionCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可以看到最大线程数量限制是<code>bg_job_limits.max_compactions</code>。</p><ul><li>队列<code>DBImpl::compaction_queue_</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;ColumnFamilyData*&gt; compaction_queue_;</span><br></pre></td></tr></table></figure><p>​    这个队列的更新是在函数<code>SchedulePendingCompaction</code>更新的，且<code>unscheduled_compactions_</code>变量是和该函数一起更新的，也就是只有设置了该变量才能够正常调度compaction后台线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::SchedulePendingCompaction</span><span class="params">(ColumnFamilyData* cfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cfd-&gt;<span class="built_in">queued_for_compaction</span>() &amp;&amp; cfd-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="built_in">AddToCompactionQueue</span>(cfd);</span><br><span class="line">    ++unscheduled_compactions_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面的核心函数是<code>NeedsCompaction</code>,通过这个函数来判断是否有sst需要被compact。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionPicker::NeedsCompaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VersionStorageInfo* vstorage)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">ExpiredTtlFiles</span>().<span class="built_in">empty</span>()) &#123; <span class="comment">//有超时的sst(ExpiredTtlFiles)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">FilesMarkedForPeriodicCompaction</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">BottommostFilesMarkedForCompaction</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">FilesMarkedForCompaction</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= vstorage-&gt;<span class="built_in">MaxInputLevel</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vstorage-&gt;<span class="built_in">CompactionScore</span>(i) &gt;= <span class="number">1</span>) &#123; <span class="comment">//遍历所有的level的sst,根据score判断是否需要compact</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sst文件的选择"><a class="markdownIt-Anchor" href="#sst文件的选择"></a> SST文件的选择</h3><p>下面这两个变量分别保存了level以及每个level所对应的score，score越高，优先级越高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; compaction_score_; <span class="comment">//当前sst的score</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; compaction_level_; <span class="comment">//当前sst需要被compact到的层level</span></span><br></pre></td></tr></table></figure><p>这两个变量的更新在函数<code>VersionStorageInfo::ComputeCompactionScore</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionStorageInfo::ComputeCompactionScore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ImmutableOptions&amp; immutable_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt;= <span class="built_in">MaxInputLevel</span>(); level++) &#123;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      <span class="type">int</span> num_sorted_runs = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> total_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>* f : files_[level]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f-&gt;being_compacted) &#123;</span><br><span class="line">          total_size += f-&gt;compensated_file_size;</span><br><span class="line">          num_sorted_runs++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compaction_style_ == kCompactionStyleUniversal) &#123;</span><br><span class="line">        <span class="comment">// For universal compaction, we use level0 score to indicate</span></span><br><span class="line">        <span class="comment">// compaction score for the whole DB. Adding other levels as if</span></span><br><span class="line">        <span class="comment">// they are L0 files.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">num_levels</span>(); i++) &#123;</span><br><span class="line">          <span class="comment">// Its possible that a subset of the files in a level may be in a</span></span><br><span class="line">          <span class="comment">// compaction, due to delete triggered compaction or trivial move.</span></span><br><span class="line">          <span class="comment">// In that case, the below check may not catch a level being</span></span><br><span class="line">          <span class="comment">// compacted as it only checks the first file. The worst that can</span></span><br><span class="line">          <span class="comment">// happen is a scheduled compaction thread will find nothing to do.</span></span><br><span class="line">          <span class="keyword">if</span> (!files_[i].<span class="built_in">empty</span>() &amp;&amp; !files_[i][<span class="number">0</span>]-&gt;being_compacted) &#123;</span><br><span class="line">            num_sorted_runs++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (compaction_style_ == kCompactionStyleFIFO) &#123;</span><br><span class="line">        score = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(total_size) /</span><br><span class="line">                mutable_cf_options.compaction_options_fifo.max_table_files_size;</span><br><span class="line">        <span class="keyword">if</span> (mutable_cf_options.compaction_options_fifo.allow_compaction ||</span><br><span class="line">            mutable_cf_options.compaction_options_fifo.age_for_warm &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// Warm tier move can happen at any time. It&#x27;s too expensive to</span></span><br><span class="line">          <span class="comment">// check very file&#x27;s timestamp now. For now, just trigger it</span></span><br><span class="line">          <span class="comment">// slightly more frequently than FIFO compaction so that this</span></span><br><span class="line">          <span class="comment">// happens first.</span></span><br><span class="line">          score = std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num_sorted_runs) /</span><br><span class="line">                  mutable_cf_options.level0_file_num_compaction_trigger,</span><br><span class="line">              score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mutable_cf_options.ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          score = std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">GetExpiredTtlFilesCount</span>(</span><br><span class="line">                  immutable_options, mutable_cf_options, files_[level])),</span><br><span class="line">              score);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        score = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num_sorted_runs) /</span><br><span class="line">                mutable_cf_options.level0_file_num_compaction_trigger;</span><br><span class="line">        <span class="keyword">if</span> (compaction_style_ == kCompactionStyleLevel &amp;&amp; <span class="built_in">num_levels</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// Level-based involves L0-&gt;L0 compactions that can lead to oversized</span></span><br><span class="line">          <span class="comment">// L0 files. Take into account size as well to avoid later giant</span></span><br><span class="line">          <span class="comment">// compactions to the base level.</span></span><br><span class="line">          <span class="type">uint64_t</span> l0_target_size = mutable_cf_options.max_bytes_for_level_base;</span><br><span class="line">          <span class="keyword">if</span> (immutable_options.level_compaction_dynamic_level_bytes &amp;&amp;</span><br><span class="line">              level_multiplier_ != <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="comment">// Prevent L0 to Lbase fanout from growing larger than</span></span><br><span class="line">            <span class="comment">// `level_multiplier_`. This prevents us from getting stuck picking</span></span><br><span class="line">            <span class="comment">// L0 forever even when it is hurting write-amp. That could happen</span></span><br><span class="line">            <span class="comment">// in dynamic level compaction&#x27;s write-burst mode where the base</span></span><br><span class="line">            <span class="comment">// level&#x27;s target size can grow to be enormous.</span></span><br><span class="line">            l0_target_size =</span><br><span class="line">                std::<span class="built_in">max</span>(l0_target_size,</span><br><span class="line">                         <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(level_max_bytes_[base_level_] /</span><br><span class="line">                                               level_multiplier_));</span><br><span class="line">          &#125;</span><br><span class="line">          score =</span><br><span class="line">              std::<span class="built_in">max</span>(score, <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(total_size) / l0_target_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="type">uint64_t</span> level_bytes_no_compacting = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> f : files_[level]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f-&gt;being_compacted) &#123;</span><br><span class="line">          level_bytes_no_compacting += f-&gt;compensated_file_size;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      score = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(level_bytes_no_compacting) /</span><br><span class="line">              <span class="built_in">MaxBytesForLevel</span>(level);</span><br><span class="line">    &#125;</span><br><span class="line">    compaction_level_[level] = level;</span><br><span class="line">    compaction_score_[level] = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sort all the levels based on their score. Higher scores get listed</span></span><br><span class="line">  <span class="comment">// first. Use bubble sort because the number of entries are small.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num_levels</span>() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">num_levels</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compaction_score_[i] &lt; compaction_score_[j]) &#123;</span><br><span class="line">        <span class="type">double</span> score = compaction_score_[i];</span><br><span class="line">        <span class="type">int</span> level = compaction_level_[i];</span><br><span class="line">        compaction_score_[i] = compaction_score_[j];</span><br><span class="line">        compaction_level_[i] = compaction_level_[j];</span><br><span class="line">        compaction_score_[j] = score;</span><br><span class="line">        compaction_level_[j] = level;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ComputeFilesMarkedForCompaction</span>();</span><br><span class="line">  <span class="built_in">ComputeBottommostFilesMarkedForCompaction</span>();</span><br><span class="line">  <span class="keyword">if</span> (mutable_cf_options.ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ComputeExpiredTtlFiles</span>(immutable_options, mutable_cf_options.ttl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mutable_cf_options.periodic_compaction_seconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ComputeFilesMarkedForPeriodicCompaction</span>(</span><br><span class="line">        immutable_options, mutable_cf_options.periodic_compaction_seconds);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">EstimateCompactionBytesNeeded</span>(mutable_cf_options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compaction每一层level大小的确定"><a class="markdownIt-Anchor" href="#compaction每一层level大小的确定"></a> compaction每一层level大小的确定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionStorageInfo::CalculateBaseBytes</span><span class="params">(<span class="type">const</span> ImmutableOptions&amp; ioptions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> MutableCFOptions&amp; options)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special logic to set number of sorted runs.</span></span><br><span class="line">  <span class="comment">// It is to match the previous behavior when all files are in L0.</span></span><br><span class="line">  <span class="type">int</span> num_l0_count = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">if</span> (compaction_style_ == kCompactionStyleUniversal) &#123;</span><br><span class="line">    <span class="comment">// For universal compaction, we use level0 score to indicate</span></span><br><span class="line">    <span class="comment">// compaction score for the whole DB. Adding other levels as if</span></span><br><span class="line">    <span class="comment">// they are L0 files.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">num_levels</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!files_[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        num_l0_count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_l0_delay_trigger_count</span>(num_l0_count);</span><br><span class="line"></span><br><span class="line">  level_max_bytes_.<span class="built_in">resize</span>(ioptions.num_levels);</span><br><span class="line">  <span class="keyword">if</span> (!ioptions.level_compaction_dynamic_level_bytes) &#123;</span><br><span class="line">    base_level_ = (ioptions.compaction_style == kCompactionStyleLevel) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate for static bytes base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ioptions.num_levels; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ioptions.compaction_style == kCompactionStyleUniversal) &#123;</span><br><span class="line">        level_max_bytes_[i] = options.max_bytes_for_level_base;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        level_max_bytes_[i] = <span class="built_in">MultiplyCheckOverflow</span>(</span><br><span class="line">            <span class="built_in">MultiplyCheckOverflow</span>(level_max_bytes_[i - <span class="number">1</span>],</span><br><span class="line">                                  options.max_bytes_for_level_multiplier),</span><br><span class="line">            options.<span class="built_in">MaxBytesMultiplerAdditional</span>(i - <span class="number">1</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        level_max_bytes_[i] = options.max_bytes_for_level_base;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> max_level_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first_non_empty_level = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Find size of non-L0 level of most data.</span></span><br><span class="line">    <span class="comment">// Cannot use the size of the last level because it can be empty or less</span></span><br><span class="line">    <span class="comment">// than previous levels after compaction.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num_levels_; i++) &#123;</span><br><span class="line">      <span class="type">uint64_t</span> total_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : files_[i]) &#123;</span><br><span class="line">        total_size += f-&gt;fd.<span class="built_in">GetFileSize</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (total_size &gt; <span class="number">0</span> &amp;&amp; first_non_empty_level == <span class="number">-1</span>) &#123;</span><br><span class="line">        first_non_empty_level = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (total_size &gt; max_level_size) &#123;</span><br><span class="line">        max_level_size = total_size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prefill every level&#x27;s max bytes to disallow compaction from there.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_levels_; i++) &#123;</span><br><span class="line">      level_max_bytes_[i] = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_level_size == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// No data for L1 and up. L0 compacts to last level directly.</span></span><br><span class="line">      <span class="comment">// No compaction from L1+ needs to be scheduled.</span></span><br><span class="line">      base_level_ = num_levels_ - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">uint64_t</span> l0_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : files_[<span class="number">0</span>]) &#123;</span><br><span class="line">        l0_size += f-&gt;fd.<span class="built_in">GetFileSize</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> base_bytes_max =</span><br><span class="line">          std::<span class="built_in">max</span>(options.max_bytes_for_level_base, l0_size);</span><br><span class="line">      <span class="type">uint64_t</span> base_bytes_min = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">          base_bytes_max / options.max_bytes_for_level_multiplier);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try whether we can make last level&#x27;s target size to be max_level_size</span></span><br><span class="line">      <span class="type">uint64_t</span> cur_level_size = max_level_size;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = num_levels_ - <span class="number">2</span>; i &gt;= first_non_empty_level; i--) &#123; <span class="comment">//从倒数第二层level往上到first non empty level</span></span><br><span class="line">        <span class="comment">// Round up after dividing</span></span><br><span class="line">        cur_level_size = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">            cur_level_size / options.max_bytes_for_level_multiplier);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Calculate base level and its size.</span></span><br><span class="line">      <span class="type">uint64_t</span> base_level_size;</span><br><span class="line">      <span class="keyword">if</span> (cur_level_size &lt;= base_bytes_min) &#123;</span><br><span class="line">        <span class="comment">// Case 1. If we make target size of last level to be max_level_size,</span></span><br><span class="line">        <span class="comment">// target size of the first non-empty level would be smaller than</span></span><br><span class="line">        <span class="comment">// base_bytes_min. We set it be base_bytes_min.</span></span><br><span class="line">        base_level_size = base_bytes_min + <span class="number">1U</span>;</span><br><span class="line">        base_level_ = first_non_empty_level;</span><br><span class="line">        <span class="built_in">ROCKS_LOG_INFO</span>(ioptions.logger,</span><br><span class="line">                       <span class="string">&quot;More existing levels in DB than needed. &quot;</span></span><br><span class="line">                       <span class="string">&quot;max_bytes_for_level_multiplier may not be guaranteed.&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find base level (where L0 data is compacted to).</span></span><br><span class="line">        base_level_ = first_non_empty_level;</span><br><span class="line">        <span class="keyword">while</span> (base_level_ &gt; <span class="number">1</span> &amp;&amp; cur_level_size &gt; base_bytes_max) &#123;</span><br><span class="line">          --base_level_;</span><br><span class="line">          cur_level_size = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">              cur_level_size / options.max_bytes_for_level_multiplier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_level_size &gt; base_bytes_max) &#123;</span><br><span class="line">          <span class="comment">// Even L1 will be too large</span></span><br><span class="line">          <span class="built_in">assert</span>(base_level_ == <span class="number">1</span>);</span><br><span class="line">          base_level_size = base_bytes_max;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          base_level_size = cur_level_size;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      level_multiplier_ = options.max_bytes_for_level_multiplier;</span><br><span class="line">      <span class="built_in">assert</span>(base_level_size &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (l0_size &gt; base_level_size &amp;&amp;</span><br><span class="line">          (l0_size &gt; options.max_bytes_for_level_base ||</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(files_[<span class="number">0</span>].<span class="built_in">size</span>() / <span class="number">2</span>) &gt;=</span><br><span class="line">               options.level0_file_num_compaction_trigger)) &#123;</span><br><span class="line">        <span class="comment">// We adjust the base level according to actual L0 size, and adjust</span></span><br><span class="line">        <span class="comment">// the level multiplier accordingly, when:</span></span><br><span class="line">        <span class="comment">//   1. the L0 size is larger than level size base, or</span></span><br><span class="line">        <span class="comment">//   2. number of L0 files reaches twice the L0-&gt;L1 compaction trigger</span></span><br><span class="line">        <span class="comment">// We don&#x27;t do this otherwise to keep the LSM-tree structure stable</span></span><br><span class="line">        <span class="comment">// unless the L0 compaction is backlogged.</span></span><br><span class="line">        base_level_size = l0_size;</span><br><span class="line">        <span class="keyword">if</span> (base_level_ == num_levels_ - <span class="number">1</span>) &#123;</span><br><span class="line">          level_multiplier_ = <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          level_multiplier_ = std::<span class="built_in">pow</span>(</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(max_level_size) /</span><br><span class="line">                  <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(base_level_size),</span><br><span class="line">              <span class="number">1.0</span> / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num_levels_ - base_level_ - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> level_size = base_level_size;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = base_level_; i &lt; num_levels_; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; base_level_) &#123;</span><br><span class="line">          level_size = <span class="built_in">MultiplyCheckOverflow</span>(level_size, level_multiplier_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don&#x27;t set any level below base_bytes_max. Otherwise, the LSM can</span></span><br><span class="line">        <span class="comment">// assume an hourglass shape where L1+ sizes are smaller than L0. This</span></span><br><span class="line">        <span class="comment">// causes compaction scoring, which depends on level sizes, to favor L1+</span></span><br><span class="line">        <span class="comment">// at the expense of L0, which may fill up and stall.</span></span><br><span class="line">        level_max_bytes_[i] = std::<span class="built_in">max</span>(level_size, base_bytes_max);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>static：每一层的大小都是固定的</p></li><li><p>dynamic：动态根据每一层大小进行计算</p></li></ol><ul><li>引入base level的概念，通常使用空间放大来衡量空间效率，忽略数据压缩的影响，空间放大 = size_on_file_system / size_of_user_data。</li></ul><h3 id="挑选参与compaction的文件"><a class="markdownIt-Anchor" href="#挑选参与compaction的文件"></a> 挑选参与compaction的文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">LevelCompactionBuilder::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pick up the first file to start compaction. It may have been extended</span></span><br><span class="line">  <span class="comment">// to a clean cut.</span></span><br><span class="line">  <span class="built_in">SetupInitialFiles</span>();</span><br><span class="line">  <span class="keyword">if</span> (start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(start_level_ &gt;= <span class="number">0</span> &amp;&amp; output_level_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it is a L0 -&gt; base level compaction, we need to set up other L0</span></span><br><span class="line">  <span class="comment">// files if needed.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SetupOtherL0FilesIfNeeded</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick files in the output level and expand more files in the start level</span></span><br><span class="line">  <span class="comment">// if needed.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SetupOtherInputsIfNeeded</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Form a compaction object containing the files we picked.</span></span><br><span class="line">  Compaction* c = <span class="built_in">GetCompaction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;LevelCompactionPicker::PickCompaction:Return&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里PickCompaction分别调用了三个主要的函数。</p><ul><li><code>SetupInitialFiles</code> 初始化需要compact的文件</li><li><code>SetupOtherL0FilesIfNeeded</code> 如果需要的话，setup一些其他的L0文件</li><li><code>SetupOtherInputsIfNeeded</code> 如果需要的话，setup一些其他的inputs</li></ul><p>下面首先分析<code>SetupInitialFiles</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelCompactionBuilder::SetupInitialFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Find the compactions by size on all levels.</span></span><br><span class="line">  <span class="type">bool</span> skipped_l0_to_base = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; compaction_picker_-&gt;<span class="built_in">NumberLevels</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    start_level_score_ = vstorage_-&gt;<span class="built_in">CompactionScore</span>(i);</span><br><span class="line">    start_level_ = vstorage_-&gt;<span class="built_in">CompactionScoreLevel</span>(i);</span><br><span class="line">    <span class="built_in">assert</span>(i == <span class="number">0</span> || start_level_score_ &lt;= vstorage_-&gt;<span class="built_in">CompactionScore</span>(i - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (start_level_score_ &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (skipped_l0_to_base &amp;&amp; start_level_ == vstorage_-&gt;<span class="built_in">base_level</span>()) &#123;</span><br><span class="line">        <span class="comment">// If L0-&gt;base_level compaction is pending, don&#x27;t schedule further</span></span><br><span class="line">        <span class="comment">// compaction from base level. Otherwise L0-&gt;base_level compaction</span></span><br><span class="line">        <span class="comment">// may starve.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      output_level_ =</span><br><span class="line">          (start_level_ == <span class="number">0</span>) ? vstorage_-&gt;<span class="built_in">base_level</span>() : start_level_ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">PickFileToCompact</span>()) &#123;</span><br><span class="line">        <span class="comment">// found the compaction!</span></span><br><span class="line">        <span class="keyword">if</span> (start_level_ == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// L0 score = `num L0 files` / `level0_file_num_compaction_trigger`</span></span><br><span class="line">          compaction_reason_ = CompactionReason::kLevelL0FilesNum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// L1+ score = `Level files size` / `MaxBytesForLevel`</span></span><br><span class="line">          compaction_reason_ = CompactionReason::kLevelMaxLevelSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// didn&#x27;t find the compaction, clear the inputs</span></span><br><span class="line">        start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (start_level_ == <span class="number">0</span>) &#123;</span><br><span class="line">          skipped_l0_to_base = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// L0-&gt;base_level may be blocked due to ongoing L0-&gt;base_level</span></span><br><span class="line">          <span class="comment">// compactions. It may also be blocked by an ongoing compaction from</span></span><br><span class="line">          <span class="comment">// base_level downwards.</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// In these cases, to reduce L0 file count and thus reduce likelihood</span></span><br><span class="line">          <span class="comment">// of write stalls, we can attempt compacting a span of files within</span></span><br><span class="line">          <span class="comment">// L0.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">PickIntraL0Compaction</span>()) &#123;</span><br><span class="line">            output_level_ = <span class="number">0</span>;</span><br><span class="line">            compaction_reason_ = CompactionReason::kLevelL0FilesNum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compaction scores are sorted in descending order, no further scores</span></span><br><span class="line">      <span class="comment">// will be &gt;= 1.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we didn&#x27;t find a compaction, check if there are any files marked for</span></span><br><span class="line">  <span class="comment">// compaction</span></span><br><span class="line">  parent_index_ = base_index_ = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  compaction_picker_-&gt;<span class="built_in">PickFilesMarkedForCompaction</span>(</span><br><span class="line">      cf_name_, vstorage_, &amp;start_level_, &amp;output_level_, &amp;start_level_inputs_);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kFilesMarkedForCompaction;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bottommost Files Compaction on deleting tombstones</span></span><br><span class="line">  <span class="built_in">PickFileToCompact</span>(vstorage_-&gt;<span class="built_in">BottommostFilesMarkedForCompaction</span>(), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kBottommostFiles;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TTL Compaction</span></span><br><span class="line">  <span class="built_in">PickFileToCompact</span>(vstorage_-&gt;<span class="built_in">ExpiredTtlFiles</span>(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kTtl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Periodic Compaction</span></span><br><span class="line">  <span class="built_in">PickFileToCompact</span>(vstorage_-&gt;<span class="built_in">FilesMarkedForPeriodicCompaction</span>(), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kPeriodicCompaction;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先遍历所有的level，从之前计算好的的compaction信息中得到每个level对应的score，只有当score&gt;=1才能继续进行compact的处理。</p></li><li><p>通过<code>PickFileToCompact</code>来选择input以及output文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionBuilder::PickFileToCompact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// level 0 files are overlapping. So we cannot pick more</span></span><br><span class="line">  <span class="comment">// than one concurrent compactions at this level. This</span></span><br><span class="line">  <span class="comment">// could be made better by looking at key-ranges that are</span></span><br><span class="line">  <span class="comment">// being compacted at level 0.</span></span><br><span class="line">  <span class="keyword">if</span> (start_level_ == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      !compaction_picker_-&gt;<span class="built_in">level0_compactions_in_progress</span>()-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;LevelCompactionPicker::PickCompactionBySize:0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(start_level_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick the largest file in this level that is not already</span></span><br><span class="line">  <span class="comment">// being compacted</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; file_size =</span><br><span class="line">      vstorage_-&gt;<span class="built_in">FilesByCompactionPri</span>(start_level_);</span><br><span class="line">  <span class="type">const</span> std::vector&lt;FileMetaData*&gt;&amp; level_files =</span><br><span class="line">      vstorage_-&gt;<span class="built_in">LevelFiles</span>(start_level_);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cmp_idx;</span><br><span class="line">  <span class="keyword">for</span> (cmp_idx = vstorage_-&gt;<span class="built_in">NextCompactionIndex</span>(start_level_);</span><br><span class="line">       cmp_idx &lt; file_size.<span class="built_in">size</span>(); cmp_idx++) &#123;</span><br><span class="line">    <span class="type">int</span> index = file_size[cmp_idx];</span><br><span class="line">    <span class="keyword">auto</span>* f = level_files[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not pick a file to compact if it is being compacted</span></span><br><span class="line">    <span class="comment">// from n-1 level.</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;being_compacted) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_level_inputs_.files.<span class="built_in">push_back</span>(f);</span><br><span class="line">    start_level_inputs_.level = start_level_;</span><br><span class="line">    <span class="keyword">if</span> (!compaction_picker_-&gt;<span class="built_in">ExpandInputsToCleanCut</span>(cf_name_, vstorage_,</span><br><span class="line">                                                    &amp;start_level_inputs_) ||</span><br><span class="line">        compaction_picker_-&gt;<span class="built_in">FilesRangeOverlapWithCompaction</span>(</span><br><span class="line">            &#123;start_level_inputs_&#125;, output_level_)) &#123;</span><br><span class="line">      <span class="comment">// A locked (pending compaction) input-level file was pulled in due to</span></span><br><span class="line">      <span class="comment">// user-key overlap.</span></span><br><span class="line">      start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that input level is fully expanded, we check whether any output files</span></span><br><span class="line">    <span class="comment">// are locked due to pending compaction.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note we rely on ExpandInputsToCleanCut() to tell us whether any output-</span></span><br><span class="line">    <span class="comment">// level files are locked, not just the extra ones pulled in for user-key</span></span><br><span class="line">    <span class="comment">// overlap.</span></span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    compaction_picker_-&gt;<span class="built_in">GetRange</span>(start_level_inputs_, &amp;smallest, &amp;largest);</span><br><span class="line">    CompactionInputFiles output_level_inputs;</span><br><span class="line">    output_level_inputs.level = output_level_;</span><br><span class="line">    vstorage_-&gt;<span class="built_in">GetOverlappingInputs</span>(output_level_, &amp;smallest, &amp;largest,</span><br><span class="line">                                    &amp;output_level_inputs.files);</span><br><span class="line">    <span class="keyword">if</span> (!output_level_inputs.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">        !compaction_picker_-&gt;<span class="built_in">ExpandInputsToCleanCut</span>(cf_name_, vstorage_,</span><br><span class="line">                                                    &amp;output_level_inputs)) &#123;</span><br><span class="line">      start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base_index_ = index;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store where to start the iteration in the next call to PickCompaction</span></span><br><span class="line">  vstorage_-&gt;<span class="built_in">SetNextCompactionIndex</span>(start_level_, cmp_idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> start_level_inputs_.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先得到当前level(start_level_)的未compacted的最大大小的文件。</p></li><li><p>通过cmp_idx索引到对应的文件。</p></li><li><p>通过<code>ExpandInputsToCleanCut</code>扩展当前文件的key的范围，需要满足&quot;<a href="https://github.com/facebook/rocksdb/wiki/Choose-Level-Compaction-Files">clean cut</a>&quot;。</p></li><li><p>通过<code>FilesRangeOverlapWithCompaction</code>判断是否有正在compact的out_level的文件范围和已经选择好的文件的key有overlap，如果有则跳过（clear start_level_inputs然后continue）。</p></li><li><p>最后在output_level中选择和start_level已经选择的文件的key有overlap的文件，通过<code>ExpandInputsToCleanCut</code>来判断output level files是否有被lock的，如果有则跳过（clear start_level_inputs然后continue）。</p></li></ul></li></ul><p>继续分析<code>PickCompaction</code>，在RocksDB中level-0比较特殊，因为只有level-0中的sst文件之间是无序的，因此接下来我们需要特殊处理level-0的情况，这个函数就是<code>SetupOtherL0FilesIfNeeded</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionBuilder::SetupOtherL0FilesIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start_level_ == <span class="number">0</span> &amp;&amp; output_level_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> compaction_picker_-&gt;<span class="built_in">GetOverlappingL0Files</span>(</span><br><span class="line">        vstorage_, &amp;start_level_inputs_, output_level_, &amp;parent_index_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用start_level_ == 0 且 output_level_ != 0则调用<code>GetOverlappingL0Files</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompactionPicker::GetOverlappingL0Files</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionStorageInfo* vstorage, CompactionInputFiles* start_level_inputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> output_level, <span class="type">int</span>* parent_index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Two level 0 compaction won&#x27;t run at the same time, so don&#x27;t need to worry</span></span><br><span class="line">  <span class="comment">// about files on level 0 being compacted.</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">level0_compactions_in_progress</span>()-&gt;<span class="built_in">empty</span>());</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  <span class="built_in">GetRange</span>(*start_level_inputs, &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">  <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">  <span class="comment">// which will include the picked file.</span></span><br><span class="line">  start_level_inputs-&gt;files.<span class="built_in">clear</span>();</span><br><span class="line">  vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(<span class="number">0</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;(start_level_inputs-&gt;files));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we include more L0 files in the same compaction run it can</span></span><br><span class="line">  <span class="comment">// cause the &#x27;smallest&#x27; and &#x27;largest&#x27; key to get extended to a</span></span><br><span class="line">  <span class="comment">// larger range. So, re-invoke GetRange to get the new key range</span></span><br><span class="line">  <span class="built_in">GetRange</span>(*start_level_inputs, &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsRangeInCompaction</span>(vstorage, &amp;smallest, &amp;largest, output_level,</span><br><span class="line">                          parent_index)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(!start_level_inputs-&gt;files.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从level-0中得到所有的重合key的文件，然后加入到start_level_inputs中。</li></ul><p>最后调用<code>SetupOtherInputsIfNeeded()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionBuilder::SetupOtherInputsIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Setup input files from output level. For output to L0, we only compact</span></span><br><span class="line">  <span class="comment">// spans of files that do not interact with any pending compactions, so don&#x27;t</span></span><br><span class="line">  <span class="comment">// need to consider other levels.</span></span><br><span class="line">  <span class="keyword">if</span> (output_level_ != <span class="number">0</span>) &#123;</span><br><span class="line">    output_level_inputs_.level = output_level_;</span><br><span class="line">    <span class="keyword">if</span> (!compaction_picker_-&gt;<span class="built_in">SetupOtherInputs</span>(</span><br><span class="line">            cf_name_, mutable_cf_options_, vstorage_, &amp;start_level_inputs_,</span><br><span class="line">            &amp;output_level_inputs_, &amp;parent_index_, base_index_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compaction_inputs_.<span class="built_in">push_back</span>(start_level_inputs_);</span><br><span class="line">    <span class="keyword">if</span> (!output_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      compaction_inputs_.<span class="built_in">push_back</span>(output_level_inputs_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In some edge cases we could pick a compaction that will be compacting</span></span><br><span class="line">    <span class="comment">// a key range that overlap with another running compaction, and both</span></span><br><span class="line">    <span class="comment">// of them have the same output level. This could happen if</span></span><br><span class="line">    <span class="comment">// (1) we are running a non-exclusive manual compaction</span></span><br><span class="line">    <span class="comment">// (2) AddFile ingest a new file into the LSM tree</span></span><br><span class="line">    <span class="comment">// We need to disallow this from happening.</span></span><br><span class="line">    <span class="keyword">if</span> (compaction_picker_-&gt;<span class="built_in">FilesRangeOverlapWithCompaction</span>(compaction_inputs_,</span><br><span class="line">                                                            output_level_)) &#123;</span><br><span class="line">      <span class="comment">// This compaction output could potentially conflict with the output</span></span><br><span class="line">      <span class="comment">// of a currently running compaction, we cannot run it.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    compaction_picker_-&gt;<span class="built_in">GetGrandparents</span>(vstorage_, start_level_inputs_,</span><br><span class="line">                                        output_level_inputs_, &amp;grandparents_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compaction_inputs_.<span class="built_in">push_back</span>(start_level_inputs_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>SetupOtherInputs</code>，扩展start_level_inputs对应的output。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Populates the set of inputs of all other levels that overlap with the</span></span><br><span class="line"><span class="comment">// start level.</span></span><br><span class="line"><span class="comment">// Now we assume all levels except start level and output level are empty.</span></span><br><span class="line"><span class="comment">// Will also attempt to expand &quot;start level&quot; if that doesn&#x27;t expand</span></span><br><span class="line"><span class="comment">// &quot;output level&quot; or cause &quot;level&quot; to include a file for compaction that has an</span></span><br><span class="line"><span class="comment">// overlapping user-key with another file.</span></span><br><span class="line"><span class="comment">// REQUIRES: input_level and output_level are different</span></span><br><span class="line"><span class="comment">// REQUIRES: inputs-&gt;empty() == false</span></span><br><span class="line"><span class="comment">// Returns false if files on parent level are currently in compaction, which</span></span><br><span class="line"><span class="comment">// means that we can&#x27;t compact them</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompactionPicker::SetupOtherInputs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; cf_name, <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionStorageInfo* vstorage, CompactionInputFiles* inputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    CompactionInputFiles* output_level_inputs, <span class="type">int</span>* parent_index,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> base_index)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!inputs-&gt;<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">assert</span>(output_level_inputs-&gt;<span class="built_in">empty</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> input_level = inputs-&gt;level;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> output_level = output_level_inputs-&gt;level;</span><br><span class="line">  <span class="keyword">if</span> (input_level == output_level) &#123;</span><br><span class="line">    <span class="comment">// no possibility of conflict</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For now, we only support merging two levels, start level and output level.</span></span><br><span class="line">  <span class="comment">// We need to assert other levels are empty.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = input_level + <span class="number">1</span>; l &lt; output_level; l++) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(vstorage-&gt;<span class="built_in">NumLevelFiles</span>(l) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the range one last time.</span></span><br><span class="line">  <span class="built_in">GetRange</span>(*inputs, &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Populate the set of next-level files (inputs_GetOutputLevelInputs()) to</span></span><br><span class="line">  <span class="comment">// include in compaction</span></span><br><span class="line">  vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(output_level, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;output_level_inputs-&gt;files, *parent_index,</span><br><span class="line">                                 parent_index);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">AreFilesInCompaction</span>(output_level_inputs-&gt;files)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!output_level_inputs-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ExpandInputsToCleanCut</span>(cf_name, vstorage, output_level_inputs)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we can further grow the number of inputs in &quot;level&quot; without</span></span><br><span class="line">  <span class="comment">// changing the number of &quot;level+1&quot; files we pick up. We also choose NOT</span></span><br><span class="line">  <span class="comment">// to expand if this would cause &quot;level&quot; to include some entries for some</span></span><br><span class="line">  <span class="comment">// user key, while excluding other entries for the same user key. This</span></span><br><span class="line">  <span class="comment">// can happen when one user key spans multiple files.</span></span><br><span class="line">  <span class="keyword">if</span> (!output_level_inputs-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> limit = mutable_cf_options.max_compaction_bytes;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> output_level_inputs_size =</span><br><span class="line">        <span class="built_in">TotalCompensatedFileSize</span>(output_level_inputs-&gt;files);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> inputs_size = <span class="built_in">TotalCompensatedFileSize</span>(inputs-&gt;files);</span><br><span class="line">    <span class="type">bool</span> expand_inputs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CompactionInputFiles expanded_inputs;</span><br><span class="line">    expanded_inputs.level = input_level;</span><br><span class="line">    <span class="comment">// Get closed interval of output level</span></span><br><span class="line">    InternalKey all_start, all_limit;</span><br><span class="line">    <span class="built_in">GetRange</span>(*inputs, *output_level_inputs, &amp;all_start, &amp;all_limit);</span><br><span class="line">    <span class="type">bool</span> try_overlapping_inputs = <span class="literal">true</span>;</span><br><span class="line">    vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(input_level, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;expanded_inputs.files, base_index, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">uint64_t</span> expanded_inputs_size =</span><br><span class="line">        <span class="built_in">TotalCompensatedFileSize</span>(expanded_inputs.files);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ExpandInputsToCleanCut</span>(cf_name, vstorage, &amp;expanded_inputs)) &#123;</span><br><span class="line">      try_overlapping_inputs = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (try_overlapping_inputs &amp;&amp; expanded_inputs.<span class="built_in">size</span>() &gt; inputs-&gt;<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        output_level_inputs_size + expanded_inputs_size &lt; limit &amp;&amp;</span><br><span class="line">        !<span class="built_in">AreFilesInCompaction</span>(expanded_inputs.files)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      <span class="built_in">GetRange</span>(expanded_inputs, &amp;new_start, &amp;new_limit);</span><br><span class="line">      CompactionInputFiles expanded_output_level_inputs;</span><br><span class="line">      expanded_output_level_inputs.level = output_level;</span><br><span class="line">      vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(output_level, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded_output_level_inputs.files,</span><br><span class="line">                                     *parent_index, parent_index);</span><br><span class="line">      <span class="built_in">assert</span>(!expanded_output_level_inputs.<span class="built_in">empty</span>());</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">AreFilesInCompaction</span>(expanded_output_level_inputs.files) &amp;&amp;</span><br><span class="line">          <span class="built_in">ExpandInputsToCleanCut</span>(cf_name, vstorage,</span><br><span class="line">                                 &amp;expanded_output_level_inputs) &amp;&amp;</span><br><span class="line">          expanded_output_level_inputs.<span class="built_in">size</span>() == output_level_inputs-&gt;<span class="built_in">size</span>()) &#123;</span><br><span class="line">        expand_inputs = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!expand_inputs) &#123;</span><br><span class="line">      vstorage-&gt;<span class="built_in">GetCleanInputsWithinInterval</span>(input_level, &amp;all_start,</span><br><span class="line">                                             &amp;all_limit, &amp;expanded_inputs.files,</span><br><span class="line">                                             base_index, <span class="literal">nullptr</span>);</span><br><span class="line">      expanded_inputs_size = <span class="built_in">TotalCompensatedFileSize</span>(expanded_inputs.files);</span><br><span class="line">      <span class="keyword">if</span> (expanded_inputs.<span class="built_in">size</span>() &gt; inputs-&gt;<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">          output_level_inputs_size + expanded_inputs_size &lt; limit &amp;&amp;</span><br><span class="line">          !<span class="built_in">AreFilesInCompaction</span>(expanded_inputs.files)) &#123;</span><br><span class="line">        expand_inputs = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expand_inputs) &#123;</span><br><span class="line">      <span class="built_in">ROCKS_LOG_INFO</span>(ioptions_.logger,</span><br><span class="line">                     <span class="string">&quot;[%s] Expanding@%d %&quot;</span> ROCKSDB_PRIszt <span class="string">&quot;+%&quot;</span> ROCKSDB_PRIszt</span><br><span class="line">                     <span class="string">&quot;(%&quot;</span> PRIu64 <span class="string">&quot;+%&quot;</span> PRIu64 <span class="string">&quot; bytes) to %&quot;</span> ROCKSDB_PRIszt</span><br><span class="line">                     <span class="string">&quot;+%&quot;</span> ROCKSDB_PRIszt <span class="string">&quot; (%&quot;</span> PRIu64 <span class="string">&quot;+%&quot;</span> PRIu64 <span class="string">&quot; bytes)\n&quot;</span>,</span><br><span class="line">                     cf_name.<span class="built_in">c_str</span>(), input_level, inputs-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                     output_level_inputs-&gt;<span class="built_in">size</span>(), inputs_size,</span><br><span class="line">                     output_level_inputs_size, expanded_inputs.<span class="built_in">size</span>(),</span><br><span class="line">                     output_level_inputs-&gt;<span class="built_in">size</span>(), expanded_inputs_size,</span><br><span class="line">                     output_level_inputs_size);</span><br><span class="line">      inputs-&gt;files = expanded_inputs.files;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将start_level_inputs和output_level_inputs加入到compaction_inputs中。</p></li><li><p>防止一些可能会出现的conflict情况，进行一些判断。</p></li></ul><p>回到<code>PickCompaction</code>函数，最后构造一个compaction然后返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Form a compaction object containing the files we picked.</span></span><br><span class="line">Compaction* c = <span class="built_in">GetCompaction</span>();</span><br><span class="line"><span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;LevelCompactionPicker::PickCompaction:Return&quot;</span>, c);</span><br><span class="line"><span class="keyword">return</span> c;</span><br></pre></td></tr></table></figure><h3 id="compaction-job根据获取到数据分配compaction线程"><a class="markdownIt-Anchor" href="#compaction-job根据获取到数据分配compaction线程"></a> Compaction job:根据获取到数据分配compaction线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:BeforeCompaction&quot;</span>,</span><br><span class="line">                             c-&gt;<span class="built_in">column_family_data</span>());</span><br><span class="line">    <span class="type">int</span> output_level __attribute__((__unused__));</span><br><span class="line">    output_level = c-&gt;<span class="built_in">output_level</span>();</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:NonTrivial&quot;</span>,</span><br><span class="line">                             &amp;output_level);</span><br><span class="line">    std::vector&lt;SequenceNumber&gt; snapshot_seqs;</span><br><span class="line">    SequenceNumber earliest_write_conflict_snapshot;</span><br><span class="line">    SnapshotChecker* snapshot_checker;</span><br><span class="line">    <span class="built_in">GetSnapshotContext</span>(job_context, &amp;snapshot_seqs,</span><br><span class="line">                       &amp;earliest_write_conflict_snapshot, &amp;snapshot_checker);</span><br><span class="line">    <span class="built_in">assert</span>(is_snapshot_supported_ || snapshots_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="function">CompactionJob <span class="title">compaction_job</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        job_context-&gt;job_id, c.get(), immutable_db_options_,</span></span></span><br><span class="line"><span class="params"><span class="function">        mutable_db_options_, file_options_for_compaction_, versions_.get(),</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;shutting_down_, preserve_deletes_seqnum_.load(), log_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        directories_.GetDbDir(),</span></span></span><br><span class="line"><span class="params"><span class="function">        GetDataDir(c-&gt;column_family_data(), c-&gt;output_path_id()),</span></span></span><br><span class="line"><span class="params"><span class="function">        GetDataDir(c-&gt;column_family_data(), <span class="number">0</span>), stats_, &amp;mutex_,</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;error_handler_, snapshot_seqs, earliest_write_conflict_snapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">        snapshot_checker, table_cache_, &amp;event_logger_,</span></span></span><br><span class="line"><span class="params"><span class="function">        c-&gt;mutable_cf_options()-&gt;paranoid_file_checks,</span></span></span><br><span class="line"><span class="params"><span class="function">        c-&gt;mutable_cf_options()-&gt;report_bg_io_stats, dbname_,</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;compaction_job_stats, thread_pri, io_tracer_,</span></span></span><br><span class="line"><span class="params"><span class="function">        is_manual ? &amp;manual_compaction_paused_ : <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        is_manual ? manual_compaction-&gt;canceled : <span class="literal">nullptr</span>, db_id_,</span></span></span><br><span class="line"><span class="params"><span class="function">        db_session_id_, c-&gt;column_family_data()-&gt;GetFullHistoryTsLow(),</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;blob_callback_)</span></span>;</span><br><span class="line">    compaction_job.<span class="built_in">Prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NotifyOnCompactionBegin</span>(c-&gt;<span class="built_in">column_family_data</span>(), c.<span class="built_in">get</span>(), status,</span><br><span class="line">                            compaction_job_stats, job_context-&gt;job_id);</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(</span><br><span class="line">        <span class="string">&quot;DBImpl::BackgroundCompaction:NonTrivial:BeforeRun&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// Should handle erorr?</span></span><br><span class="line">    compaction_job.<span class="built_in">Run</span>().<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:NonTrivial:AfterRun&quot;</span>);</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">    status = compaction_job.<span class="built_in">Install</span>(*c-&gt;<span class="built_in">mutable_cf_options</span>());</span><br><span class="line">    io_s = compaction_job.<span class="built_in">io_status</span>();</span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">InstallSuperVersionAndScheduleWork</span>(c-&gt;<span class="built_in">column_family_data</span>(),</span><br><span class="line">                                         &amp;job_context-&gt;superversion_contexts[<span class="number">0</span>],</span><br><span class="line">                                         *c-&gt;<span class="built_in">mutable_cf_options</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    *made_progress = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:AfterCompaction&quot;</span>,</span><br><span class="line">                             c-&gt;<span class="built_in">column_family_data</span>());</span><br></pre></td></tr></table></figure><ul><li><p><code>Prepare</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompactionJob::Prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_COMPACTION_PREPARE)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate file_levels_ for compaction before making Iterator</span></span><br><span class="line">  <span class="keyword">auto</span>* c = compact_-&gt;compaction;</span><br><span class="line">  <span class="built_in">assert</span>(c-&gt;<span class="built_in">column_family_data</span>() != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(c-&gt;<span class="built_in">column_family_data</span>()-&gt;<span class="built_in">current</span>()-&gt;<span class="built_in">storage_info</span>()-&gt;<span class="built_in">NumLevelFiles</span>(</span><br><span class="line">             compact_-&gt;compaction-&gt;<span class="built_in">level</span>()) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  write_hint_ =</span><br><span class="line">      c-&gt;<span class="built_in">column_family_data</span>()-&gt;<span class="built_in">CalculateSSTWriteHint</span>(c-&gt;<span class="built_in">output_level</span>());</span><br><span class="line">  bottommost_level_ = c-&gt;<span class="built_in">bottommost_level</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;<span class="built_in">ShouldFormSubcompactions</span>()) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">StopWatch <span class="title">sw</span><span class="params">(db_options_.clock, stats_, SUBCOMPACTION_SETUP_TIME)</span></span>;</span><br><span class="line">      <span class="built_in">GenSubcompactionBoundaries</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(sizes_.<span class="built_in">size</span>() == boundaries_.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= boundaries_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      Slice* start = i == <span class="number">0</span> ? <span class="literal">nullptr</span> : &amp;boundaries_[i - <span class="number">1</span>];</span><br><span class="line">      Slice* end = i == boundaries_.<span class="built_in">size</span>() ? <span class="literal">nullptr</span> : &amp;boundaries_[i];</span><br><span class="line">      compact_-&gt;sub_compact_states.<span class="built_in">emplace_back</span>(c, start, end, sizes_[i],</span><br><span class="line">                                                <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RecordInHistogram</span>(stats_, NUM_SUBCOMPACTIONS_SCHEDULED,</span><br><span class="line">                      compact_-&gt;sub_compact_states.<span class="built_in">size</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> Slice* start = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> Slice* end = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">uint64_t</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    compact_-&gt;sub_compact_states.<span class="built_in">emplace_back</span>(c, start, end, size,</span><br><span class="line">                                              <span class="comment">/*sub_job_id*/</span> <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>GenSubcompactionBoundaries</code>构造subcompaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompactionJob::GenSubcompactionBoundaries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* c = compact_-&gt;compaction;</span><br><span class="line">  <span class="keyword">auto</span>* cfd = c-&gt;<span class="built_in">column_family_data</span>();</span><br><span class="line">  <span class="type">const</span> Comparator* cfd_comparator = cfd-&gt;<span class="built_in">user_comparator</span>();</span><br><span class="line">  std::vector&lt;Slice&gt; bounds;</span><br><span class="line">  <span class="type">int</span> start_lvl = c-&gt;<span class="built_in">start_level</span>();</span><br><span class="line">  <span class="type">int</span> out_lvl = c-&gt;<span class="built_in">output_level</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the starting and/or ending key of certain input files as a potential</span></span><br><span class="line">  <span class="comment">// boundary</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> lvl_idx = <span class="number">0</span>; lvl_idx &lt; c-&gt;<span class="built_in">num_input_levels</span>(); lvl_idx++) &#123;</span><br><span class="line">    <span class="type">int</span> lvl = c-&gt;<span class="built_in">level</span>(lvl_idx);</span><br><span class="line">    <span class="keyword">if</span> (lvl &gt;= start_lvl &amp;&amp; lvl &lt;= out_lvl) &#123;</span><br><span class="line">      <span class="type">const</span> LevelFilesBrief* flevel = c-&gt;<span class="built_in">input_levels</span>(lvl_idx);</span><br><span class="line">      <span class="type">size_t</span> num_files = flevel-&gt;num_files;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num_files == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lvl == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// For level 0 add the starting and ending key of each file since the</span></span><br><span class="line">        <span class="comment">// files may have greatly differing key ranges (not range-partitioned)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">          bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[i].smallest_key);</span><br><span class="line">          bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[i].largest_key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For all other levels add the smallest/largest key in the level to</span></span><br><span class="line">        <span class="comment">// encompass the range covered by that level</span></span><br><span class="line">        bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[<span class="number">0</span>].smallest_key);</span><br><span class="line">        bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[num_files - <span class="number">1</span>].largest_key);</span><br><span class="line">        <span class="keyword">if</span> (lvl == out_lvl) &#123;</span><br><span class="line">          <span class="comment">// For the last level include the starting keys of all files since</span></span><br><span class="line">          <span class="comment">// the last level is the largest and probably has the widest key</span></span><br><span class="line">          <span class="comment">// range. Since it&#x27;s range partitioned, the ending key of one file</span></span><br><span class="line">          <span class="comment">// and the starting key of the next are very close (or identical).</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">            bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[i].smallest_key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(bounds.<span class="built_in">begin</span>(), bounds.<span class="built_in">end</span>(),</span><br><span class="line">            [cfd_comparator](<span class="type">const</span> Slice&amp; a, <span class="type">const</span> Slice&amp; b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> cfd_comparator-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(a),</span><br><span class="line">                                             <span class="built_in">ExtractUserKey</span>(b)) &lt; <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">  <span class="comment">// Remove duplicated entries from bounds</span></span><br><span class="line">  bounds.<span class="built_in">erase</span>(</span><br><span class="line">      std::<span class="built_in">unique</span>(bounds.<span class="built_in">begin</span>(), bounds.<span class="built_in">end</span>(),</span><br><span class="line">                  [cfd_comparator](<span class="type">const</span> Slice&amp; a, <span class="type">const</span> Slice&amp; b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cfd_comparator-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(a),</span><br><span class="line">                                                   <span class="built_in">ExtractUserKey</span>(b)) == <span class="number">0</span>;</span><br><span class="line">                  &#125;),</span><br><span class="line">      bounds.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Combine consecutive pairs of boundaries into ranges with an approximate</span></span><br><span class="line">  <span class="comment">// size of data covered by keys in that range</span></span><br><span class="line">  <span class="type">uint64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;RangeWithSize&gt; ranges;</span><br><span class="line">  <span class="comment">// Get input version from CompactionState since it&#x27;s already referenced</span></span><br><span class="line">  <span class="comment">// earlier in SetInputVersioCompaction::SetInputVersion and will not change</span></span><br><span class="line">  <span class="comment">// when db_mutex_ is released below</span></span><br><span class="line">  <span class="keyword">auto</span>* v = compact_-&gt;compaction-&gt;<span class="built_in">input_version</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = bounds.<span class="built_in">begin</span>();;) &#123;</span><br><span class="line">    <span class="type">const</span> Slice a = *it;</span><br><span class="line">    ++it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it == bounds.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Slice b = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApproximateSize could potentially create table reader iterator to seek</span></span><br><span class="line">    <span class="comment">// to the index block and may incur I/O cost in the process. Unlock db</span></span><br><span class="line">    <span class="comment">// mutex to reduce contention</span></span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="type">uint64_t</span> size = versions_-&gt;<span class="built_in">ApproximateSize</span>(<span class="built_in">SizeApproximationOptions</span>(), v, a,</span><br><span class="line">                                               b, start_lvl, out_lvl + <span class="number">1</span>,</span><br><span class="line">                                               TableReaderCaller::kCompaction);</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">    ranges.<span class="built_in">emplace_back</span>(a, b, size);</span><br><span class="line">    sum += size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Group the ranges into subcompactions</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> min_file_fill_percent = <span class="number">4.0</span> / <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> base_level = v-&gt;<span class="built_in">storage_info</span>()-&gt;<span class="built_in">base_level</span>();</span><br><span class="line">  <span class="type">uint64_t</span> max_output_files = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(std::<span class="built_in">ceil</span>(</span><br><span class="line">      sum / min_file_fill_percent /</span><br><span class="line">      <span class="built_in">MaxFileSizeForLevel</span>(</span><br><span class="line">          *(c-&gt;<span class="built_in">mutable_cf_options</span>()), out_lvl,</span><br><span class="line">          c-&gt;<span class="built_in">immutable_options</span>()-&gt;compaction_style, base_level,</span><br><span class="line">          c-&gt;<span class="built_in">immutable_options</span>()-&gt;level_compaction_dynamic_level_bytes)));</span><br><span class="line">  <span class="type">uint64_t</span> subcompactions =</span><br><span class="line">      std::<span class="built_in">min</span>(&#123;<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(ranges.<span class="built_in">size</span>()),</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(c-&gt;<span class="built_in">max_subcompactions</span>()),</span><br><span class="line">                max_output_files&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subcompactions &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">double</span> mean = sum * <span class="number">1.0</span> / subcompactions;</span><br><span class="line">    <span class="comment">// Greedily add ranges to the subcompaction until the sum of the ranges&#x27;</span></span><br><span class="line">    <span class="comment">// sizes becomes &gt;= the expected mean size of a subcompaction</span></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      sum += ranges[i].size;</span><br><span class="line">      <span class="keyword">if</span> (subcompactions == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s only one left to schedule then it goes to the end so no</span></span><br><span class="line">        <span class="comment">// need to put an end boundary</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &gt;= mean) &#123;</span><br><span class="line">        boundaries_.<span class="built_in">emplace_back</span>(<span class="built_in">ExtractUserKey</span>(ranges[i].range.limit));</span><br><span class="line">        sizes_.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">        subcompactions--;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sizes_.<span class="built_in">emplace_back</span>(sum + ranges.<span class="built_in">back</span>().size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Only one range so its size is the total sum of sizes computed above</span></span><br><span class="line">    sizes_.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历所有的需要compact的level,然后取得每一个level的边界(最大key和最小key)加入到bounds数组之中。</li><li>然后对获取到的bounds进行排序去重。</li><li>计算理想情况下所需要的subcompactions的个数以及输出文件的个数。</li><li>最后更新<code>boundaries_</code>，这里会根据文件的大小，通过平均的size,把所有的range分为几份，最终这些都会保存在<code>boundaries_</code>中。</li></ul></li></ul></li><li><p><code>Run</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CompactionJob::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_COMPACTION_RUN)</span></span>;</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;CompactionJob::Run():Start&quot;</span>);</span><br><span class="line">  log_buffer_-&gt;<span class="built_in">FlushBufferToLog</span>();</span><br><span class="line">  <span class="built_in">LogCompaction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> num_threads = compact_-&gt;sub_compact_states.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">assert</span>(num_threads &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> start_micros = db_options_.clock-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Launch a thread for each of subcompactions 1...num_threads-1</span></span><br><span class="line">  std::vector&lt;port::Thread&gt; thread_pool;</span><br><span class="line">  thread_pool.<span class="built_in">reserve</span>(num_threads - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; compact_-&gt;sub_compact_states.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    thread_pool.<span class="built_in">emplace_back</span>(&amp;CompactionJob::ProcessKeyValueCompaction, <span class="keyword">this</span>,</span><br><span class="line">                             &amp;compact_-&gt;sub_compact_states[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Always schedule the first subcompaction (whether or not there are also</span></span><br><span class="line">  <span class="comment">// others) in the current thread to be efficient with resources</span></span><br><span class="line">  <span class="built_in">ProcessKeyValueCompaction</span>(&amp;compact_-&gt;sub_compact_states[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for all other threads (if there are any) to finish execution</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : thread_pool) &#123;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compaction_stats_.micros = db_options_.clock-&gt;<span class="built_in">NowMicros</span>() - start_micros;</span><br><span class="line">  compaction_stats_.cpu_micros = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; compact_-&gt;sub_compact_states.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    compaction_stats_.cpu_micros +=</span><br><span class="line">        compact_-&gt;sub_compact_states[i].compaction_job_stats.cpu_micros;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RecordTimeToHistogram</span>(stats_, COMPACTION_TIME, compaction_stats_.micros);</span><br><span class="line">  <span class="built_in">RecordTimeToHistogram</span>(stats_, COMPACTION_CPU_TIME,</span><br><span class="line">                        compaction_stats_.cpu_micros);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;CompactionJob::Run:BeforeVerify&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if any thread encountered an error during execution</span></span><br><span class="line">  Status status;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line">  <span class="type">bool</span> wrote_new_blob_files = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      status = state.status;</span><br><span class="line">      io_s = state.io_status;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.blob_file_additions.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      wrote_new_blob_files = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (io_status_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    io_status_ = io_s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> IODebugContext* dbg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_directory_) &#123;</span><br><span class="line">      io_s = output_directory_-&gt;<span class="built_in">Fsync</span>(<span class="built_in">IOOptions</span>(), dbg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>() &amp;&amp; wrote_new_blob_files &amp;&amp; blob_output_directory_ &amp;&amp;</span><br><span class="line">        blob_output_directory_ != output_directory_) &#123;</span><br><span class="line">      io_s = blob_output_directory_-&gt;<span class="built_in">Fsync</span>(<span class="built_in">IOOptions</span>(), dbg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (io_status_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    io_status_ = io_s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = io_s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    thread_pool.<span class="built_in">clear</span>();</span><br><span class="line">    std::vector&lt;<span class="type">const</span> CompactionJob::SubcompactionState::Output*&gt; files_output;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : state.outputs) &#123;</span><br><span class="line">        files_output.<span class="built_in">emplace_back</span>(&amp;output);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ColumnFamilyData* cfd = compact_-&gt;compaction-&gt;<span class="built_in">column_family_data</span>();</span><br><span class="line">    <span class="keyword">auto</span> prefix_extractor =</span><br><span class="line">        compact_-&gt;compaction-&gt;<span class="built_in">mutable_cf_options</span>()-&gt;prefix_extractor.<span class="built_in">get</span>();</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">size_t</span>&gt; <span class="title">next_file_idx</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> verify_table = [&amp;](Status&amp; output_status) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> file_idx = next_file_idx.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (file_idx &gt;= files_output.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Verify that the table is usable</span></span><br><span class="line">        <span class="comment">// We set for_compaction to false and don&#x27;t OptimizeForCompactionTableRead</span></span><br><span class="line">        <span class="comment">// here because this is a special case after we finish the table building</span></span><br><span class="line">        <span class="comment">// No matter whether use_direct_io_for_flush_and_compaction is true,</span></span><br><span class="line">        <span class="comment">// we will regard this verification as user reads since the goal is</span></span><br><span class="line">        <span class="comment">// to cache it here for further user reads</span></span><br><span class="line">        ReadOptions read_options;</span><br><span class="line">        InternalIterator* iter = cfd-&gt;<span class="built_in">table_cache</span>()-&gt;<span class="built_in">NewIterator</span>(</span><br><span class="line">            read_options, file_options_, cfd-&gt;<span class="built_in">internal_comparator</span>(),</span><br><span class="line">            files_output[file_idx]-&gt;meta, <span class="comment">/*range_del_agg=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            prefix_extractor,</span><br><span class="line">            <span class="comment">/*table_reader_ptr=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            cfd-&gt;<span class="built_in">internal_stats</span>()-&gt;<span class="built_in">GetFileReadHist</span>(</span><br><span class="line">                compact_-&gt;compaction-&gt;<span class="built_in">output_level</span>()),</span><br><span class="line">            TableReaderCaller::kCompactionRefill, <span class="comment">/*arena=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            <span class="comment">/*skip_filters=*/</span><span class="literal">false</span>, compact_-&gt;compaction-&gt;<span class="built_in">output_level</span>(),</span><br><span class="line">            <span class="built_in">MaxFileSizeForL0MetaPin</span>(</span><br><span class="line">                *compact_-&gt;compaction-&gt;<span class="built_in">mutable_cf_options</span>()),</span><br><span class="line">            <span class="comment">/*smallest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            <span class="comment">/*largest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            <span class="comment">/*allow_unprepared_value=*/</span><span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">auto</span> s = iter-&gt;<span class="built_in">status</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; paranoid_file_checks_) &#123;</span><br><span class="line">          <span class="function">OutputValidator <span class="title">validator</span><span class="params">(cfd-&gt;internal_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="comment">/*_enable_order_check=*/</span><span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="comment">/*_enable_hash=*/</span><span class="literal">true</span>)</span></span>;</span><br><span class="line">          <span class="keyword">for</span> (iter-&gt;<span class="built_in">SeekToFirst</span>(); iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">            s = validator.<span class="built_in">Add</span>(iter-&gt;<span class="built_in">key</span>(), iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            s = iter-&gt;<span class="built_in">status</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp;</span><br><span class="line">              !validator.<span class="built_in">CompareValidator</span>(files_output[file_idx]-&gt;validator)) &#123;</span><br><span class="line">            s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Paranoid checksums do not match&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> iter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          output_status = s;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; compact_-&gt;sub_compact_states.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      thread_pool.<span class="built_in">emplace_back</span>(verify_table,</span><br><span class="line">                               std::<span class="built_in">ref</span>(compact_-&gt;sub_compact_states[i].status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">verify_table</span>(compact_-&gt;sub_compact_states[<span class="number">0</span>].status);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : thread_pool) &#123;</span><br><span class="line">      thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!state.status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        status = state.status;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TablePropertiesCollection tp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : state.outputs) &#123;</span><br><span class="line">      <span class="keyword">auto</span> fn =</span><br><span class="line">          <span class="built_in">TableFileName</span>(state.compaction-&gt;<span class="built_in">immutable_options</span>()-&gt;cf_paths,</span><br><span class="line">                        output.meta.fd.<span class="built_in">GetNumber</span>(), output.meta.fd.<span class="built_in">GetPathId</span>());</span><br><span class="line">      tp[fn] = output.table_properties;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  compact_-&gt;compaction-&gt;<span class="built_in">SetOutputTableProperties</span>(std::<span class="built_in">move</span>(tp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish up all book-keeping to unify the subcompaction results</span></span><br><span class="line">  <span class="built_in">AggregateStatistics</span>();</span><br><span class="line">  <span class="built_in">UpdateCompactionStats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RecordCompactionIOStats</span>();</span><br><span class="line">  <span class="built_in">LogFlush</span>(db_options_.info_log);</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;CompactionJob::Run():End&quot;</span>);</span><br><span class="line"></span><br><span class="line">  compact_-&gt;status = status;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历所有的sub_compact,然后启动线程来进行对应的compact工作，最后等到所有的线程完成，然后退出。</li><li>通过<code>ProcessKeyValueCompaction</code>拿到的sub_compact_states进行真正的compaction处理实际的key-value数据。</li></ul></li></ul><h2 id="process-keys"><a class="markdownIt-Anchor" href="#process-keys"></a> Process keys</h2><h3 id="构造能够访问所有key的迭代器"><a class="markdownIt-Anchor" href="#构造能够访问所有key的迭代器"></a> 构造能够访问所有key的迭代器</h3><p>首先进入到<code>ProcessKeyValueCompaction</code>函数中，通过之前步骤中填充的sub_compact数据取出对应的key-value数据，构造一个InternalIterator。这一部分主要做key之间的排序以及inernal key的merge操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;InternalIterator&gt; <span class="title">raw_input</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    versions_-&gt;MakeInputIterator(read_options, sub_compact-&gt;compaction,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 &amp;range_del_agg, file_options_for_read_))</span></span>;</span><br><span class="line">InternalIterator* input = raw_input.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><ul><li><p>构造的过程是通过函数<code>MakeInputIterator</code>进行的，我们进入到该函数，这个函数构造迭代器的逻辑同样区分level-0和level-其他。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InternalIterator* <span class="title">VersionSet::MakeInputIterator</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ReadOptions&amp; read_options, <span class="type">const</span> Compaction* c,</span></span></span><br><span class="line"><span class="params"><span class="function">    RangeDelAggregator* range_del_agg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FileOptions&amp; file_options_compactions)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> cfd = c-&gt;<span class="built_in">column_family_data</span>();</span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> space = (c-&gt;<span class="built_in">level</span>() == <span class="number">0</span> ? c-&gt;<span class="built_in">input_levels</span>(<span class="number">0</span>)-&gt;num_files +</span><br><span class="line">                                              c-&gt;<span class="built_in">num_input_levels</span>() - <span class="number">1</span></span><br><span class="line">                                        : c-&gt;<span class="built_in">num_input_levels</span>());</span><br><span class="line">  InternalIterator** list = <span class="keyword">new</span> InternalIterator* [space];</span><br><span class="line">  <span class="type">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> which = <span class="number">0</span>; which &lt; c-&gt;<span class="built_in">num_input_levels</span>(); which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;<span class="built_in">input_levels</span>(which)-&gt;num_files != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;<span class="built_in">level</span>(which) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> LevelFilesBrief* flevel = c-&gt;<span class="built_in">input_levels</span>(which);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; flevel-&gt;num_files; i++) &#123;</span><br><span class="line">          list[num++] = cfd-&gt;<span class="built_in">table_cache</span>()-&gt;<span class="built_in">NewIterator</span>(</span><br><span class="line">              read_options, file_options_compactions,</span><br><span class="line">              cfd-&gt;<span class="built_in">internal_comparator</span>(), *flevel-&gt;files[i].file_metadata,</span><br><span class="line">              range_del_agg, c-&gt;<span class="built_in">mutable_cf_options</span>()-&gt;prefix_extractor.<span class="built_in">get</span>(),</span><br><span class="line">              <span class="comment">/*table_reader_ptr=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*file_read_hist=*/</span><span class="literal">nullptr</span>, TableReaderCaller::kCompaction,</span><br><span class="line">              <span class="comment">/*arena=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*skip_filters=*/</span><span class="literal">false</span>,</span><br><span class="line">              <span class="comment">/*level=*/</span><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c-&gt;<span class="built_in">level</span>(which)),</span><br><span class="line">              <span class="built_in">MaxFileSizeForL0MetaPin</span>(*c-&gt;<span class="built_in">mutable_cf_options</span>()),</span><br><span class="line">              <span class="comment">/*smallest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*largest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*allow_unprepared_value=*/</span><span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        list[num++] = <span class="keyword">new</span> <span class="built_in">LevelIterator</span>(</span><br><span class="line">            cfd-&gt;<span class="built_in">table_cache</span>(), read_options, file_options_compactions,</span><br><span class="line">            cfd-&gt;<span class="built_in">internal_comparator</span>(), c-&gt;<span class="built_in">input_levels</span>(which),</span><br><span class="line">            c-&gt;<span class="built_in">mutable_cf_options</span>()-&gt;prefix_extractor.<span class="built_in">get</span>(),</span><br><span class="line">            <span class="comment">/*should_sample=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*no per level latency histogram=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            TableReaderCaller::kCompaction, <span class="comment">/*skip_filters=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*level=*/</span><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c-&gt;<span class="built_in">level</span>(which)), range_del_agg,</span><br><span class="line">            c-&gt;<span class="built_in">boundaries</span>(which));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(num &lt;= space);</span><br><span class="line">  InternalIterator* result =</span><br><span class="line">      <span class="built_in">NewMergingIterator</span>(&amp;c-&gt;<span class="built_in">column_family_data</span>()-&gt;<span class="built_in">internal_comparator</span>(), list,</span><br><span class="line">                         <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">  <span class="keyword">delete</span>[] list;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先获取当前sub_compact所属的cfd。</p></li><li><p>针对level-0,为其中的每一个sst文件构建一个table_cache迭代器，放入list中。</p></li><li><p>针对其他非level-0的层，每一层直接创建一个级联的迭代器并放入list中。也就是这个迭代器从它的start就能够顺序访问到该层最后一个sst文件的最后一个key。</p></li><li><p>将所有层的迭代器添加到一个迭代器数组list中，通过<code>NewMergingIterator</code>迭代器维护一个底层的排序堆结构，完成所有层之间的key-value的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InternalIterator* <span class="title">NewMergingIterator</span><span class="params">(<span class="type">const</span> InternalKeyComparator* cmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     InternalIterator** list, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     Arena* arena, <span class="type">bool</span> prefix_seek_mode)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewEmptyInternalIterator</span>&lt;Slice&gt;(arena);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arena == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MergingIterator</span>(cmp, list, n, <span class="literal">false</span>, prefix_seek_mode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> mem = arena-&gt;<span class="built_in">AllocateAligned</span>(<span class="built_in">sizeof</span>(MergingIterator));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">new</span> (mem) <span class="built_in">MergingIterator</span>(cmp, list, n, <span class="literal">true</span>, prefix_seek_mode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果list是空的，则直接返回空。</p></li><li><p>如果只有一个，那么认为这个迭代器本身就是有序的，不需要构建一个堆排序的迭代器（level-0的sst内部是有序的，之前创建的时候是为level-0每一个sst创建一个list元素；非level-0的整层都是有序的）。</p></li><li><p>如果有多个，那么直接通过<code>MergingIterator</code>来创建堆排序的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MergingIterator</span>(<span class="type">const</span> InternalKeyComparator* comparator,</span><br><span class="line">                  InternalIterator** children, <span class="type">int</span> n, <span class="type">bool</span> is_arena_mode,</span><br><span class="line">                  <span class="type">bool</span> prefix_seek_mode)</span><br><span class="line">      : <span class="built_in">is_arena_mode_</span>(is_arena_mode),</span><br><span class="line">        <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">current_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">        <span class="built_in">direction_</span>(kForward),</span><br><span class="line">        <span class="built_in">minHeap_</span>(comparator_),</span><br><span class="line">        <span class="built_in">prefix_seek_mode_</span>(prefix_seek_mode),</span><br><span class="line">        <span class="built_in">pinned_iters_mgr_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    children_.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Set</span>(children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; child : children_) &#123;</span><br><span class="line">      <span class="built_in">AddToMinHeapOrCheckStatus</span>(&amp;child);</span><br><span class="line">    &#125;</span><br><span class="line">    current_ = <span class="built_in">CurrentForward</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过将传入的list也就是函数中的children中的所有元素添加到一个vector中，再遍历其中的每一个key-value，通过函数 <code>AddToMinHeapOrCheckStatus</code>构造底层结构堆，堆中的元素顺序是由用户参数<code>option.comparator</code>指定，默认是BytewiseComparator支持的lexicographical order，也就是字典顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergingIterator::AddToMinHeapOrCheckStatus</span><span class="params">(IteratorWrapper* child)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(child-&gt;<span class="built_in">status</span>().<span class="built_in">ok</span>());</span><br><span class="line">    minHeap_.<span class="built_in">push</span>(child);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">considerStatus</span>(child-&gt;<span class="built_in">status</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="通过seektofirst和next指针处理元素"><a class="markdownIt-Anchor" href="#通过seektofirst和next指针处理元素"></a> 通过SeekToFirst和Next指针处理元素</h3><p>回到<code>ProcessKeyValueCompaction</code>函数,使用构造好的internalIterator再构造一个包含所有状态的CompactionIterator，直接初始化就可以，构造完成需要将CompactionIterator的内部指针放在整个迭代器最开始的部位，通过Next指针来获取下一个key-value，同时还需要需要在每次迭代器元素内部移动的时候除了调整底层堆中的字典序结构之外，还兼顾处理各个不同type的key数据，将kValueType，kTypeDeletion，kTypeSingleDeletion，kValueDeleteRange,kTypeMerge 等不同的key type处理完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c_iter-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">while</span> (status.<span class="built_in">ok</span>() &amp;&amp; !cfd-&gt;<span class="built_in">IsDropped</span>() &amp;&amp; c_iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">  <span class="comment">// Invariant: c_iter.status() is guaranteed to be OK if c_iter-&gt;Valid()</span></span><br><span class="line">  <span class="comment">// returns true.</span></span><br><span class="line">  <span class="type">const</span> Slice&amp; key = c_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">  <span class="type">const</span> Slice&amp; value = c_iter-&gt;<span class="built_in">value</span>();</span><br><span class="line">  ......</span><br><span class="line">  c_iter-&gt;<span class="built_in">Next</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="write-keys"><a class="markdownIt-Anchor" href="#write-keys"></a> Write keys</h2><p>这一步也在<code>ProcessKeyValueCompaction</code>函数中，将key-value写入SST文件中。</p><ul><li><p>确认key 的valueType类型，如果是data_block或者index_block类型，则放入builder状态机中</p></li><li><p>优先创建filter_buiilder和index_builder，index builer创建成 分层格式(两层index leve, 第一层多个restart点，用来索引具体的datablock；第二层索引第一层的index block)，方便加载到内存进行二分查找，节约内存消耗，加速查找；其次再写data_block_builder</p></li><li><p>如果key的 valueType类型是 range_deletion，则加入到range_delete_block_builder之中</p></li><li><p>先将data_block builder 利用绑定的输出的文件的writer写入底层文件</p></li><li><p>将filter_block / index_builder / compress_builder/range_del_builder/properties_builder 按照对应的格式加入到 meta_data_builder之中，利用绑定ouput 文件的 writer写入底层存储</p></li><li><p>利用meta_data_handle 和 index_handle 封装footer,写入底层存储</p></li></ul><h3 id="将builder与输出文件的writer绑定"><a class="markdownIt-Anchor" href="#将builder与输出文件的writer绑定"></a> 将builder与输出文件的writer绑定</h3><p>默认的blockbase table SST文件有很多不同的block，除了data block之外，其他的block都是需要先写入到一个临时的数据结构builder，然后由builder通过其绑定的output文件的writer写入到底层磁盘形成磁盘的sst文件结构。</p><p>这里的逻辑就是将builder与output文件的writer进行绑定，创建好table builder。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open output file if necessary</span></span><br><span class="line"><span class="keyword">if</span> (sub_compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = <span class="built_in">OpenCompactionOutputFile</span>(sub_compact);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过table_builder的状态机添加block数据"><a class="markdownIt-Anchor" href="#通过table_builder的状态机添加block数据"></a> 通过table_builder的状态机添加block数据</h3><p>然后调用<code>builder-&gt;Add</code>函数构造对应的builder结构，添加的过程主要是通过拥有三个状态的状态机完成不同block的builder创建，状态机是由构造tablebuilder的时候创建的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status = sub_compact-&gt;<span class="built_in">AddToBuilder</span>(key, value);</span><br><span class="line"><span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">AddToBuilder</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> curr = <span class="built_in">current_output</span>();</span><br><span class="line">    <span class="built_in">assert</span>(builder != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">assert</span>(curr != <span class="literal">nullptr</span>);</span><br><span class="line">    Status s = curr-&gt;validator.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  ValueType value_type = <span class="built_in">ExtractValueType</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsValueType</span>(value_type)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;props.num_entries &gt; r-&gt;props.num_range_deletions) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(r-&gt;internal_comparator.<span class="built_in">Compare</span>(key, <span class="built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !NDEBUG</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;<span class="built_in">Update</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      <span class="built_in">Flush</span>();</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">        <span class="type">bool</span> exceeds_buffer_limit =</span><br><span class="line">            (r-&gt;buffer_limit != <span class="number">0</span> &amp;&amp; r-&gt;data_begin_offset &gt; r-&gt;buffer_limit);</span><br><span class="line">        <span class="type">bool</span> is_cache_full = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase cache reservation for the last buffered data block</span></span><br><span class="line">        <span class="comment">// only if the block is not going to be unbuffered immediately</span></span><br><span class="line">        <span class="comment">// and there exists a cache reservation manager</span></span><br><span class="line">        <span class="keyword">if</span> (!exceeds_buffer_limit &amp;&amp; r-&gt;cache_rev_mng != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          Status s = r-&gt;cache_rev_mng-&gt;<span class="built_in">UpdateCacheReservation</span>&lt;</span><br><span class="line">              CacheEntryRole::kCompressionDictionaryBuildingBuffer&gt;(</span><br><span class="line">              r-&gt;data_begin_offset);</span><br><span class="line">          is_cache_full = s.<span class="built_in">IsIncomplete</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exceeds_buffer_limit || is_cache_full) &#123;</span><br><span class="line">          <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add item to index block.</span></span><br><span class="line">      <span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line">      <span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line">      <span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line">      <span class="comment">// between the keys &quot;the quick brown fox&quot; and &quot;the who&quot;.  We can use</span></span><br><span class="line">      <span class="comment">// &quot;the r&quot; as the key for the index block entry since it is &gt;= all</span></span><br><span class="line">      <span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line">      <span class="comment">// blocks.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: PartitionedFilterBlockBuilder requires key being added to filter</span></span><br><span class="line">    <span class="comment">// builder after being added to index builder.</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">PushBack</span>(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">      <span class="comment">// Buffered keys will be replayed from data_block_buffers during</span></span><br><span class="line">      <span class="comment">// `Finish()` once compression dictionary has been finalized.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO offset passed in is not accurate for parallel compression case</span></span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;range_del_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="comment">// TODO offset passed in is not accurate for parallel compression case</span></span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r-&gt;props.num_entries++;</span><br><span class="line">  r-&gt;props.raw_key_size += key.<span class="built_in">size</span>();</span><br><span class="line">  r-&gt;props.raw_value_size += value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (value_type == kTypeDeletion || value_type == kTypeSingleDeletion) &#123;</span><br><span class="line">    r-&gt;props.num_deletions++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;props.num_deletions++;</span><br><span class="line">    r-&gt;props.num_range_deletions++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeMerge) &#123;</span><br><span class="line">    r-&gt;props.num_merge_operands++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>kBuffered</strong>为状态机的初始状态。处于这个状态的时候，内存有较多缓存的未压缩的datablock。在该状态的过程中，通过 EnterUnbuffered 函数构造compression block，依此构建对应的index block和filterblock。最终将状态置为下一个状态的：kUnbuffered。</li><li><strong>kUnbuffered</strong>这个状态时，compressing block已经通过之前的buffer中的data初步构造完成，且接下来将在这个状态通过 Finish 完成各个block的写入 或者通过 Abandon 丢弃当前的写入。</li><li><strong>kClosed</strong>这个状态之前已经完成了table builder的finish或者abandon，那么接下来将析构当前的table builder。</li></ul><p>对于第一个状态，进入下面的逻辑。如果data block能够满足flush的条件，则直接flush datablock的数据到当前bulider对应的datablock存储结构中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;<span class="built_in">Update</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      <span class="built_in">Flush</span>();</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">        <span class="type">bool</span> exceeds_buffer_limit =</span><br><span class="line">            (r-&gt;buffer_limit != <span class="number">0</span> &amp;&amp; r-&gt;data_begin_offset &gt; r-&gt;buffer_limit);</span><br><span class="line">        <span class="type">bool</span> is_cache_full = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase cache reservation for the last buffered data block</span></span><br><span class="line">        <span class="comment">// only if the block is not going to be unbuffered immediately</span></span><br><span class="line">        <span class="comment">// and there exists a cache reservation manager</span></span><br><span class="line">        <span class="keyword">if</span> (!exceeds_buffer_limit &amp;&amp; r-&gt;cache_rev_mng != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          Status s = r-&gt;cache_rev_mng-&gt;<span class="built_in">UpdateCacheReservation</span>&lt;</span><br><span class="line">              CacheEntryRole::kCompressionDictionaryBuildingBuffer&gt;(</span><br><span class="line">              r-&gt;data_begin_offset);</span><br><span class="line">          is_cache_full = s.<span class="built_in">IsIncomplete</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exceeds_buffer_limit || is_cache_full) &#123;</span><br><span class="line">          <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add item to index block.</span></span><br><span class="line">      <span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line">      <span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line">      <span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line">      <span class="comment">// between the keys &quot;the quick brown fox&quot; and &quot;the who&quot;.  We can use</span></span><br><span class="line">      <span class="comment">// &quot;the r&quot; as the key for the index block entry since it is &gt;= all</span></span><br><span class="line">      <span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line">      <span class="comment">// blocks.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>EnterUnbuffered</code>函数主要逻辑是构造compression block，如果我们开启了compression的选项则会构造。</p><p>同时依据之前flush添加到datablock中的数据来构造index block和filter block，用来索引datablock的数据。选择在这里构造的话主要还是因为flush的时候表示一个完整的datablock已经写入完成，这里需要通过一个完整的datablock数据才有必要构造一条indexblock的数据。</p><p>其中data_block_and_keys_buffers数组存放的是未经过压缩的datablock数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; <span class="built_in">ok</span>() &amp;&amp; i &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter = <span class="built_in">get_iterator_for_block</span>(i);</span><br><span class="line">      <span class="built_in">assert</span>(iter != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      next_block_iter = <span class="built_in">get_iterator_for_block</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">      Slice first_key_in_next_block;</span><br><span class="line">      <span class="type">const</span> Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first_key_in_next_block_ptr = r-&gt;first_key_in_next_block;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      std::vector&lt;std::string&gt; keys;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        keys.<span class="built_in">emplace_back</span>(iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">          r-&gt;compression_type, first_key_in_next_block_ptr, &amp;data_block, &amp;keys);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">      r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        Slice key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(<span class="built_in">Slice</span>(data_block), &amp;r-&gt;pending_handle, BlockType::kData);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        Slice first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line"></span><br><span class="line">        Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line"></span><br><span class="line">        iter-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">        std::string last_key = iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>();</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;last_key, first_key_in_next_block_ptr,</span><br><span class="line">                                        r-&gt;pending_handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>EnterUnbuffered</code>函数中创建index block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (table_options.index_type ==</span><br><span class="line">    BlockBasedTableOptions::kTwoLevelIndexSearch) &#123;</span><br><span class="line">  p_index_builder_ = PartitionedIndexBuilder::<span class="built_in">CreateIndexBuilder</span>(</span><br><span class="line">      &amp;internal_comparator, use_delta_encoding_for_index_values,</span><br><span class="line">      table_options);</span><br><span class="line">  index_builder.<span class="built_in">reset</span>(p_index_builder_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  index_builder.<span class="built_in">reset</span>(IndexBuilder::<span class="built_in">CreateIndexBuilder</span>(</span><br><span class="line">      table_options.index_type, &amp;internal_comparator,</span><br><span class="line">      &amp;<span class="keyword">this</span>-&gt;internal_prefix_transform, use_delta_encoding_for_index_values,</span><br><span class="line">      table_options));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>ProcessKeyValueCompaction</code>中的while循环中，不断遍历迭代器中的key，将其添加到对应的datablock，并完善indeblock和filter block，以及compression block。</p><h3 id="通过构建的meta_index_builder和footer完成数据的固化"><a class="markdownIt-Anchor" href="#通过构建的meta_index_builder和footer完成数据的固化"></a> 通过构建的meta_index_builder和Footer完成数据的固化</h3><p>接下来将通过<code>FinishCompactionOutputFil</code>对之前添加的builder数据进行整合，处理一些delete range的block以及更新当前compaction的边界。<br />这个函数调用是当之前累计的builder中block数据的大小达到可以写入的sst文件本身的大小max_output_file_size，会触发当前函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close output file if it is big enough. Two possibilities determine it&#x27;s</span></span><br><span class="line">    <span class="comment">// time to close it: (1) the current key should be this file&#x27;s last key, (2)</span></span><br><span class="line">    <span class="comment">// the next key should not be in this file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// TODO(aekmekji): determine if file should be closed earlier than this</span></span><br><span class="line">    <span class="comment">// during subcompactions (i.e. if output size, estimated by input size, is</span></span><br><span class="line">    <span class="comment">// going to be 1.2MB and max_output_file_size = 1MB, prefer to have 0.6MB</span></span><br><span class="line">    <span class="comment">// and 0.6MB instead of 1MB and 0.2MB)</span></span><br><span class="line">    <span class="type">bool</span> output_file_ended = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (sub_compact-&gt;compaction-&gt;<span class="built_in">output_level</span>() != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        sub_compact-&gt;current_output_file_size &gt;=</span><br><span class="line">            sub_compact-&gt;compaction-&gt;<span class="built_in">max_output_file_size</span>()) &#123;</span><br><span class="line">      <span class="comment">// (1) this key terminates the file. For historical reasons, the iterator</span></span><br><span class="line">      <span class="comment">// status before advancing will be given to FinishCompactionOutputFile().</span></span><br><span class="line">      output_file_ended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(</span><br><span class="line">        <span class="string">&quot;CompactionJob::Run():PausingManualCompaction:2&quot;</span>,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;std::atomic&lt;<span class="type">int</span>&gt;*&gt;(manual_compaction_paused_)));</span><br><span class="line">    <span class="keyword">if</span> (partitioner.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      last_key_for_partitioner.<span class="built_in">assign</span>(c_iter-&gt;<span class="built_in">user_key</span>().data_,</span><br><span class="line">                                      c_iter-&gt;<span class="built_in">user_key</span>().size_);</span><br><span class="line">    &#125;</span><br><span class="line">    c_iter-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="keyword">if</span> (c_iter-&gt;<span class="built_in">status</span>().<span class="built_in">IsManualCompactionPaused</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!output_file_ended &amp;&amp; c_iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (((partitioner.<span class="built_in">get</span>() &amp;&amp;</span><br><span class="line">            partitioner-&gt;<span class="built_in">ShouldPartition</span>(<span class="built_in">PartitionerRequest</span>(</span><br><span class="line">                last_key_for_partitioner, c_iter-&gt;<span class="built_in">user_key</span>(),</span><br><span class="line">                sub_compact-&gt;current_output_file_size)) == kRequired) ||</span><br><span class="line">           (sub_compact-&gt;compaction-&gt;<span class="built_in">output_level</span>() != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            sub_compact-&gt;<span class="built_in">ShouldStopBefore</span>(</span><br><span class="line">                c_iter-&gt;<span class="built_in">key</span>(), sub_compact-&gt;current_output_file_size))) &amp;&amp;</span><br><span class="line">          sub_compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// (2) this key belongs to the next file. For historical reasons, the</span></span><br><span class="line">        <span class="comment">// iterator status after advancing will be given to</span></span><br><span class="line">        <span class="comment">// FinishCompactionOutputFile().</span></span><br><span class="line">        output_file_ended = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (output_file_ended) &#123;</span><br><span class="line">      <span class="type">const</span> Slice* next_key = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (c_iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">        next_key = &amp;c_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      CompactionIterationStats range_del_out_stats;</span><br><span class="line">      status = <span class="built_in">FinishCompactionOutputFile</span>(input-&gt;<span class="built_in">status</span>(), sub_compact,</span><br><span class="line">                                          &amp;range_del_agg, &amp;range_del_out_stats,</span><br><span class="line">                                          next_key);</span><br><span class="line">      <span class="built_in">RecordDroppedKeys</span>(range_del_out_stats,</span><br><span class="line">                        &amp;sub_compact-&gt;compaction_job_stats);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FinishCompactionOutputFile</code>函数内部最终调用s=sub_compact-&gt;builder-&gt;Finish()完成所有数据的固化写入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BlockBasedTableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="type">bool</span> empty_data_block = r-&gt;data_block.<span class="built_in">empty</span>();</span><br><span class="line">  r-&gt;first_key_in_next_block = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StopParallelCompression</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; br : r-&gt;pc_rep-&gt;block_rep_buf) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(br.status.<span class="built_in">ok</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !NDEBUG</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// To make sure properties block is able to keep the accurate size of index</span></span><br><span class="line">    <span class="comment">// block, we will finish writing all index entries first.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_data_block) &#123;</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(</span><br><span class="line">          &amp;r-&gt;last_key, <span class="literal">nullptr</span> <span class="comment">/* no next data block */</span>, r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write meta blocks, metaindex block and footer in the following order.</span></span><br><span class="line">  <span class="comment">//    1. [meta block: filter]</span></span><br><span class="line">  <span class="comment">//    2. [meta block: index]</span></span><br><span class="line">  <span class="comment">//    3. [meta block: compression dictionary]</span></span><br><span class="line">  <span class="comment">//    4. [meta block: range deletion tombstone]</span></span><br><span class="line">  <span class="comment">//    5. [meta block: properties]</span></span><br><span class="line">  <span class="comment">//    6. [metaindex block]</span></span><br><span class="line">  <span class="comment">//    7. Footer</span></span><br><span class="line">  BlockHandle metaindex_block_handle, index_block_handle;</span><br><span class="line">  MetaIndexBuilder meta_index_builder;</span><br><span class="line">  <span class="built_in">WriteFilterBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteIndexBlock</span>(&amp;meta_index_builder, &amp;index_block_handle);</span><br><span class="line">  <span class="built_in">WriteCompressionDictBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteRangeDelBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WritePropertiesBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// flush the meta index block</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(meta_index_builder.<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                  &amp;metaindex_block_handle, BlockType::kMetaIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">WriteFooter</span>(metaindex_block_handle, index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;state = Rep::State::kClosed;</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(r-&gt;<span class="built_in">CopyIOStatus</span>());</span><br><span class="line">  Status ret_status = r-&gt;<span class="built_in">CopyStatus</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!ret_status.<span class="built_in">ok</span>() || <span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="keyword">return</span> ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="compaction参数设置"><a class="markdownIt-Anchor" href="#compaction参数设置"></a> Compaction参数设置</h2><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td><code>write_buffer_size</code></td><td>限定Memtable的大小</td><td>64MB</td></tr><tr><td><code>level0_file_num_compaction_trigger</code></td><td>限定Level 0层的文件数量</td><td>4</td></tr><tr><td><code>target_file_size_base</code></td><td>每一层单个目标文件的大小</td><td>64MB</td></tr><tr><td><code>target_file_size_multiplier</code></td><td>每一层单个目标文件的乘法因子</td><td>1</td></tr><tr><td><code>max_bytes_for_level_base</code></td><td>每一层所有文件的大小</td><td>256MB</td></tr><tr><td><code>max_bytes_for_level_multiplier</code></td><td>每一层所有文件的乘法因子</td><td>10</td></tr><tr><td><code>level_compaction_dynamic_level_bytes</code></td><td>是否将Compact的策略改为层级从下往上应用</td><td>False</td></tr><tr><td><code>num_levels</code></td><td>LSM的层级数量</td><td>7</td></tr></tbody></table><ul><li><p>参数<code>target_file_size_base</code>和<code>target_file_size_multiplier</code>用来限定Compact之后的每一层的单个文件大小。<code>target_file_size_base</code>是Level-1中每个文件的大小，Level N层可以用<code>target_file_size_base * target_file_size_multiplier ^ (L -1)</code> 计算。<code>target_file_size_base</code> 默认为64MB，<code>target_file_size_multiplier</code>默认为1。</p></li><li><p>参数<code>max_bytes_for_level_base</code>和<code>max_bytes_for_level_multiplier</code>用来限定每一层所有文件的限定大小。 <code>max_bytes_for_level_base</code>是Level-1层的所有文件的限定大小。Level N层的所有文件的限定大小可以用 <code>(max_bytes_for_level_base) * (max_bytes_for_level_multiplier ^ (L-1))</code>计算。<code>max_bytes_for_level_base</code>的默认为256MB，<code>max_bytes_for_level_multiplier</code>默认为10。</p></li><li><p>参数<code>level_compaction_dynamic_level_bytes</code>用来指示Compact的策略改为层级从下往上应用。<code>Target_Size(Ln-1) = Target_Size(Ln) / max_bytes_for_level_multiplier</code>来限定大小：假如 <code>max_bytes_for_level_base</code>是 1GB, <code>num_levels</code>设为6。最底层的实际容量是276GB, 所以L1-L6层的大小分别是 0, 0, 0.276GB, 2.76GB, 27.6GB and 276GB。</p></li><li><p>MutableDBOptions</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MutableDBOptions</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">kName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MutableDBOptions&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">MutableDBOptions</span>();</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutableDBOptions</span><span class="params">(<span class="type">const</span> MutableDBOptions&amp; options)</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutableDBOptions</span><span class="params">(<span class="type">const</span> DBOptions&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Dump</span><span class="params">(Logger* log)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> max_background_jobs;</span><br><span class="line">  <span class="type">int</span> base_background_compactions;</span><br><span class="line">  <span class="type">int</span> max_background_compactions;</span><br><span class="line">  <span class="type">uint32_t</span> max_subcompactions;</span><br><span class="line">  <span class="type">bool</span> avoid_flush_during_shutdown;</span><br><span class="line">  <span class="type">size_t</span> writable_file_max_buffer_size;</span><br><span class="line">  <span class="type">uint64_t</span> delayed_write_rate;</span><br><span class="line">  <span class="type">uint64_t</span> max_total_wal_size;</span><br><span class="line">  <span class="type">uint64_t</span> delete_obsolete_files_period_micros;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stats_dump_period_sec;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stats_persist_period_sec;</span><br><span class="line">  <span class="type">size_t</span> stats_history_buffer_size;</span><br><span class="line">  <span class="type">int</span> max_open_files;</span><br><span class="line">  <span class="type">uint64_t</span> bytes_per_sync;</span><br><span class="line">  <span class="type">uint64_t</span> wal_bytes_per_sync;</span><br><span class="line">  <span class="type">bool</span> strict_bytes_per_sync;</span><br><span class="line">  <span class="type">size_t</span> compaction_readahead_size;</span><br><span class="line">  <span class="type">int</span> max_background_flushes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>mutable_cf_options_</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MutableCFOptions</span><span class="params">(<span class="type">const</span> ColumnFamilyOptions&amp; options)</span></span></span><br><span class="line"><span class="function">      : write_buffer_size(options.write_buffer_size),</span></span><br><span class="line"><span class="function">        max_write_buffer_number(options.max_write_buffer_number),</span></span><br><span class="line"><span class="function">        arena_block_size(options.arena_block_size),</span></span><br><span class="line"><span class="function">        memtable_prefix_bloom_size_ratio(</span></span><br><span class="line"><span class="function">            options.memtable_prefix_bloom_size_ratio),</span></span><br><span class="line"><span class="function">        memtable_whole_key_filtering(options.memtable_whole_key_filtering),</span></span><br><span class="line"><span class="function">        memtable_huge_page_size(options.memtable_huge_page_size),</span></span><br><span class="line"><span class="function">        max_successive_merges(options.max_successive_merges),</span></span><br><span class="line"><span class="function">        inplace_update_num_locks(options.inplace_update_num_locks),</span></span><br><span class="line"><span class="function">        prefix_extractor(options.prefix_extractor),</span></span><br><span class="line"><span class="function">        disable_auto_compactions(options.disable_auto_compactions),</span></span><br><span class="line"><span class="function">        soft_pending_compaction_bytes_limit(</span></span><br><span class="line"><span class="function">            options.soft_pending_compaction_bytes_limit),</span></span><br><span class="line"><span class="function">        hard_pending_compaction_bytes_limit(</span></span><br><span class="line"><span class="function">            options.hard_pending_compaction_bytes_limit),</span></span><br><span class="line"><span class="function">        level0_file_num_compaction_trigger(</span></span><br><span class="line"><span class="function">            options.level0_file_num_compaction_trigger),</span></span><br><span class="line"><span class="function">        level0_slowdown_writes_trigger(options.level0_slowdown_writes_trigger),</span></span><br><span class="line"><span class="function">        level0_stop_writes_trigger(options.level0_stop_writes_trigger),</span></span><br><span class="line"><span class="function">        max_compaction_bytes(options.max_compaction_bytes),</span></span><br><span class="line"><span class="function">        target_file_size_base(options.target_file_size_base),</span></span><br><span class="line"><span class="function">        target_file_size_multiplier(options.target_file_size_multiplier),</span></span><br><span class="line"><span class="function">        max_bytes_for_level_base(options.max_bytes_for_level_base),</span></span><br><span class="line"><span class="function">        max_bytes_for_level_multiplier(options.max_bytes_for_level_multiplier),</span></span><br><span class="line"><span class="function">        ttl(options.ttl),</span></span><br><span class="line"><span class="function">        periodic_compaction_seconds(options.periodic_compaction_seconds),</span></span><br><span class="line"><span class="function">        max_bytes_for_level_multiplier_additional(</span></span><br><span class="line"><span class="function">            options.max_bytes_for_level_multiplier_additional),</span></span><br><span class="line"><span class="function">        compaction_options_fifo(options.compaction_options_fifo),</span></span><br><span class="line"><span class="function">        compaction_options_universal(options.compaction_options_universal),</span></span><br><span class="line"><span class="function">        enable_blob_files(options.enable_blob_files),</span></span><br><span class="line"><span class="function">        min_blob_size(options.min_blob_size),</span></span><br><span class="line"><span class="function">        blob_file_size(options.blob_file_size),</span></span><br><span class="line"><span class="function">        blob_compression_type(options.blob_compression_type),</span></span><br><span class="line"><span class="function">        enable_blob_garbage_collection(options.enable_blob_garbage_collection),</span></span><br><span class="line"><span class="function">        blob_garbage_collection_age_cutoff(</span></span><br><span class="line"><span class="function">            options.blob_garbage_collection_age_cutoff),</span></span><br><span class="line"><span class="function">        max_sequential_skip_in_iterations(</span></span><br><span class="line"><span class="function">            options.max_sequential_skip_in_iterations),</span></span><br><span class="line"><span class="function">        check_flush_compaction_key_order(</span></span><br><span class="line"><span class="function">            options.check_flush_compaction_key_order),</span></span><br><span class="line"><span class="function">        paranoid_file_checks(options.paranoid_file_checks),</span></span><br><span class="line"><span class="function">        report_bg_io_stats(options.report_bg_io_stats),</span></span><br><span class="line"><span class="function">        compression(options.compression),</span></span><br><span class="line"><span class="function">        bottommost_compression(options.bottommost_compression),</span></span><br><span class="line"><span class="function">        compression_opts(options.compression_opts),</span></span><br><span class="line"><span class="function">        bottommost_compression_opts(options.bottommost_compression_opts),</span></span><br><span class="line"><span class="function">        bottommost_temperature(options.bottommost_temperature),</span></span><br><span class="line"><span class="function">        sample_for_compression(</span></span><br><span class="line"><span class="function">            options.sample_for_compression) &#123;</span>  <span class="comment">// <span class="doctag">TODO:</span> is 0 fine here?</span></span><br><span class="line">    <span class="built_in">RefreshDerivedOptions</span>(options.num_levels, options.compaction_style);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="some-concepts"><a class="markdownIt-Anchor" href="#some-concepts"></a> Some Concepts</h2><ul><li><strong>Slice</strong> is a simple structure containing a pointer into some external storage and a size.</li><li><strong>parents</strong> &amp;&amp; <strong>grandparents</strong>: parent=level+1 grandparent==level+2</li><li><strong>column family</strong>(cfd)</li><li><strong>compaction filter</strong></li><li><strong>compression</strong></li><li><strong>sst file maneger</strong>(sfm)</li><li><strong>background</strong>(bg)</li></ul><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://github.com/facebook/rocksdb/wiki/Compaction">RocksDB Compaction Wiki</a></li><li><a href="https://blog.csdn.net/Z_Stand/article/details/106959058">Rocksdb Compaction 源码详解（一）：SST文件详细格式源码解析</a></li><li><a href="https://vigourtyy-zhg.blog.csdn.net/article/details/107592966?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.no_search_link?%7C">Rocksdb Compaction源码详解（二）：Compaction 完整实现过程 概览</a></li><li><a href="http://rocksdb.org/blog/2015/07/23/dynamic-level.html">Dynamic Level Size for Level-Based Compaction</a></li><li><a href="https://blog.csdn.net/weixin_31951239/article/details/113019578">通过base level减少space amplification</a></li><li><a href="https://www.leviathan.vip/2018/03/05/Rocksdb%E7%9A%84Compact/">RocksDB的Compact</a></li><li><a href="http://rocksdb.org/blog/2016/01/29/compaction_pri.html">compaction_pri</a></li><li><a href="https://github.com/facebook/rocksdb/wiki/Compaction-Filter">compaction filter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;  RocksDB的Compaction过程整体可分为三个部分，prepare keys、process keys、write keys。&lt;/p&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    <category term="KV store" scheme="https://tongyiheng.top/categories/Embedded/KV-store/"/>
    
    
    <category term="RocksDB" scheme="https://tongyiheng.top/tags/RocksDB/"/>
    
    <category term="cpp" scheme="https://tongyiheng.top/tags/cpp/"/>
    
    <category term="compaction" scheme="https://tongyiheng.top/tags/compaction/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Buffer Pool Design</title>
    <link href="https://tongyiheng.top/2021/09/07/Embedded/mysql-buffer-pool-design/"/>
    <id>https://tongyiheng.top/2021/09/07/Embedded/mysql-buffer-pool-design/</id>
    <published>2021-09-07T13:00:00.000Z</published>
    <updated>2021-10-20T14:55:25.251Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL存储引擎InnoDB的buffer pool设计思路。</p><span id="more"></span><h2 id="mysqlinnodb-buffer-pool"><a class="markdownIt-Anchor" href="#mysqlinnodb-buffer-pool"></a> MySQL(InnoDB) buffer pool</h2><h3 id="配置参数"><a class="markdownIt-Anchor" href="#配置参数"></a> 配置参数</h3><ul><li><p><code>innodb_buffer_pool_size</code>: buffer pool大小</p></li><li><p><code>innodb_buffer_pool_instances</code>: buffer pool实例个数（若bufferpool较大，可划分为多个instances，每个instance通过各自的list独立管理，提高读并发度）</p></li><li><p><code>innodb_buffer_pool_chunk_size</code>: 当增加或减少<code>innodb_buffer_pool_size</code>时，<code>innodb_buffer_pool_chunk_size</code>相应变化</p></li></ul><blockquote><p>If the new innodb_buffer_pool_chunk_size value * innodb_buffer_pool_instances is larger than the current buffer pool size when the buffer pool is initialized, innodb_buffer_pool_chunk_size is truncated to innodb_buffer_pool_size / innodb_buffer_pool_instances.</p></blockquote><blockquote><p>Buffer pool size must always be equal to or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances. If you alter innodb_buffer_pool_chunk_size, innodb_buffer_pool_size is automatically adjusted to a value that is equal to or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances. The adjustment occurs when the buffer pool is initialized.</p></blockquote><ul><li><code>innodb_old_blocks_pct</code>: controls the percentage of “old” blocks in the LRU list（LRU链表中插入点的位置）</li></ul><h3 id="替换策略变种lru"><a class="markdownIt-Anchor" href="#替换策略变种lru"></a> 替换策略：变种LRU</h3><ul><li><p>普通LRU会产生的问题：预读失效和缓冲池污染。</p><ul><li>预读失效：预先加载的一些page后续没有被访问，反而丢弃了原本LRU链表末尾的一些page。</li><li>缓冲池污染：一次性扫描大量数据，buffer pool中所有page被替换出去。</li></ul></li><li><p>解决方案：冷热数据分离</p><ul><li>将LRU链表分为两部分，热数据区和冷数据区。</li><li>当某一page第一次被加载到buffer pool中，先将其放到冷数据区域的链表头部。</li><li>经过<code>innodb_old_blocks_time</code>（单位：ms）后，若该page再次被访问，将其移动到热数据区域的链表头部。</li><li>若page已经在热数据区，再次被访问，不需要每次都移动到热数据区链表头部，MySQL的优化方案是，热数据区的后3/4部分被访问需要移动到链表头部，前1/4部分不移动。</li></ul></li></ul><h3 id="lru链表"><a class="markdownIt-Anchor" href="#lru链表"></a> LRU链表</h3><p><img src="https://dev.mysql.com/doc/refman/5.7/en/images/innodb-buffer-pool-list.png" alt="" /></p><ul><li>分为两个部分：New Sublist，Old Sublist。</li><li><code>innodb_old_blocks_pct</code>控制插入点Midpoint。</li><li>全表扫描时，设置<code>innodb_old_blocks_time</code>的时间窗口可以有效的保护New Sublist。</li></ul><h3 id="预读机制"><a class="markdownIt-Anchor" href="#预读机制"></a> 预读机制</h3><ul><li>Linear read-ahead</li><li>Random read-ahead</li></ul><h3 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h3><ul><li><p><a href="https://github.com/mysql/mysql-server/blob/8.0/storage/innobase/include/buf0buf.h">buf0buf.h</a>: The database buffer pool high-level routines</p><ul><li><code>dberr_t buf_pool_init(ulint total_size, ulint n_instances)</code>: Creates the buffer pool.</li><li><code>void buf_pool_free_all()</code>: Frees the buffer pool at shutdown.</li><li><code>void buf_resize_thread()</code>: This is the thread for resizing buffer pool.</li><li><code>void buf_pool_clear_hash_index(void)</code>: Clears the adaptive hash index on all pages in the buffer pool.</li><li><code>static inline ulint buf_pool_get_curr_size(void)</code>: Gets the current size of buffer buf_pool in bytes.</li><li><code>static inline ulint buf_pool_get_n_pages(void)</code>: Gets the current size of buffer buf_pool in frames.</li><li>get<ul><li><code>bool buf_page_optimistic_get(ulint rw_latch, buf_block_t *block, uint64_t modify_clock, Page_fetch fetch_mode, const char *file, ulint line, mtr_t *mtr)</code>: Get optimistic access to a database page.</li><li><code>bool buf_page_get_known_nowait(ulint rw_latch, buf_block_t *block, Cache_hint hint, const char *file, ulint line, mtr_t *mtr)</code>: Get access to a known database page, when no waiting can be done.</li><li><code>const buf_block_t *buf_page_try_get_func(const page_id_t &amp;page_id, const char *file, ulint line, mtr_t *mtr)</code>: Given a tablespace id and page number tries to get that page.</li><li><code>buf_block_t *buf_page_get_gen(const page_id_t &amp;page_id, const page_size_t &amp;page_size, ulint rw_latch, buf_block_t *guess, Page_fetch mode, const char *file, ulint line, mtr_t *mtr, bool dirty_with_no_latch = false)</code>: Get access to a database page.</li><li><code>buf_block_t *buf_page_create(const page_id_t &amp;page_id, const page_size_t &amp;page_size, rw_lock_type_t rw_latch, mtr_t *mtr)</code>: Initializes a page to the buffer buf_pool.</li></ul></li><li><code>void buf_page_make_young(buf_page_t *bpage)</code>: Moves a page to the start of the buffer pool LRU list.</li><li><code>void buf_page_make_old(buf_page_t *bpage)</code>: Moved a page to the end of the buffer pool LRU list.</li><li><code>static inline ibool buf_page_peek(const page_id_t &amp;page_id)</code>: Returns TRUE if the page can be found in the buffer pool hash table.</li></ul></li><li><p><a href="https://github.com/mysql/mysql-server/blob/8.0/storage/innobase/include/buf0dblwr.h">buf0dblwr.h</a>: Doublewrite buffer module</p></li><li><p><a href="https://github.com/mysql/mysql-server/blob/8.0/storage/innobase/include/buf0rea.h">buf0rea.h</a>: The database buffer read</p></li><li><p><a href="https://github.com/mysql/mysql-server/blob/8.0/storage/innobase/include/buf0dump.h">buf0dump.h</a>: Implements a buffer pool dump/load</p></li><li><p><a href="https://github.com/mysql/mysql-server/blob/8.0/storage/innobase/include/buf0flu.h">buf0flu.h</a>: The database buffer pool flush algorithm</p></li><li><p><a href="https://github.com/mysql/mysql-server/blob/8.0/storage/innobase/include/buf0lru.h">buf0lru.h</a>: The database buffer pool LRU replacement algorithm</p></li></ul><h3 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h3><ul><li><a href="https://github.com/mysql/mysql-server">MySQL源码</a><ul><li><a href="https://github.com/mysql/mysql-server/tree/8.0/storage/innobase/include">buffer pool API声明</a></li><li><a href="https://github.com/mysql/mysql-server/tree/8.0/storage/innobase/buf">buffer pool API实现</a></li></ul></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">MySQL InnoDB文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL存储引擎InnoDB的buffer pool设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://tongyiheng.top/categories/Embedded/"/>
    
    
    <category term="cpp" scheme="https://tongyiheng.top/tags/cpp/"/>
    
    <category term="MySQL" scheme="https://tongyiheng.top/tags/MySQL/"/>
    
    <category term="buffer pool" scheme="https://tongyiheng.top/tags/buffer-pool/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://tongyiheng.top/2021/06/13/CS/ComputerNetworks/"/>
    <id>https://tongyiheng.top/2021/06/13/CS/ComputerNetworks/</id>
    <published>2021-06-13T02:18:35.000Z</published>
    <updated>2021-10-19T06:54:54.501Z</updated>
    
    <content type="html"><![CDATA[<p>How to build a network?</p><span id="more"></span><h1 id="computer-networks"><a class="markdownIt-Anchor" href="#computer-networks"></a> Computer Networks</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>M</mi><mi>b</mi><mi>p</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mi>b</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1Mbps=10^{6}bps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>G</mi><mi>b</mi><mi>p</mi><mi>s</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mi>b</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1Gbps=10^{9}bps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord mathdefault">G</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span></p><h2 id="第一章引言"><a class="markdownIt-Anchor" href="#第一章引言"></a> 第一章：引言</h2><h3 id="11-名词解释"><a class="markdownIt-Anchor" href="#11-名词解释"></a> 1.1 名词解释</h3><ul><li>计算机网络：一组通过单一技术相互连接的自主计算机集合。</li><li><strong>VPN</strong>（Virtual Private Networks）：虚拟专用网络。</li><li>peer-to-peer：对等。</li><li><mark>P2P：对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式。</mark></li><li>RFID（Radio Frequency IDentification）：射频识别。</li><li>hotspot：无线热点。</li><li>GPS（Global Positioning System）：全球定位系统。</li><li>NFC（Near Field Communication）：近场通信。</li><li><strong>点到点</strong>，<strong>端到端</strong>。</li><li>单播（unicasting）、<mark>广播（broadcasting）</mark>：同时给全部目标地址发送一个数据包、组播（multicasting）。</li><li>PAN（Personal Area Network）：个域网</li><li>LAN（Local Area Network）：局域网</li><li>WIFI：无线局域网的一个标准 IEEE 802.11</li><li>Ethernet：以太网 IEEE 802.3</li><li>VLAN（Virtual LAN）：虚拟局域网</li><li>MAN（Metropolitan Area Network）：城域网</li><li>WAN（Wide Area Network）：广域网</li><li>通信子网（subnet）、子网：子网的工作是把信息从一个主机携带到另一个主机。<br />子网由两个不同部分组成：传输线路（e.g. 铜线、光纤、无线）和交换元素（交换机、路由器）。</li><li>ISP（Internet Service Provider）：Internet服务提供商。相应的子网称为ISP网络。</li><li><mark>协议：通信双方就如何进行通信的一种约定。</mark></li><li><strong>对等体</strong>：不同机器上构成相应层次的实体。</li><li><strong>接口</strong>：定义了下层向上层提供哪些原语操作和服务。</li><li><strong>网络体系结构</strong>：层和协议的集合。</li><li><strong>协议栈</strong>：一个特定的系统所使用的一组协议，即每一层一个协议。</li><li>统计复用：许多网络设计根据主机的短期需求变化动态共享网络带宽，而不是给每个主机分配可能用也可能不会用的固定比例带宽。</li><li>流量控制：保持快速发送方不会用数据把慢速接收方淹没。</li><li>拥塞：太多的计算机需要发送太多的流量，而网络没有能力传递所有的数据包。</li><li><strong>面向连接的服务</strong>：按照电话系统建模。</li><li><strong>无连接服务</strong>：按照邮政系统建模。</li><li><strong>存储-转发交换</strong>：中间节点只能在收到报文的全部内容后再将该报文发送给下一个节点。</li><li><strong>直通式交换</strong>：报文还未全部接受完毕之前就向下一个节点传输。</li><li><mark>DNS（Domain Name System）：域名系统，将主机名字映射到网络地址。</mark></li><li>ISO（International Standards Organization）：国际标准化组织。</li><li>OSI（Open Systems Interconnection）：开放系统互连。</li><li>物理层：关注在一条通信信道上传输原始比特。</li><li>数据链路层：将一个原始的传输设施转变成一条没有漏检传输错误的线路。</li><li>网络层：控制子网的运行。关注如何将数据报从源端路由到接收方。</li><li>传输层：接收来自上一层的数据，在必要的时候把这些数据分割成较小的单元，然后把这些数据单元传递给网络层，并且确保这些数据单元正确地到达另一端。</li><li>IP（Internet Protocol）：因特网协议。</li><li>ICMP（Internet Control Message Protocol）：因特网控制报文协议。</li><li>TCP（Transport Control Protocol）：传输控制协议，可靠的、面向连接的。</li><li>UDP（User Datagram Protocol）：用户数据报协议，不可靠的、无连接的。</li><li>DSL（Digital Subscriber Line）：数字用户线。</li><li>modem ：调制解调器。</li><li>CMTS（Cable Modem Termination System）：线缆调制解调终端系统。</li><li>宽带（broadband）：以高于拨号速率（56kbps）接入Internet。<mark>IEEE 802.16</mark></li><li>FTTH（Fiber to the Home）：光纤到户。</li><li>POP（Point of Presence）：ISP存点，客户数据报进入ISP网络使用其服务的位置。</li><li>IXP（Internet eXchange Point）：Internet交换点。相互连接的ISP被认为彼此对等。</li><li>AMPS（Advanced Mobile Phone System）：高级移动电话系统。 1G</li><li>GSM（Global System for Mobile communications）：全球移动通信系统。 2G</li><li>UMTS（Universal Mobile Telecommunications System）：通用移动通信系统。 3G</li><li>CDMA（Code Division Multiple Access）：码分多址。</li><li>WCDMA（Wideband Code Division Multiple Access）：宽带码分多址。</li><li>GPRS（General Packet Radio Service）：通用数据报无线业务。</li><li>软切换（soft handover）–硬切换（hard handover）</li><li>SIM（Subscriber Identity Module）：用户识别模块。</li><li>ISM（Industral Scientific and Medical）：工业科学医疗频段。</li><li>AP（Access Point）：接入点。</li><li>OFDM（Orthogonal Frequency Division Multiplexing）：正交频分复用。</li><li>CSMA（Carrier Sense Multiple Access）：载波侦听多路访问。</li><li>WPA（WiFi Protected Access）：WiFi保护接入。</li></ul><h2 id="第二章物理层"><a class="markdownIt-Anchor" href="#第二章物理层"></a> 第二章：物理层</h2><h3 id="21-数据通信的理论基础"><a class="markdownIt-Anchor" href="#21-数据通信的理论基础"></a> 2.1 数据通信的理论基础</h3><h4 id="211-傅里叶分析"><a class="markdownIt-Anchor" href="#211-傅里叶分析"></a> 2.1.1 傅里叶分析</h4><h4 id="212-带宽有限的信号"><a class="markdownIt-Anchor" href="#212-带宽有限的信号"></a> 2.1.2 带宽有限的信号</h4><ul><li>带宽：<mark>在传输过程中振幅不会明显减弱的频率的宽度</mark> or <mark>单位时间内可以传递的数据位数</mark></li><li>带宽是传输介质的一种物理特性，通常取决于介质的构成、厚度和电线或者光纤的长度。</li><li>一般将从0到某个最大频率的信号称为基带信号，将被搬移并占用某个更大频率范围的信号称为通带信号。</li></ul><h4 id="213-信道的最大数据速率"><a class="markdownIt-Anchor" href="#213-信道的最大数据速率"></a> 2.1.3 信道的最大数据速率</h4><ul><li><p><mark>尼奎斯特定理</mark></p><ul><li>在<strong>无噪声信道</strong>中，如果物理带宽为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ，信号离散度等级为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> ，则该信道最大数据速率 （数字带宽）= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>B</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>V</mi><mtext> </mtext><mi>b</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2B log_{2}V \ bps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> ，计算后还要乘每秒采样数。</li><li>任意一个信号的通过一个物理带宽为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的低通滤波器只要进行每秒 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">2B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 次的采样就可完全重构出被滤掉的信号。</li><li>信道一定，物理带宽确定时，要提高数字带宽只有<strong>增加离散等级</strong>。</li></ul></li><li><p><mark>香农定理</mark></p><ul><li>在<strong>有噪声信道</strong>中，如果物理带宽为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ，信噪比为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">S/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，则该信道最大数据速率 （数字带宽）= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>b</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">B log_{2}(1+S/N) \ bps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 。</li><li>分贝值 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mtext> </mtext><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">10log_{10}S/N \ dB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></li><li>信道一定，物理带宽确定时，要提高数字带宽只有<strong>增加信噪比</strong>。</li></ul></li></ul><h3 id="22-引导性传输介质"><a class="markdownIt-Anchor" href="#22-引导性传输介质"></a> 2.2 引导性传输介质</h3><ul><li>全双工（full-deplex）：可以双向同时使用的链路。</li><li>半双工（half-deplex）：可以双向使用但是一次只能使用一个方向的链路。</li><li>单双工（simplex）：只允许一个方向上的传输的链路。</li></ul><h3 id="23-无线传输"><a class="markdownIt-Anchor" href="#23-无线传输"></a> 2.3 无线传输</h3><h3 id="24-通信卫星"><a class="markdownIt-Anchor" href="#24-通信卫星"></a> 2.4 通信卫星</h3><h3 id="25-数字调制与多路复用"><a class="markdownIt-Anchor" href="#25-数字调制与多路复用"></a> 2.5 数字调制与多路复用</h3><ul><li><mark>多路复用</mark>：信道被多个信号共享。</li><li>基带传输：信号的传输占有传输介质上从零到最大值之间的全部频率。</li><li>通带传输：信号占据了以载波信号频率为中心的一段频带。</li></ul><h4 id="251-基带传输"><a class="markdownIt-Anchor" href="#251-基带传输"></a> 2.5.1 基带传输</h4><ul><li>NRZ（Non-Return-to-Zero）：不归零。</li><li><mark>曼彻斯特编码</mark><ul><li>从低到高：逻辑0</li><li>从高到低：逻辑1</li><li>需要两倍于NRZ编码的带宽。</li><li>每一位的中间有一跳变，位中间的跳变既作时钟信号，又作数据信号。</li></ul></li><li><mark>差分曼彻斯特编码</mark><ul><li>每位中间的跳变仅提供时钟定时。</li><li>第一个信号：如果中间位电平从低到高，则表示0；如果中间位电平从高到低，则表示1。</li><li>从第二个信号开始，每位开始时有无跳变表示&quot;0&quot;或&quot;1&quot;，有跳变为&quot;0&quot;，无跳变为&quot;1&quot;。</li></ul></li><li>NRZI（Non-Return-to-Zero Inverted）：不归零逆转<ul><li>信号有跳变：1</li><li>信号无跳变：0</li></ul></li><li>4B/5B<ul><li>4个比特被映射为5个比特</li><li>保证永远不会出现连续三个0</li></ul></li><li>双极编码<ul><li>使用两个电压级别表示逻辑1</li><li>发送1时在+1V和-1V之间进行选择</li></ul></li></ul><h4 id="252-通带传输"><a class="markdownIt-Anchor" href="#252-通带传输"></a> 2.5.2 通带传输</h4><ul><li>ASK（Amplitude Shift Keying）：幅移键控。通过两个不同的振幅表示0和1。</li><li>FSK（Frequency Shift Keying）：频移键控。通过两个不同的频率表示0和1。<ul><li>最简单的形式是相移键控（PSK，Phase Shift Keying）。</li><li>二进制相移键控（BPSK，Binary Phase Shift Keying）：载波波形偏移0°或180°。</li><li>正交相移键控（QPSK，Quadrature Phase Shift Keying）：4个偏移，45°、135°、225°、315°。</li></ul></li></ul><h4 id="253-频分复用"><a class="markdownIt-Anchor" href="#253-频分复用"></a> 2.5.3 频分复用</h4><ul><li>FDM：Frequency Division Multiplexing</li><li>保护带（guardband）：使信道之间完全隔离。</li><li>OFDM（Orthogonal Frequency Division Multiplexing）：正交频分复用。</li></ul><h4 id="254-时分复用"><a class="markdownIt-Anchor" href="#254-时分复用"></a> 2.5.4 时分复用</h4><ul><li>TDM：Time Division Multiplexing</li><li>每个用户周期性获得整个带宽非常短的一个时间。</li><li>要求时间上必须同步，各用户需要的带宽不均衡，而TDW用户时间片的使用却是一样的，将造成信道的浪费，不高效。</li></ul><h4 id="255-码分复用"><a class="markdownIt-Anchor" href="#255-码分复用"></a> 2.5.5 码分复用</h4><ul><li>CDMA：Code Division Multiple Access</li><li>允许每个站利用整个频段发送信号，没有时间限制。</li><li>可以将TDM看作许多人按顺序交谈，将FDM看作不用人按不同语调交谈，CDMA则是每对交谈者使用不用的语言。</li><li>CDMA关键在于能够提取出需要的信号，同时拒绝所有其他的信号并把这些信号当作噪声。</li></ul><h3 id="26-公共电话交换网络"><a class="markdownIt-Anchor" href="#26-公共电话交换网络"></a> 2.6 公共电话交换网络</h3><ul><li><p>本地回路(Local loops)：模拟线路，连接端局和千家万户，通常用三类双绞线承担。</p></li><li><p>干线、中继线(Trunks)：数字光纤，连接交换局。</p></li><li><p>交换局(Switching offices)：语音接驳干线的场所，包括端局。</p></li><li><p>56k（64k）的调制解调器：V.90标准电话线路频率为4kHz，采样率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>2</mn><mo>×</mo><mn>4000</mn><mo>=</mo><mn>8000</mn><mi>s</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">=2×4000=8000sample/sec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span> ，每个码元传输8bit，其中1个比特控制错误，故传输数据速率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>8000</mn><mo>×</mo><mn>7</mn><mo>=</mo><mn>56000</mn><mi>k</mi><mi>b</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">=8000×7=56000kbps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span>，若算上控制错误的比特，毛速率为64kbps。</p></li><li><p><mark>ADSL（Asymmetric Digital Subscriber Lines）： 非对称数字用户线。</mark></p></li><li><p>连接调制解调器的本地回路带宽，被限制为4k，因为电话占频为4k；xDSL取消了电话系统里的滤波器后，可使用本地回路的全部（1.1兆）物理带宽。</p></li><li><p>使用<strong>离散多音</strong>（DMT，Discrete MultiTone）调制方法的ADSL操作：</p><ul><li>1.1MHz的频谱，分为256根信道，每根4kHz（4312.5Hz）。信道0用于简单老式电话服务（POTS），信道1~5空闲， 剩下250条信道中，一条用于上行流控制，一条用于下行流控制，剩余248条信道用于数据传输（一种常见的分法是32条用于上行数据流）。</li><li>每条信道内使用QAM调制方案，速率约为4000符号/秒。</li><li>QAM-64每个符号传输6bits。</li><li>1999年设定国际标准G.dmt，下行速度8Mbps，上行速度1Mbps。</li></ul></li><li><p>DSLAM（Digital Subscriber Line Access Multiplexer）：数字用户线路接入复用器。</p></li><li><p>NID（Network Interface Device）：网络接口设备。</p></li><li><p>光纤入户（FttH）:</p><ul><li>PON（Passive Optical Network）：无源光网络。</li><li>下行流：光分离器 。上行流：光合并器。</li></ul></li><li><p>脉冲编码调制：PCM，Pulse Code Modulation</p><ul><li>模拟信号数字化的技术。构成了现代PSTN的核心。</li><li>采样、量化、编码、传输。</li><li>每125微秒发送一个语音样值，该采样率足以捕捉4kHz电话信道带宽上的信息。</li></ul></li><li><p>时分多路复用TDM</p><ul><li><strong>T1载波</strong>（北美和日本），24路。</li><li>每帧24×8=192个比特，加上控制用的一个比特的帧码，每125微秒产生193个比特，即<strong>数据传输率为193bits/0.000125s=1.544Mbps</strong>，<strong>8kbps</strong>用于信令控制。</li><li>每个样值中每个信道有7个数据比特，故1帧中包含的数据为<strong>24×7=168bits</strong>。</li><li>E1载波（中国），32路语音的复用<br />每125微秒传递32*8=256个比特，即<strong>数据传输率为256bits/0.000125s=2.048Mbps</strong></li><li>TDM允许更高级别的复用，比如4条T1流复用为1条T2流，7条T2流复用为1条T3流（每一步复用有少量开销用于同步控制、成帧）</li></ul></li><li><p><strong>SONET/SDH</strong>：光介质上进行同步数据传输的标准</p><ul><li>SONET（Synchronous Optical NETwork）：同步光网络，美国ANSIS制定。</li><li>SDH（Synchronous Digital Hierarchy）：同步数字序列，国际标准组织ITU制定。</li><li>每隔125微秒发送810字节数据块，SONET是同步系统故不管是否有用该帧都被发送出去，<strong>总的传输速率为51.84Mbps</strong>。</li><li>9行，90列，有效载荷（SPE）为87列，共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>87</mn><mo>×</mo><mn>9</mn><mo>×</mo><mn>8</mn><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo>×</mo><mn>8000</mn><mi>s</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>e</mi><mi>c</mi><mo>=</mo><mn>50.112</mn><mi>M</mi><mi>b</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">87×9×8bits×8000sample/sec=50.112Mbps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 。</li><li>SPE第一列是路径开销，因此用户数据为86列。</li><li>每帧前三列，保留用作传输系统管理信息。<ul><li>前三列的前三行包含section开销。</li><li>前三列的后六行包含line开销，其中前两个字节包含了指向SPE首地址的指针。</li></ul></li><li>源端正在构造SONET空帧时来了一个有效载荷数据，它可直接半途插入到当前构造的帧中，比如下图，SPE就从第1个帧的半途开始，横跨了两个帧。</li><li>对应于STS-n的光纤载波称为OC-n，其复用也是按比特进行的。</li><li>如果一个载波（比如OC-3）没有被复用，而是仅承载了来自单个源的数据，则在线路名称后面加一个字母c（表示级联），因此OC-3表示由三条独立的OC-1载波构成的一条155.52Mbps载波，而OC-3c则表示来自于单个源的155.52Mbps数据流。</li></ul></li><li><p>波分多路复用WDM</p><ul><li>WDM，Wavelength Division Multiplexing</li><li>波长λ，c=λf</li><li>按照波长分成若干份，承载不同用户的光信号。</li></ul></li><li><p><mark>交换</mark></p><ul><li>电路交换</li><li>包交换</li></ul></li></ul><h2 id="第三章数据链路层"><a class="markdownIt-Anchor" href="#第三章数据链路层"></a> 第三章：数据链路层</h2><h3 id="31-数据链路层的设计问题"><a class="markdownIt-Anchor" href="#31-数据链路层的设计问题"></a> 3.1 数据链路层的设计问题</h3><ul><li>无确认的无连接服务。 以太网</li><li>有确认的无连接服务。WiFi。</li><li>有确认的有连接服务。</li><li>成帧：<ul><li>字节计数法：每帧开始使以一个计数字段表示该帧的总字符数。</li><li>字节填充的标志字节法：<ul><li>以某些特殊字符作帧的开始/结束标志，同时增加转义环节以免该字符无法表达。</li><li>缺点：容易造成帧界混淆（故增加转义字节），<strong>依赖8位字符</strong>。</li></ul></li><li>比特填充的标志比特法：<ul><li>用特殊的位模式<code>01111110</code>作为帧标志，即一个帧的开始（前一个帧的结束）</li><li>且为了处理帧内容中出现一个和帧标志相同的位串<code>01111110</code>。发送方一般在5个1后插入1个0，变为<code>01111101</code>。接收方自动删除第5个1后的0。</li><li>优点：可传输任意比特数的帧，传输速率更高。</li></ul></li><li>物理层编码违禁法：<ul><li>在物理层的线路编码方法里头，有一些冗余信号是不会出现在传输数据里的，以其作帧界。</li><li>比如，在4B/5B编码中，4B被映射成5B传输，32个模式，只用到16个，剩下的可以用作帧界。</li><li>比如，曼彻斯特编码，高电位跳变到低电位表示”1”，相反表示”0”。所以有两个跳变（高-&gt;高，低-&gt;低），两个冗余的跳变是没有使用的，也可拿作帧界。好处是使用冗余信号，不会混淆也不需要填充，故传输速率高。</li></ul></li></ul></li></ul><h3 id="32-差错检测和纠正"><a class="markdownIt-Anchor" href="#32-差错检测和纠正"></a> 3.2 差错检测和纠正</h3><ul><li>码字：包含数据位和校验位的n位单元（n=m+r）。</li><li>码率：码字中不包含冗余部分所占的比例，m/n。</li><li>海明距离：两个码字中不相同的位的个数。</li><li>意义：如果两个码字的海明距离为d，则需要d个1位错误才能将一个码字转变成另一个码字。</li><li>海明码，见计组和数字逻辑。</li><li><mark>循环冗余校验码（CRC）：</mark><ul><li>任何一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>位的帧，可以看做一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次的多项式。如1011001，看做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>6</mn></msub><mo>+</mo><msub><mi>x</mi><mn>4</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_6+x_4+x_3+x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（6阶7项多项式）</li><li>约定一个<strong>生成多项式</strong>（Generator Polynomial）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，阶数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，项数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li><li>现在有一个要计算CRC的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>位帧的多项式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>&gt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">m&gt;r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>长。</li><li>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>后附上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>个0，成为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>r</mi><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">xrM(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>r</mi><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">xrM(x)/G(x)=Q(x)+R(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>为商、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>为余数，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>r</mi><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">xrM(x)-R(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>一定能被<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>整除。</li></ul></li></ul><h3 id="33-基本数据链路层协议"><a class="markdownIt-Anchor" href="#33-基本数据链路层协议"></a> 3.3 基本数据链路层协议</h3><h3 id="34-滑动窗口协议"><a class="markdownIt-Anchor" href="#34-滑动窗口协议"></a> 3.4 滑动窗口协议</h3><ul><li><mark>发送窗口、接收窗口</mark><ul><li>含义：允许发送的帧、允许接收的帧。</li><li>如何移动：<ul><li>发送窗口：任何时候当有新的数据包从网络层到来时，它被赋予窗口的下一个最高序号，并且窗口的上边界前移一格。当收到一个确认时，窗口的下边界也前移一格。</li><li>接收窗口：任何落在窗口内的帧被放入接收方的缓冲区。当收到一个帧，而且其序号等于窗口下边界时，接收方将它传递给网络层，并将整个窗口向前移动1个位置。</li></ul></li></ul></li><li><mark>回退N协议</mark>：当位于某个数据流中间的一个帧损坏或丢失，接收方丢弃所有到达的后序帧，而且针对这些丢弃的帧不返回确认。</li><li><mark>选择重传协议</mark>：当位于某个数据流中间的一个帧损坏或丢失，接收方将收到的坏帧丢弃，但接收并缓存坏帧后面的所有好帧。当发送方超时，只重传那个最早的未被确认的帧。</li></ul><h2 id="第四章介质访问控制子层"><a class="markdownIt-Anchor" href="#第四章介质访问控制子层"></a> 第四章：介质访问控制子层</h2><ul><li><mark>介质访问控制子层（MAC, Medium Access Control）</mark>：用来确定多路访问信道下一个使用者的协议，属于数据链路层的一个子层。</li><li>MAC子层位于数据链路层底部。</li></ul><h3 id="41-信道分配问题"><a class="markdownIt-Anchor" href="#41-信道分配问题"></a> 4.1 信道分配问题</h3><h3 id="42-多路访问协议"><a class="markdownIt-Anchor" href="#42-多路访问协议"></a> 4.2 多路访问协议</h3><h4 id="421-aloha"><a class="markdownIt-Anchor" href="#421-aloha"></a> 4.2.1 ALOHA</h4><ul><li>纯ALOHA<ul><li>任何一个工作站都可以在帧生成后立即发送，并通过信号的反馈检测信道以判断是否发送成功。冲突则随机等待后重发。</li><li>即任性，想发就发。</li><li>生成k帧的概率服从泊松分布： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mi>G</mi><mi>k</mi></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup><mi mathvariant="normal">/</mi><mi>k</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">Pr[k]=G^ke^{-G}/k!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">!</span></span></span></span> 例如生成0帧的概率是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">Pr[0]=e^{-G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span> 。</li><li>在2t时间内，发送成功的概率应为，2t内都不才产生新帧的概率： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>0</mn><mo>=</mo><mi>P</mi><mi>r</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>×</mo><mi>P</mi><mi>r</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P0=Pr[0]×Pr[0]=e^{-2G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span> 。</li><li>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>0</mn><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P0=e^{-2G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span> 代入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>G</mi><mo>×</mo><mi>P</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">S=G×P0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">0</span></span></span></span> ，得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>G</mi><mo>×</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S=G×e^{-2G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span> 。</li><li>求导求吞吐率S的极大值： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>G</mi></mrow></msup><mo>−</mo><mn>2</mn><mi>G</mi><mo>×</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>G</mi></mrow></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S&#x27;=e^{-2G}-2G×e^{-2G}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，故当  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">G=0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span> 时，  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>≈</mo><mn>0.184</mn></mrow><annotation encoding="application/x-tex">S≈0.184</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">8</span><span class="mord">4</span></span></span></span> 。</li><li>即，纯ALOHA信道的利用率最高为18.4%。</li></ul></li><li>分槽ALOHA<ul><li>把时间分成时隙（时间片），时隙 = 帧时T（较纯ALOHA降低一半）</li><li>发送帧必须在时隙的起点，所以冲突值发生在时隙的起点</li><li>冲突危险期缩短为T，一旦某个站占用某个时隙并发送成功，则在该时隙内不会出现冲突</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>0</mn><mo>=</mo><mi>P</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P0=P[0]=e^{-G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>G</mi><mo>×</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>G</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S=G×e^{-G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">G</span></span></span></span></span></span></span></span></span></span></span></span></li><li>在G=1时取得最大吞吐率： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>=</mo><mn>1</mn><mi>e</mi><mo>≈</mo><mn>0.368</mn></mrow><annotation encoding="application/x-tex">Smax=1e≈0.368</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span></span></span></span></li><li>即，分隙ALOHA信道的利用率最高为36.8%。</li></ul></li></ul><h4 id="422-载波侦听多路访问协议"><a class="markdownIt-Anchor" href="#422-载波侦听多路访问协议"></a> 4.2.2 载波侦听多路访问协议</h4><ul><li><p>载波侦听多路访问协议（CSMA，Carrier Sense Multiple Access），改进的ALOHA协议。特点：先听后发。</p></li><li><p>非坚持CSMA</p><ul><li>概念：发送数据之前先侦听信道，若信道空闲，则发送帧；若信道忙碌，则等待一段随机时间后再侦听。</li><li>缺点：随机等待时间内介质上没有数据传送，这段时间被浪费，带来更大的延迟。</li><li>优点：更好的信道利用率。</li></ul></li><li><p>持续式CSMA</p><ul><li>分为：1-坚持CSMA、P-坚持CSMA</li><li>P-坚持CSMA（适用于分时间槽的信道）<ul><li>发送数据之前先侦听信道，若信道空闲，则以P的概率发送，以1-P的概率延迟一个时间槽发送；若信道忙碌，则等待直至信道变成空闲。如果发生冲突，等待一段随机时间后再侦听。</li></ul></li><li>1-坚持CSMA<ul><li>发送数据之前先侦听信道，若信道空闲，则发送帧；若信道忙碌，则等待直至信道变成空闲。如果发生冲突，等待一段随机时间后再侦听。</li></ul></li></ul></li><li><p>CSMA仍然会冲突的原因</p><ul><li>同时侦听同时传送。</li><li>传播延迟。信号在介质传播速度是光速的65%（每微秒200米），在信号未到达接收方的时候，接收方监听信道发现空闲，随后发帧，两帧碰撞冲突。</li></ul></li><li><p>冲突窗口</p><ul><li>冲突危险期：一个工作站能够检测到冲突的时间最大值。</li><li>冲突窗口定义为上限：来回时间（RTT，Round Trip Time），2个帧时。</li><li>信号在信道传播速度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>=</mo><mn>200</mn><mi>m</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">V = 200m/us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span></span></span></span></li><li>网卡处理帧的时间：网卡延时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>P</mi><mi>H</mi><mi>Y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{PHY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>最远的两个工作站相距： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></li><li>计算得到：冲突窗口 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>t</mi><mo>+</mo><mn>2</mn><msub><mi>t</mi><mrow><mi>P</mi><mi>H</mi><mi>Y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">2t+2t_{PHY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mi>S</mi><mi>V</mi></mfrac></mrow><annotation encoding="application/x-tex">t=\frac{S}{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。</li><li>倘若最远两个工作站间还有中继器，中继器处理时间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>r</mi><mi>e</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{repeater}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，则冲突窗口 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><msub><mi>t</mi><mrow><mi>P</mi><mi>H</mi><mi>Y</mi></mrow></msub><mo>+</mo><mi>N</mi><mo>×</mo><msub><mi>t</mi><mrow><mi>r</mi><mi>e</mi><mi>p</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(t+t_{PHY}+N×t_{repeater})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mi>S</mi><mi>V</mi></mfrac></mrow><annotation encoding="application/x-tex">t=\frac{S}{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。</li><li>如果冲突发生在最远两个工作站的正中间，那么此时检测到冲突的时间等于最远两个工作站之间的传播延迟。</li></ul></li><li><p><mark>带冲突检测的载波侦听多路访问协议（CSMA/CD,CSMA with Collision Detection）</mark>，也是1-持续的CSMA。<strong>半双工以太网中使用。</strong></p><ul><li>工作原理<ul><li>先听后发、边发边听。</li><li>经侦听，若介质空闲，则发送；若介质忙碌，持续侦听至空闲；发送之后，持续侦听是否碰撞冲突，若不冲突则发送成功，若冲突则随机等待后再重复侦听。</li><li>发送站感知冲突后，中断发送，之后发送一个非常简短的拥塞信号（Jam信号，是一个强化信号，广播出去通知各工作组该地方发生了碰撞）。</li></ul></li></ul></li><li><p>冲突检测和处理</p><ul><li>冲突检测的方法：比较发出和收到的两个信号的能量与脉冲宽度变化。</li><li>冲突检测的要求：<ul><li>时隙宽度 = 冲突窗口(最大冲突检测时间) ----&gt; 保证在一个时隙内能够检测到最远距离的冲突。</li><li>发送有效帧的时间 &gt;= 冲突窗口 ----&gt; 防止因为在发生冲突时，已完成短帧发送而无法知道实际上已发送失败。</li></ul></li></ul></li></ul><h4 id="423-无冲突协议"><a class="markdownIt-Anchor" href="#423-无冲突协议"></a> 4.2.3 无冲突协议</h4><p>以根本不可能产生冲突的方式解决信道竞争问题。</p><ul><li>位图协议<ul><li>假定有 N 个站，每个竞争期有 N 个槽。</li><li>j 号站在 j 号槽中插入1位来声明自己有帧要发送。</li><li>经过 N 个槽后，按照数字顺序开始传送数据。</li><li>效率<ul><li>低负载：每一帧的额外开销为 N 位，数据长度为 d 位，信道利用率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d/(n+d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> 。</li><li>高负载：若所有站在任何时候都有数据要发送，则 N 位竞争期被分摊到 N 个帧上，因此每一帧的额外开销只有1位，信道利用率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d/(1+d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> 。</li></ul></li></ul></li><li>令牌传递<ul><li>令牌代表发送权限。</li><li>如果站有个等待传输的帧队列，当它接收到令牌就可以发送帧，然后再把令牌传递到下一站。</li><li>如果站没有排队的帧要传，则只把令牌传递下去。</li></ul></li><li>二进制倒计数<ul><li>如果一个站想要使用信道，它就以二进制位串的形式广播自己的地址，从高序的位开始。</li><li>假定所有的地址具有相同的长度。</li><li>不同站地址中相同位在同时发送时被信道布尔或在一起。</li><li>假设传输延迟可忽略。</li><li>一个站只要看到自己的地址位中的0值被改写成了1，则它必须放弃竞争。</li><li>特性：高序站的优先级比低序站的优先级高。</li><li>信道利用率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d/(d+log_2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，如果精心设计帧格式，使得发送方的地址正好是帧内的第一个字段，信道利用率为100%。</li></ul></li></ul><h4 id="424-有限竞争协议"><a class="markdownIt-Anchor" href="#424-有限竞争协议"></a> 4.2.4 有限竞争协议</h4><ul><li>低负载下采用竞争的做法而提供较短的延迟，高负载下采用无冲突技术获得良好的信道效率。</li></ul><h4 id="425-无线局域网协议"><a class="markdownIt-Anchor" href="#425-无线局域网协议"></a> 4.2.5 无线局域网协议</h4><ul><li>隐藏终端问题：由于竞争者离得太远而导致站无法检测到潜在的竞争者。</li><li>暴露终端问题：发送方监听到有一个传输正在进行，错误地得出结论不能开始将要进行的传输，而事实上将要进行的传输不会破坏正在进行的这个传输。</li><li><mark>MACA（Multiple Access with Collision Avoidance）</mark>：冲突避免多路访问。<ul><li>基本思想：发送方刺激接收方输出一个短帧，以便其附近的站能检测到这次传输，从而避免在接下去进行的（较大）数据帧传输中也发送数据。</li><li>A首先给B发送一个RTS（Request to Send）帧，包含了随后将要发送的数据帧的长度。</li><li>B用一个CTS（Clear to Send）作为应答，此CTS帧也包含了数据长度（从RTS）中复制过来。</li><li>A收到CTS之后开始传输。</li></ul></li></ul><h3 id="43-以太网"><a class="markdownIt-Anchor" href="#43-以太网"></a> 4.3 以太网</h3><ul><li>经典以太网</li><li>交换式以太网</li></ul><h4 id="431-经典以太网物理层"><a class="markdownIt-Anchor" href="#431-经典以太网物理层"></a> 4.3.1 经典以太网物理层</h4><ul><li>可以包含多个电缆段和多个中继器，但是不允许任意两个收发器之间的距离超过2.5km，并且任意两个收发器之间经过的中继器不能超过4个。</li></ul><h4 id="432-经典以太网mac子层协议"><a class="markdownIt-Anchor" href="#432-经典以太网mac子层协议"></a> 4.3.2 经典以太网MAC子层协议</h4><ul><li>SOF（Start of Frame）：帧起始定界符。</li><li>LLC（Logical Link Control）：逻辑链路控制。</li><li><strong>IEEE 802.3帧结构</strong>：<ul><li>前导码+帧起始字段：8个Bytes，前7个Bytes都是10101010，最后一个字节10101011（最后一位是1表明帧的开始）。前导码的作用——表明一个帧的开始。<ul><li>而在DIX以太网帧中，帧起始字段最后一位是0。</li></ul></li><li>目的地址：6个Bytes（MAC地址，前24位为OUI表示某公司，后24位表序号）。</li><li>源地址：6个Bytes（MAC地址，全球唯一，表示方法是’-‘、’:’、’.’配合16进制）。</li><li>长度字段：表明帧长度（不包括前导码、但包括帧头帧尾），帧长度最小64字节最大1518字节。<ul><li>而在DIX以太网帧中，该字段是类型字段，表明上层网络层是什么协议。</li><li>如何区分是长度字段还是类型字段：判断大小，长度字段大小&lt;=1536(0x600)， 类型字段大小&gt;1536(0x600)。</li></ul></li><li>数据字段：搭载了LLC的数据，长度最小是46字节，实际内容小于46则要填充到46，如此加上帧头帧尾的18字节再能保证整个帧至少64字节。</li><li>校验字段：4个Bytes，CRC循环冗余校验，除了前导码+帧起始字段都被校验。</li><li>有效帧长度至少64Bytes ★<ul><li>CDMA/CD的要求：最短帧发送时间 &gt;= 冲突窗口 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></li><li>以太网(802.3)规定，在10Mbps局域网中<ul><li>时隙： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>τ</mi><mo>=</mo><mn>51.2</mn><mi>μ</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2τ=51.2μs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord mathdefault">μ</span><span class="mord mathdefault">s</span></span></span></span></li><li>最短帧长度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>M</mi><mi>b</mi><mi>p</mi><mi>s</mi><mo>×</mo><mn>2</mn><mi>τ</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>64</mn><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">10Mbps×2τ/8=64Bytes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>51200</mn><mi mathvariant="normal">/</mi><mn>100</mn><mi>n</mi><mi>s</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>64</mn><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">(51200/100ns)/8=64Bytes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span></li></ul></li><li>为了更加容易区分有效帧和垃圾数据，以太网要求有效帧必须至少64字节。</li></ul></li></ul></li><li><mark>二进制指数后退的CSMA/CD</mark><ul><li>冲突检测到后，时间被分成离散的时隙，时隙长度等于信号在介质上来回传输时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>51.2</mn><mi>μ</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">51.2μs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord mathdefault">μ</span><span class="mord mathdefault">s</span></span></span></span> 。一般地，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次冲突后，等待的时间将从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 之间随机选择一个数，然后等待这么多个时间槽。达到10次冲突后，随机数的选择区间被固定在最大值1023，以后不再增加。在16次冲突之后，控制器放弃努力，并给计算机返回一个失败报告。</li><li>有效性<ul><li>如果只有少量站发生冲突，则可确保较低的延迟。</li><li>当许多站发生冲突时，可以保证在一个相对合理的时间间隔内解决冲突。将延迟后退的步子截断在1023​可避免延迟增长的太大。</li></ul></li></ul></li></ul><h4 id="433-以太网性能"><a class="markdownIt-Anchor" href="#433-以太网性能"></a> 4.3.3 以太网性能</h4><h4 id="434-交换式以太网"><a class="markdownIt-Anchor" href="#434-交换式以太网"></a> 4.3.4 交换式以太网</h4><ul><li>集线器</li><li>交换机</li></ul><h4 id="435-快速以太网"><a class="markdownIt-Anchor" href="#435-快速以太网"></a> 4.3.5 快速以太网</h4><ul><li>快速以太网（100M以太网——IEEE802.3u）<ul><li>要求：跟10M以太网兼容</li><li>基本思想：保留原有的帧格式、接口和过程规则</li><li>比特时间：100ns -&gt; 10ns</li><li>电缆最大长度：2500m - &gt; 250m</li></ul></li><li>编码方式<ul><li>10M以太网：曼彻斯特编码</li><li>快速以太网：4B/5B（4bits数据被编码成5bits信号，易实现、电压平衡、效率80%）</li></ul></li></ul><h4 id="436-千兆以太网"><a class="markdownIt-Anchor" href="#436-千兆以太网"></a> 4.3.6 千兆以太网</h4><ul><li>千兆以太网（G比特以太网，GE）：IEEE802.3z<ul><li>兼容10/100M以太网（同时期的两个技术FDDI、ATM不兼容）</li><li>主要工作在全双工模式，若半双工，则需要CSMA/CD技术，可能带来传输距离过短的问题 -&gt; 可使用帧串、帧扩充等方法解决</li><li>编码方式：8B/10B</li></ul></li></ul><h4 id="437-万兆以太网"><a class="markdownIt-Anchor" href="#437-万兆以太网"></a> 4.3.7 万兆以太网</h4><h4 id="438-以太网回顾"><a class="markdownIt-Anchor" href="#438-以太网回顾"></a> 4.3.8 以太网回顾</h4><h3 id="44-无线局域网"><a class="markdownIt-Anchor" href="#44-无线局域网"></a> 4.4 无线局域网</h3><h4 id="441-80211体系结构和协议栈"><a class="markdownIt-Anchor" href="#441-80211体系结构和协议栈"></a> 4.4.1 802.11体系结构和协议栈</h4><ul><li>分布式系统（distribution system）</li><li>自组织网络（ad hoc network）</li><li>MAC子层决定如何分配信道，LLC子层隐藏802系列协议之间的差异，使它们在网络层看起来并无差别。</li></ul><h4 id="442-80211物理层"><a class="markdownIt-Anchor" href="#442-80211物理层"></a> 4.4.2 802.11物理层</h4><ul><li>频段：2.4GHz或5GHz</li></ul><h4 id="443-80211mac子层协议"><a class="markdownIt-Anchor" href="#443-80211mac子层协议"></a> 4.4.3 802.11MAC子层协议</h4><ul><li><mark>CSMA/CA原理</mark>：<ul><li>带<strong>冲突避免</strong>的载波侦听多路访问协议。</li><li>首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。</li><li>接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧ACK。</li><li>发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，会出现一段空闲时间。</li></ul></li><li>隐藏站问题：<ul><li>假设有3无线通信站ABC如下所示：<br />A —&gt; (B &lt;— C)<br />其中B在C的无线电波范围内，但A不在C的无线电波范围内。此时C正在向B传送数据，而A也试图向B传送数据。此时，A不能够监听到B正在忙，而错误的认为此时可以向B传送数据了。如果A向B传送数据，则将导致错误。此即隐藏站问题。其中C是A的隐藏站。</li></ul></li><li>暴露站问题：<ul><li>假设有3无线通信站ABC如下所示：<br />&lt;—–(A B) —&gt; C<br />其中B在A的无线电波范围内，但C不在A的无线电波范围内。此时A正在传送数据（向除B以外的某通信站），而B希望给C发送数据，但是错误地认为该传送过程将会失败（因为B会监听到一次传输，所以它会错误地认为此时不能向C发送数据）。此即暴露站问题。其中A是B的暴露站。</li></ul></li><li>网络分配向量（NAV，Network Allocation Vector）：说明这个帧所属的一系列数据将传输多长时间。</li></ul><h4 id="444-80211帧结构"><a class="markdownIt-Anchor" href="#444-80211帧结构"></a> 4.4.4 802.11帧结构</h4><ul><li>三种类型的帧：数据帧、控制帧和管理帧。</li><li>数据帧：<ul><li>第一个字段是帧控制字段，包括11个子字段：协议版本、类型（比如数据帧10、控制帧01或者管理帧00）、子类型（比如RTS和CTS）、去往DS、来自DS、更多段、重传、电源管理、更多数据、受保护的、顺序。</li><li>第二个字段是持续时间字段，它通告本帧和其确认帧将会占用信道多长时间，按微秒计时。</li><li>接下来是地址字段，包括<strong>3个</strong>地址：<strong>接收方地址、发送方地址、远程端点</strong>。</li><li>序号字段是帧的编号，可用于重复帧的检测。</li><li>数据字段包含了有效载荷，长度可以达到2312字节。</li><li>帧校验序列字段（CRC）。</li></ul></li><li>管理帧的格式与数据帧的格式相同，其数据部分的的格式因子类型的不同而变。</li><li>控制帧要短一些，有帧控制字段、持续时间字段、帧校验序列字段，但只有一个地址，没有数据部分，大多数关键信息都转换成子类型字段。</li></ul><h4 id="445-服务"><a class="markdownIt-Anchor" href="#445-服务"></a> 4.4.5 服务</h4><h3 id="45-宽带无线"><a class="markdownIt-Anchor" href="#45-宽带无线"></a> 4.5 宽带无线</h3><h3 id="46-蓝牙"><a class="markdownIt-Anchor" href="#46-蓝牙"></a> 4.6 蓝牙</h3><h3 id="47-rfid"><a class="markdownIt-Anchor" href="#47-rfid"></a> 4.7 RFID</h3><h3 id="48-数据链路层交换"><a class="markdownIt-Anchor" href="#48-数据链路层交换"></a> 4.8 数据链路层交换</h3><ul><li><p>交换机在交换帧时的三种方式</p><ul><li>存储转发：交换机把整个帧接收下来，计算校验和并检查该帧无错再做策略。（延迟大、出错率小）</li><li>直通交换（贯穿）：在接收时即读入目的端口转发出去。（延迟小、出错率高）</li><li>无分片交换：交换时，读满64字节后才转发，不会转发碎片帧，而冲突碎片往往是小于64字节的非法短帧runt。（延迟不大、出错率不高）</li></ul></li><li><p><mark>学习网桥：</mark></p><ul><li>后向学习法：学习的是源地址。</li><li>泛洪算法：对于每个发向未知目标地址的入境帧，网桥将它输出到所有的端口，但它来的那个输入端口除外。</li><li>若目的端口与源端口相同，则丢弃该帧。</li><li>若目的端口与源端口不同，则转发该帧到目的端口。</li><li>若目的端口未知，则使用泛洪法，将帧送到所有的端口，除了它入境的那个。</li><li>网桥可以进行协议转换。</li></ul></li><li><p><mark>生成树网桥：</mark></p><ul><li>生成树算法：Radia Perlman。</li><li>STP，Spanning Tree Protocol，IEEE802.1D</li><li>每一个网络有一个根网桥；每一个网桥有一个根端口；每一个网段有一个指定端口；剩下的非指定端口不被使用</li><li>生成树算法，可在有物理回路的网络中，生成逻辑无回路的生成树，但并不能保证其中的路径最优。</li><li>非指定端口虽不参与数据帧的转发，但它会侦听树的工作报文。当树上某些端口失效后，非指定端口将重新启用，形成新的生成树。</li></ul></li><li><p>物理层：repeater中继器、hub<br />数据链路层：Bridge、switch<br />网络层：Router<br />传输层：Transport gateway<br />应用层：Application gateway</p></li><li><p>虚拟局域网</p><ul><li>802.1Q标准</li><li>VLAN：一组逻辑上的设备或用户，不考虑地理位置。</li><li>VLAN的实现：<ul><li>基于MAC地址</li><li>基于三层协议</li><li>基于端口（大多数）：在交换机内部有一张VLAN成员配置表</li></ul></li><li>VLAN成员跨越不同交换机（帧标记法）：<ul><li>帧在通过Trunk干线起点时打上标签，干线终点拆除标签（把这个帧涂上它所在VLAN的颜色）</li></ul></li></ul></li></ul><h2 id="第五章网络层"><a class="markdownIt-Anchor" href="#第五章网络层"></a> 第五章：网络层</h2><h3 id="51-网络层的设计问题"><a class="markdownIt-Anchor" href="#51-网络层的设计问题"></a> 5.1 网络层的设计问题</h3><ul><li>数据报网络：无连接的服务，携带目的机地址，一路查路由表。</li><li>虚电路网络：面向连接的服务，不携带目的机地址，携带路径的标号，沿途路由器有带路径标号的路由表。</li><li>标签交换：label switching</li><li>多协议标签交换：MPLS，MultiProtocol Label Switching</li></ul><h3 id="52-路由算法"><a class="markdownIt-Anchor" href="#52-路由算法"></a> 5.2 路由算法</h3><ul><li>非自适应算法（静态路由）和自适应算法（动态路由）</li><li>最优化原理：<ul><li>如果一个路由器 J 处在路由器I到路由器K的最优路径上，那么，从路由器J到路由器K的最优路径也在同样的这条路径上。</li><li>==汇集树（sink tree）：从所有的源到一个指定目标的最优路径的集合构成的一棵以目标节点为根的树。==汇聚树不唯一。路由算法的目的，为所有的路由器发现和使用汇聚树。</li></ul></li><li><strong>距离矢量路由</strong>（distance vector routing）选择算法<ul><li>DV是分布式Bellman-Ford路由算法，常被用于小型网络，RIP是一个典型的DV。</li><li>工作原理：<ul><li>维护：每个路由器维护两个向量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li><li>交换：在邻居路由器之间交换路由信息（矢量）。</li><li>更新：每个路由器根据收到的矢量信息更新自己的路由表。</li></ul></li><li>DV 算法的特点：<ul><li>优点：简单。</li><li>缺点：交换的信息太大；路由信息传播慢，可能导致路径信息不一致；收敛慢；度量计数到无穷、路径环；不适合大型的网络。</li></ul></li><li>可能的问题：<ul><li>路由环路</li><li>无穷计数<ul><li>“好事传千里，坏事传得慢”。</li><li>解决办法：定义最大跳数、加快收敛。</li></ul></li><li>收敛慢<ul><li>收敛：网络查找最佳路径的过程。</li><li>收敛的加快：水平分割、毒性逆转、抑制定时器、触发更新。</li></ul></li><li>因为站得不够高看得不够远，每个路由只从近邻拿信息，无法判断正确与否，可能学习、传播过时信息。全网不断传播错误、过时信息，无法稳定、收敛。</li></ul></li></ul></li><li><strong>链路状态路由</strong>选择算法<ul><li>为解决DV站得不够高看得不够远的问题。</li><li>算法思想：<ul><li>发现邻居：向邻居发Hello包，等待回复了解它们的全球唯一名字。</li><li>设置链路成本：到它的每个邻居的成本度量。<ul><li>链路带宽的反比。</li><li>延迟：发送ECHO包，等待回复，通过测量往返时间RTT，获得合理的延迟估计值。</li></ul></li><li>构造链路状态包：Link State Packet，一个分组，包含发送方标识、序列号（防序列号回转问题，用32bits表示）、年龄（解决路由器崩溃和序列号损坏，每过1s，age-1，age=0则丢弃LSP）、邻居列表、到邻居的成本/度量。基于事件/时钟去触发构造。</li><li>分发链路状态包：这个分组给所有其他的路由器。<ul><li><strong>逆向路径转发</strong>：新的分组到达，若该分组是新的，被从除了来线路外的其他线路转发/泛洪出去；重复分组丢弃，过时分组拒绝。</li><li>保留区：到达的分组不先处理，而是每时钟时间处理一次，期间保留区的相同分组就会被丢弃。</li></ul></li><li>计算新路由：dijkstra到每个路由器的最短路径，最短路树。</li></ul></li></ul></li><li>层次路由<ul><li>网络规模不断增长，路由表成比例增长，消耗路由器内存。</li></ul></li><li>广播路由</li><li>组播路由</li><li>选播路由</li><li>移动主机路由</li><li>自组织网络路由</li></ul><h3 id="53-拥塞控制算法"><a class="markdownIt-Anchor" href="#53-拥塞控制算法"></a> 5.3 拥塞控制算法</h3><ul><li>增加资源<ul><li>在某些点之间使用更多的通道增加带宽（增加通路）</li><li>把流量分散到多条路径</li><li>启用空闲或备份的路由器</li></ul></li><li>降低负载<ul><li>拒绝为某些用户提供服务</li><li>给某些用户的服务降低等级</li><li>让用户更有预见性地安排他们的需求</li></ul></li><li>网络供给</li><li>流量感知路由</li><li>准入控制</li><li>流量限制</li><li>负载脱落<ul><li><mark>随机早期检测（RED，Random Early Detection）</mark></li><li>路由器维护一个运行队列长度的平均值。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。当没有出现期待的回复信息时，受此影响的发送方将会发现丢包，然后传输协议将放慢速度。</li><li>丢失的数据包起到了传递抑制包的同样作用，但却是隐含的，无须路由器发送任何显式信号。</li></ul></li></ul><h3 id="54-服务质量"><a class="markdownIt-Anchor" href="#54-服务质量"></a> 5.4 服务质量</h3><ul><li><mark>四个主要参数：带宽、延迟、抖动和丢失。</mark></li><li>流量整形：用户产生的流量忽大忽小，流量整形就是调节数据传输的平均速率和突发数据流，以减少突发而带来的拥塞、缓存溢出、丢包等问题。<ul><li><mark>漏桶（Leaky Bucket）</mark><ul><li>每个主机连接到网络的接口中都有一个漏桶，即一个优先长度的内部队列。</li><li>当桶中有分组的时候，输出速率是恒定的，当桶空的时候，输出速率是0。</li><li>当一个分组到达满的桶的时候，分组将被丢弃（满则溢）。</li><li>每个时钟周期tick，仅允许一个分组或固定数量的分组发送出去。</li></ul></li><li><mark>令牌桶（Token Bucket）</mark><ul><li>改进了漏桶中桶满溢出的问题，桶满丢令牌而不丢分组。</li><li>允许有上限的数据输出突发。</li><li>令牌桶拥有令牌（tokens），且以每△T秒产生一个令牌的速度往桶中输入令牌。</li><li>一个分组要发送的时候，它必要从桶中取出和获取到一个令牌。</li><li>令牌桶算法允许累积令牌，但最多可以累积 n（令牌桶的容量）个令牌。</li></ul></li><li>其他：资源预留、准入控制、分组调度等。</li></ul></li><li>最大突发时间的计算：<ul><li>设突发时间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 秒。</li><li>已知，令牌桶容量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 字节，令牌到达速率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 字节/秒，最大输出速率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 字节/秒。</li><li>得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>+</mo><mi>R</mi><mi>S</mi><mo>=</mo><mi>M</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">B+ RS = MS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> ，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>B</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>M</mi><mo>−</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S = B/(M-R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 。</li></ul></li></ul><h3 id="55-网络互联"><a class="markdownIt-Anchor" href="#55-网络互联"></a> 5.5 网络互联</h3><ul><li><mark>隧道技术</mark></li><li>MTU（Path Maximum Transmission Unit）：路径最大传输单元</li><li><strong>数据包分段</strong></li></ul><h3 id="56-internet的网络层"><a class="markdownIt-Anchor" href="#56-internet的网络层"></a> 5.6 Internet的网络层</h3><h4 id="561-ipv4协议"><a class="markdownIt-Anchor" href="#561-ipv4协议"></a> 5.6.1 IPv4协议</h4><ul><li>协议版本：4位，IPv4为0100，IPv6为0110</li><li><strong>报头长度（IHL）</strong>：4位，表示IP分组的头部有多长，数据范围为0101~1111，单位是 4 Byte，即最小 20 Byte，最大 60 Byte</li><li>区分服务（ds，Differentiated services）：8位，表示分组的重要程度优先级等，可提供一定的服务质量保证、拥塞控制</li><li><strong>总长度</strong>：16位，表示包括头部和数据的数据报总长度，单位是 1 Byte，最大为 65535 Byte</li><li>标识：16位，标识当前的数据分组的序列号（由发送者来分配，接收方可通过该号码来进行重组）</li><li>一个未使用的位：1位</li><li>标志位：2位，决定分组是否要进行分片<ul><li>DF（Don’t Fragment）：不分段</li><li>MF（More Fragment）：更多的段</li></ul></li><li>分段偏移量：13位，指明了该段在当前数据报中的位置。除了数据报的最后一个段外，其他所有段的长度必须是8字节的倍数。<ul><li>每个数据报最多8192个段，由此支持总长度字段限制的最大数据报。</li><li>分片后接收方可通过分片偏移进行重组。</li><li>为什么要分片？分组穿越的网络 MTU (载重力)不同。</li></ul></li><li><strong>生存时间（TTL）</strong>：8位，单位 hop，每经过一个路由器，重新封装时把TTL生存时间减1，当TTL=0时，分组被丢弃，向源发回一个超时消息。该字段可防止分组在网络中无限循环。最大的生存期为255秒。</li><li><strong>用户协议</strong>：8位，指明它的上层传输层采用的协议，UDP (17)、TCP (6)。</li><li>报头校验和：16位，每一跳必须重新计算头校验和，因为TTL总在不断改变。</li><li>源IP地址</li><li>目的IP地址</li><li>数据报选项：可选、可变长的选项，长度不等，该字段允许主机支持不同的选项，比如安全、源路由、时间戳等。</li><li>填充：将数据报选项字段填充到32位（4字节）的整数倍</li></ul><h4 id="562-ip地址"><a class="markdownIt-Anchor" href="#562-ip地址"></a> 5.6.2 IP地址</h4><ul><li>前缀<ul><li>一个网络对应的一块连续的IP地址空间。</li></ul></li><li>子网<ul><li>IP分组如何送达子网：路由器使用子网掩码来决定分组往哪个子网转发<br />主路由器（边界路由器）：负责和外部联系<br />子网掩码：了解内部网络结构的机制<ul><li>点分十进制：如255.255.255.224</li><li>/网络位数+子网位数：如/27</li><li>目的网络地址 = 目的IP地址 &amp; 子网掩码</li><li>举例：131.108.2.2目的IP地址 &amp; 255.255.255.0子网掩码 = 131.108.2.0子网络地址</li><li>ABC类IP地址的子网掩码分别是：/8、/16、/24<br />子网位由主机位借位而来，剩下的主机位中全0为网络地址、全1为广播地址，不能标识主机。</li></ul></li></ul></li><li><mark>CIDR——无类域间路由</mark><ul><li>如果路由表中有多个表项匹配 (这些表项有不同的子网掩码) ，使用子网掩码最长（子网最小）的那个表项。</li></ul></li><li>分类和特殊寻址<ul><li>A类地址——大型<ul><li>前1×8位是网络部分，后3×8位是主机部分</li><li>第一字节的最高位固定为0，故第一字节取值范围为 0∼127</li><li>全世界的A类地址总共只有128个</li><li>每一个A类网络可容纳 2^24-2个主机</li></ul></li><li>B类地址——中型<ul><li>前2×8位是网络部分，后2×8位是主机部分</li><li>第一字节的最高位固定为10，故第一字节取值范围为 128∼191</li><li>全世界的B类地址总共只有 2^14 个</li><li>每一个B类网络可容纳 2^16-2 个主机</li></ul></li><li>C类地址——小型<ul><li>前3×8位是网络部分，后1×8位是主机部分</li><li>第一字节的最高位固定为110，故第一字节取值范围为 192∼223</li><li>全世界的C类地址总共只有 2^21 个</li><li>每一个C类网络可容纳 254 个主机</li></ul></li><li>区分ABC——看第一字节值的</li><li>D类：用作组播</li><li>E类：用作一些科研</li><li>特殊的保留地址（不分配给特定主机）：<ul><li>网络地址：主机部分全0的地址</li><li>广播地址：主机部分全1的地址</li><li>0.0.0.0：指该主机、该网络，路由表中默认路由的目的地址</li><li>255.255.255.255：泛洪广播地址，为防广播风暴，又退化成本地广播地址</li><li>127.0.0.0：环回地址(Lookback Network)，如127.0.0.1表示本机</li><li>169.254.0.0：非正常地址，不能与外部正常通信</li></ul></li></ul></li><li><mark>NAT——网络地址转换</mark><ul><li>NAT思想：<ul><li>内网使用私人地址，当内网需与外网通信，私人地址转换为合法的global的IP地址</li><li>NAT转换器（NAT Box），维护地址转换表</li></ul></li><li>NAT优点：<ul><li>节省了公有IP地址</li><li>提供了内部网访问外网的灵活性</li><li>有一定的保密性</li></ul></li><li>NAT缺点：<ul><li>违背了IP的结构模型——每个IP地址唯一地标识了一台机器</li><li>将互联网改变成了“面向连接”的网络，NAT转换器维护着连接的状态，一旦它崩溃，连接也没有了</li><li>违背了最基本的协议分层原则，IP是网络层，Port是传输层，跨层工作了</li><li>如果传输层不是采用TCP或UDP，而是采用了其它的协议，NAT将不再工作</li><li>有些应用会在payload中插入IP地址，然后接收方会提取出该IP地址并使用，但是NAT转换器对此一无所知，导致该类应用不再有效</li><li>NAT让一个IP地址可以承载61,440 （65536-4096）个私人地址（超载，PAT）</li></ul></li></ul></li><li><mark>ARP——地址解析协议</mark>：完成主机或者路由器从IP地址到MAC地址的映射<ul><li>ARP思想：<ul><li>将IP地址映射到MAC地址。</li><li>向周围广播：”我是128.1.2.7，谁知道128.1.2.15的MAC地址”。</li><li>128.1.2.15收到询问自己的ARP请求，才回复。</li></ul></li><li>远程主机的MAC地址解析（跨LAN进行ARP）：<ul><li>源将目的MAC地址填上默认网关的MAC</li><li>默认网关解封装后重封装时将源、目的MAC分别变为默认网关MAC、目的机MAC</li></ul></li><li>ARP的优化——ARP表：<ul><li>动态建立、更新、维护ARP表</li><li>机器上线/配置改变时，向周围广播免费ARP（srcIP=trgtIP），告知周边的MAC地址，不期望收到应答，若意外收到应答则表明自己的IP冲突</li><li>收到源的ARP请求非目标机虽不应答，但默默记下源的MAC地址到自己的ARP表</li><li>定时删除超时ARP信息</li><li>静态配置ARP可以解决动态更新的病毒隐患</li></ul></li></ul></li></ul><h2 id="第六章传输层"><a class="markdownIt-Anchor" href="#第六章传输层"></a> 第六章：传输层</h2><h3 id="61-传输服务"><a class="markdownIt-Anchor" href="#61-传输服务"></a> 6.1 传输服务</h3><ul><li>目标：向用户提供高效的、可靠的和成本有效的数据传输服务，用于通常是应用层的进程。</li><li>传输层、网络层分层原因：<ul><li>网络层运行在由承运商操作的路由器上，用户无法真正控制到网络层，只能眼睁睁看着丢包、延迟</li><li>把另一层放在网络层之上，可让用户能够控制道服务质量</li><li>传输层原语独立于网络层原语，而网络层原语会因网络的不同而不同</li><li>两层的作用范围不同<ul><li>网络层负责把数据从源机送达目的机，hostToHost</li><li>传输层负责把数据送到具体的应用进程，endToEnd</li></ul></li></ul></li><li>数据段：<ul><li>TPDU（Transport Protocol Data Unit），传输层协议数据单元。是从传输实体发到对端传输实体的信息</li><li>TPDUs 被封装在分组（packet）中，由网络层交换</li><li>分组被封装在帧（frames）中，由数据链路层交换</li></ul></li><li>传输层两大协议：<ul><li>用户数据报协议，UDP，User Datagram Protocol</li><li>传输控制协议，TCP，Transport Control Protocol</li></ul></li></ul><h3 id="62-传输协议的要素"><a class="markdownIt-Anchor" href="#62-传输协议的要素"></a> 6.2 传输协议的要素</h3><h4 id="621-寻址"><a class="markdownIt-Anchor" href="#621-寻址"></a> 6.2.1 寻址</h4><ul><li>端口：port</li><li>传输服务访问点：TSAP，Transport Service Access Point</li><li>网络服务访问点：NSAP，Network Serivice Access Point，IP地址是NSAP的实例。</li></ul><h4 id="622-连接建立"><a class="markdownIt-Anchor" href="#622-连接建立"></a> 6.2.2 连接建立</h4><ul><li><mark>三次握手</mark><ul><li>(1)客户发送第一个报文，这是一个SYN报文，在这个报文中只有SYN标志置为1。这个报文的作用是使序号同步。</li><li>(2)服务器发送第二个报文，即SYN+ACK报文，其中SYN和ACK标志被置为1。这个报文有两个目的。首先，它是一个用来和对方进行通信的SYN报文。服务器使用这个报文同步初始序号，以便从服务器向客户发送字节。服务器还使用ACK标志确认已从客户端收到了SYN报文，同时给出期望从客户端收到的下一个序号。另外，服务器还定义了客户端要使用的接收窗口的大小。</li><li>(3)客户发送第三个报文。这仅仅是一个ACK报文。它使用ACK标志和确认号字段来确认收到了第二个报文。</li></ul></li></ul><h4 id="623-连接释放"><a class="markdownIt-Anchor" href="#623-连接释放"></a> 6.2.3 连接释放</h4><ul><li>非对称释放</li><li>对称释放</li><li><mark>三次挥手</mark><ul><li>(1)当客户端想关闭TCP连接时，它发送一个TCP报文，把FIN标志位设置为1。</li><li>(2)服务器端在收到这个TCP报文后，把TCP连接即将关闭的消息发送给相应的进程，并发送第二个报文——FIN+ACK报文，以证实从客户端收到了FIN报文，同时也说明，另一个方向的连接也关闭了。</li><li>(3)客户端发送最后一个报文以证实从TCP服务器收到了FIN报文。这个报文包括确认号，它等于从服务器收到的FIN报文的序号加1。</li></ul></li></ul><h4 id="624-差错控制和流量控制"><a class="markdownIt-Anchor" href="#624-差错控制和流量控制"></a> 6.2.4 差错控制和流量控制</h4><h4 id="625-多路复用"><a class="markdownIt-Anchor" href="#625-多路复用"></a> 6.2.5 多路复用</h4><h4 id="626-崩溃恢复"><a class="markdownIt-Anchor" href="#626-崩溃恢复"></a> 6.2.6 崩溃恢复</h4><h3 id="63-拥塞控制"><a class="markdownIt-Anchor" href="#63-拥塞控制"></a> 6.3 拥塞控制</h3><ul><li>AIMD（Additive Increase Multiplicative Decrease）：加法递增乘法递减</li></ul><h3 id="64-internet传输协议udp"><a class="markdownIt-Anchor" href="#64-internet传输协议udp"></a> 6.4 Internet传输协议：UDP</h3><ul><li>UDP数据段头——头部（8字节）+数据：<ul><li>头部第1字段，源端口，16bits</li><li>头部第2字段，目的端口，16bits</li><li>头部第3字段，UDP长度，表示包括头部（8字节）和数据共多少字节，16bits 范围：8~65515</li><li>头部第4字段，校验和，可选(不选择填0)，16bits，校验头部、数据、IP伪头<ul><li>IP伪头：源地址、目的地址、UDP协议号、UDP段（包括头）的字节计数。</li></ul></li></ul></li><li>端口Port：<ul><li>16位，0~65535</li><li>&lt; 1023，知名端口，用于公共应用（保留，全局分配，用于标准服务器），IANA分配</li><li>1024-49151，非特权用户端口，注册端口，比如BT使用6881-6887</li><li>≥ 49152，动态端口，私人端口</li><li>自由端口 free port<ul><li>本地分配、动态随机端口</li></ul></li></ul></li><li>远程过程调用（RPC，Remote Procedure Call）</li><li>RTP（Real-time Transport Protocol）：实时传输协议</li><li>RTCP（Real-time Transport Control Protocol）：实时传输控制协议</li></ul><h3 id="65-internet传输协议tcp"><a class="markdownIt-Anchor" href="#65-internet传输协议tcp"></a> 6.5 Internet传输协议：TCP</h3><ul><li><p>格式：</p><ul><li>head，20字节的头部（去掉可选项）。</li><li>Options，变长的数据字段/域（可是0个或更多字节）。</li><li>Data</li><li>头部第1字段，源端口，16bits。</li><li>头部第2字段，目的端口，16bits。</li><li>头部第3字段，序列号，表示一个字节的编号，32bits。<ul><li>ISNs(initial sequence numbers)：初始序列号，是随机产生的。</li><li>SYN：携带了ISNs 和SYN 控制位的数据段。</li></ul></li><li>头部第4字段，确认号，表示期望对方发来的字节的编号，32bits。<ul><li>TCP的可靠传输保证，采用肯定确认机制和累计确认技术。</li><li>如确认号是500，表示收到了发方发送的499、498…等字节。下次我就可以发500序列号的字节过去了。</li></ul></li><li>头部第5字段，TCP段头长度，单位是4字节，4bits。</li><li>下一字段是保留字段，现在逐步启用做拥塞控制。</li><li>头部第6、7、8、9、10、11字段，控制比特，URG、ACK、PSH、RST、SYN、FIN，各1bit。<ul><li>URG：当紧急指针使用的时候，URG 被置为1，表明有紧急数据，必须先处理。</li><li>ACK：等于1表示确认号有效，启用了捎带确认，等于0表示确认号无效。</li><li>PSH：表示这是带有PUSH标志的数据，接收方收到这样的数据，应该立刻送到上层，而不需要缓存它。</li><li>RST：被用来重置一个已经混乱的连接。如果在连接建立阶段，就直接拒绝建立连接。</li><li>SYN：用在连接建立过程中。与ACK配合使用可以表示连接请求(SYN=1,ACK=0)或连接接收(SYN=1,ACK=1)。</li><li>FIN：被用来释放连接，表示发送方已经没有数据要传输，但可继续接收数据。</li></ul></li><li>头部第12字段，窗口尺寸，告诉对方可以发送的数据字节数，即从确认字节号开始，连续发送的字节总数，16bits。<ul><li>为避免接收方被大量涌入的数据所淹没，TCP实体进行了流量控制，用可变长的滑动窗口来完成，这个窗口尺寸的大小取决于接收方。</li></ul></li><li>头部第13字段，校验和，16bits。</li><li>头部第14字段，紧急指针，与URG控制位配合使用，16bits。<ul><li>紧急指针是一个对于当前序列号的字节偏移量，标明紧急数据从哪里开始。</li></ul></li><li>Options，选项域，提供了一种增加基本头没有包含内容的方法。</li></ul></li><li><p><strong>TCP连接的建立</strong></p><ul><li>Host1发送连接请求，控制位SYN=1, ACK=0。SEQ=x，x是随机产生的初始序列号。</li><li>Host2接收后，回答，控制位SYN=1, ACK=1。SEQ=y，y是随机产生的初始序列号，ACK Number=x+1，表示对x之前的字节都确认收到。</li><li>Host1接收应答，回发最后的确认，控制位SYN=0, ACK=1。SEQ=x+1，ACK Number=y+1，表示对y之前的字节确认收到。</li></ul></li><li><p><strong>TCP连接的释放</strong></p><ul><li>任何一方没数据要发送时，都可发送一个FIN置位的TCP数据段。</li><li>当FIN被确认时，该方式的连接被关闭。</li><li>当双向连接都关闭后，连接释放。</li></ul><p>TCP连接的释放是对称，要求两方的释放请求都被确认，而一次只能确认一个，这有一些问题，解决方案是把释放连接的决定权交给请求者：</p><ul><li>一方发送 连接释放请求DR（Disconnect Request），并期待对方的确认ACK。</li><li>DR到达接收端，它回发ACK，并且也发送一个DR。</li><li>ACK到达发送端，连接释放；同时回发确认ACK，当这个ACK到达接收端，反方向的连接也释放。</li></ul><p>采用定时器：</p><ul><li>避免DR、ACK丢失而引发的问题，在任何时候发出DR的同时，都启动一个定时器。</li><li>如果一方发送了FIN置位的DR数据段出去，若在定时器超时都没收到应答，释放连接。</li><li>另一方最终也会注意到连接的对方已不在，即定时器超时后连接释放。</li></ul><p>杀死半开放连接：</p><ul><li>半开放连接：最初的DR及其重传都丢失了的话，发送者因超时放弃继续发送且释放连接，但另一端却不知道这些情况仍处于活跃的状态。</li><li>杀死方式：在一定时间内没有TPDUs到达则单方面自动释放；同时利用定时器，超时时自动发一个哑TPDU（dummy TPDU），避免被对方释放。</li></ul></li><li><p>TCP传输策略：</p><ul><li>类似LLC，TCP链路传输，采用了基本的肯定确认重传机制。</li><li>使用Window Size字段进行流量控制：</li><li>当窗口数为0时，发送者不能正常发送数据段，除非：<ul><li>Urgent紧急数据。比如用户想杀掉远端机器上的进程时</li><li>发送者可发送一个字节的数据段，以便让接受者再次发送(期待接收的字节号或ACK, WIN)，以免死锁</li></ul></li><li>优化接收端，不要急着回复确认<ul><li>接收端推迟500ms发送确认分组和窗口更新，以便可免费搭载在处理后的回显分组内（free ride便车）</li></ul></li><li>优化发送端——Nagle’s Algorithm<ul><li>当数据以一次一字节的速度到达的时候，只发送第一个字节，然后将后续的字节缓存起来，直到发出的字节得到确认；<br />将缓存起来的字节在一个数据段中发出，再继续缓存，直到发出的数据得到确认。</li></ul></li></ul></li><li><p>傻瓜窗口综合征：</p><ul><li>silly window syndrome problem</li><li>当有大块数据被传递给发送端TCP实体，但接收端的交互式应用每次只读取一个字节的时候，往返发送的有效信息大小与代价相差甚远。</li><li>解决方案——Clark解决方案<ul><li>阻止接收方发送只有1个字节的窗口更新，相反，它必须等待一段时间，当有了一定数量的空间之后再告诉发送方。</li><li>接收方可以可以维护一个内部缓冲，且阻塞上层应用的READ 请求，直到它有大块的数据提供。</li></ul></li></ul></li><li><p>发送方和接收方的优化：</p><ul><li>发送方，Nagle’s Algorithm。尽量不发送数据含量小的数据段；缓存应用层数据到一定量才发送。</li><li>接收方，Clark’s Solution。不请求对方发送短数据段(Window Size)；延迟窗口变更信息，使接收缓冲区足够大。</li></ul></li><li><p>TCP拥塞控制</p><p>虽然网络层也管理拥塞，但大多数管理任务由TCP完成。</p><p>因为针对拥塞的真正解决方案是减慢数据率，所以TCP拥塞控制遵循分组守恒原则，即老分组离开后新分组才注入网络。</p><p>拥塞检测：</p><ul><li>Congestion Detection</li><li>所有的互联网TCP算法都假定超时是由于拥塞引起的，并通过监视超时的情况来判断是否出现问题。</li></ul><p>拥塞控制：</p><ul><li>Congestion Control</li><li>当一个连接建立的时候，双方选择一个合适的窗口大小，接收方根据自己的缓冲区大小来指定窗口的大小。</li><li>若发送者遵循这窗口大小的限制，则接收端不会出现缓冲区溢出的问题，但可能由于网络内部的拥塞而发生问题。</li></ul><p>拥塞的两种情形：</p><ul><li>接收方容量不足，比如快速的网络向小容量接收方传输数据。</li><li>网络容量瓶颈，比如慢速的网络向大容量的接收方传输数据。</li></ul><p>拥塞控制：</p><ul><li>针对拥塞的两种情形，单独解决问题。</li><li>发送者维护两个窗口：<ul><li>流量控制窗口，反映了目前接收者的处理能力（容易获取）。</li><li>拥塞窗口cwnd，反映了目前网络容量（难以获取），也就是发送端可以往网络发送的字节数。</li><li>发送数据大小 = 上述两个窗口的较小值</li></ul></li></ul><p><mark>慢启动算法Slow Start</mark>：</p><ul><li>获取拥塞窗口大小。</li><li>指数的增长：连接建立时，发送者用当前使用的最大数据段长度MaxSeqL初始化拥塞窗口，然后发送一个最大的数据段，若在定时器超时前得到确认，则将拥塞窗口翻倍，发送两个数据段，直到超时。</li><li>线性的增长：采用阈值参数，初始为64K，拥塞窗口增长到阈值时，就停止指数增长，按照线性增长，即每次成功的传输让拥塞窗口增加一个最大的数据段长度。<br />当超时发生时，阈值降为当前拥塞窗口的一半，同时将拥塞窗口重设为一个最大的数据段的长度，重新开启新一次的慢启动。</li><li>下图，一开始阈值Threshold=32k，当指数增长到阈值时改为线性增长，在第14次发送时超时，阈值设为拥塞窗口的一半20k，且发送窗口重置为一个数据段大小，重新开启新一次的慢启动。</li><li>线性增长，可将窗口尝试粒度变小，以获得更准确的拥塞窗口值。</li><li>TCP慢启动算法就是这样不断超时、不断重启，尝试出的拥塞窗口值也随之网络状况变化而变化，达到拥塞控制的目的。</li><li>快速恢复：重新慢启动时，拥塞窗口值可以不重置为一个数据段大小，而是设置为阈值大小，从这里开始直接线性增长。</li></ul></li><li><p>TCP定时器等</p><p>TCP采用肯定确认重传技术，保证每一个字节的可靠传输。</p><p>重传定时器：</p><ul><li>retransmission timer</li><li>为了解决数据段丢失的问题，每发一个数据段都会启动一个重传定时器。</li><li>其时间设置需要良好的考量，设置过长则等待过长，设置过短引发频繁超时重传。</li></ul><p>持续定时器：</p><ul><li>persistence timer</li><li>用来避免以下死锁deadlock发生。<ul><li>接收方发送了一个窗口数为零的确认（窗口更新），告诉发送方等待。<br />稍后，接收方空出了缓冲，发送更新窗口的数据段，但是该分组丢失啦！<br />现在，收发双方都在等待对方发送数据段过来，但永远等不到，死锁产生。</li></ul></li><li>发送方在收到win=0时，启动一个持续定时器，如果定时器超时没有收到更新窗口，则发送一个探测数据段，引发对方重新发出更新窗口。</li></ul><p>保活定时器：</p><ul><li>keep-alive timer</li><li>用来检查连接是否存活，当一个连接空闲的时间超过保活定时器的时间，该连接将被杀掉。</li></ul><p>在关闭时刻处于TIMED WAIT状态中使用的定时器：</p><ul><li>运行两倍的最大分组生存时间，以确保连接关闭之后，该连接上的所有分组都完全消失。</li></ul></li></ul><h2 id="第七章应用层"><a class="markdownIt-Anchor" href="#第七章应用层"></a> 第七章：应用层</h2><h3 id="71-dns"><a class="markdownIt-Anchor" href="#71-dns"></a> 7.1 DNS</h3><ul><li>原理：<ul><li>1.应用程序以域名作为参数调用解析器。</li><li>2.解析器发送UDP分组给本地DNS服务器。</li><li>3.如果待查询域名在该DNS服务器的管辖范围内或存在缓存则返回资源记录给解析器。</li><li>4.反之则本地DNS服务器向根域名服务器发送一条查询此域的迭代查询请求。</li><li>5.根域名服务器会返回所查询域的IP地址或者本地DNS服务器下一步应该向之查询的域名服务器地址。</li><li>6.本地域名服务器向正确的域名服务器查询到IP后返回给解析器。同时缓存查询过的域名服务器地址。</li></ul></li></ul><h3 id="72-邮件"><a class="markdownIt-Anchor" href="#72-邮件"></a> 7.2 邮件</h3><ul><li>协议：SMTP、POP</li></ul><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><p>《计算机网络》第五版 严伟 潘爱民 译</p></li><li><p>tt学长的笔记：<a href="https://zhangt.top/CS/Computer-Network-Study-Notes">https://zhangt.top/CS/Computer-Network-Study-Notes</a></p></li><li><p>MOOC华南理工大学《计算机网络》by 袁华：<a href="https://www.icourse163.org/learn/SCUT-1002700002?tid=1463162477#/learn/announce">https://www.icourse163.org/learn/SCUT-1002700002?tid=1463162477#/learn/announce</a></p></li><li><p>2019王道考研计算机网络：<a href="https://www.bilibili.com/video/BV19E411D78Q?from=search&amp;seid=5912359002984844436">https://www.bilibili.com/video/BV19E411D78Q?from=search&amp;seid=5912359002984844436</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;How to build a network?&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://tongyiheng.top/categories/Computer-Science/"/>
    
    <category term="Computer Networks" scheme="https://tongyiheng.top/categories/Computer-Science/Computer-Networks/"/>
    
    
    <category term="network" scheme="https://tongyiheng.top/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Lunch Meeting（二）</title>
    <link href="https://tongyiheng.top/2021/04/20/Secret/JingYing/lunch-meeting-2nd/"/>
    <id>https://tongyiheng.top/2021/04/20/Secret/JingYing/lunch-meeting-2nd/</id>
    <published>2021-04-20T09:10:38.000Z</published>
    <updated>2021-09-30T13:08:13.163Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6242b7a292d927b57cc3c3bb5e30829a9750634c277f3a9426163076f96efac7">1a1d9abe5672c7bc37baaec17a6e5159515451f0571d00edcbb5bd7cff710270b2c80bd894018ec924b79a1de86d11859f11e6abf8457cc70356e98dcdb85dfa6f1d0d86667833d1ba6b56a4762d0b6c9d4e2862913fa823906570c608dc0b0f2fc371d32d68f6dd4a36abb58da763b8b8a4e39ab2a87fc073a04840e85af9768b80cc932b3f02f0384da513edb6f4bc8f0c939d8d51ff91a1aba402b4e690d0362b0c97cd2a2d26b5ff9d985d1c52f43642a8d5fbd59fbbcb25d92e9cf45fead2cbc7dc54f9206271bbaf74e306fffe6b42d8aa1e282e0f27ffa103a4a0ecaa60d6d600e2662ee2c4e51e47fd07b5024b27a500a84716e27b802ad412288b2c099eba1b9b26f924f0d9e617d23f81dd143953ae063403ff436c91d6ddc12ad4edea7e7e98c45ab18f1d50bc54d6d829e42dcd123e83d1d22a3c9e77d6cec038b5324a8170c543cff222a504920978b0ccff8d430e24ab7ff88360a533c929a3c76c51bb568994fe964e93bbb89567c75150f6b5a195e1b44171b761f6c9e15903db753dae8694426efbdd9f0f7e142bec198917292723a502fc98182877f7fee38e7397f36252216ee201fd8a73ddef93c2a32ae6ca17440a271514fcd00a664d752cf3ac2844e9605a5d1ad780c748f352f733dc424511384407c87747c998384f33b0d850aff805b1314cd4ce881d7134108d6337b47d15d568fd9c3f354a9b625c69d5a7a3d87d3cd539b61043155d673912cbd078a8929a234eae246d75f0af82fac3c11de5cfe4ed9aa3708372a661a18228505d8cc7a81a0b8a50a59681c31d432619d693beee8b848366dbf0027327bdb0a5897443b027410fea4373bcf21946b55dc105f4b95f2ef5f139ecb3126207fefc101b48241e8df46bcb44d161ed658d2657ad86f119ddb17364f3e46de945ecdd612187bcb45dfbaf9b440207180a82a40a37ebccc04ce4285b0cf5465ae981de58c5946f0c7d2318a321d2f3517573fbe7f135506d08af7f76b3d992a7e8ba60d3544b5ba687c091085448d3ac3689936a52d325f62fd6a68e93857be448e25e206e946e831f299ab578c90e68e2e0e985656c58278de41aa58d7bef1dbc6a38ca054b73d244d725af7ea247031274b81c550843f7177510eab94afd6fe38e8ef482033069828e3b6e7d3c6042f81e0109adcef4214496bbc6a414415b19dc13c1543b905a4c176291fbf0ede8b09d0f7989f741efccf972b789b14366ca183ac1d4b4be02784c2f084e7f8fd86e13fe6fc97f9db7b0ee9db673de1e1bef3a183f62ba27475ae72c372f41a85f031cf155b268dccb043e071aff39c83521d8f0f83306e15f0e46bcaf2a87c5966490e2ed923f3df6f91a4ffd3934b55c642140a43097c62c59ea5bddb5a8d8753206a877a19f1ac27b9700a57ec8afc45de83edfa5a7e422ba7707178cef2fd8f0db15c38f3ffa04a2f974055dcbebba6d83080a6213caa4bcdcf12c75245a048661c50dc6cdf38ad94de7649f8fb5c8a7ccb192adcc585e83c3edebc07399ba1793394ed6d78a4c6c189f1de3bcc8270b89ae45682e138c448e1b37181c0b3f9a32ab4d218826a7f26cac9e25305bb10a6489ea7b81898a3b432f0f1f0b6b53326a92575e808c564f998db0945ac43b26c498060bd6e644c4f66031ac2f42119712ab0de19dee42169483c20c0b97fa3b231d0a731c00c628df4ac96ab246e2154d27deb3c6980f6ad890d68e922156279c1c45c5c943b190c43bc298d1b5c19c3c96239de47c2685d7802d9965b018297071d33ea28abaaf219dc41f9ce5e14d724afc79503c70eb20837a0f98d6ba0efab7be5d7a5bd7afef5a71e281469348590d4f86ed6631f9e2de3b1a51b970fd73cee1c28a8f6234923a157d0dc003fa5500b5dbec9ebf050c8055c4762359c5007d9fefae6102d6d4510ac45ff9f7f490c4a140ef3a72a12346e88c7e87489381a74b98ccbbd367d7797f3a45fff9bb319feac90593288c476696273ddd0a56133d0fd12da2f886234d70221b62f1d912627c6c688f2cbbfe18afa94ee2eb33f564bfd7ed2dd995b35d585c58134c577925f91e3ea7eb75f66931e18da61e9288ce88eaa0dce2e93558809d1847f48ae3c411b7edcb985aa197b31ac92804d26c57316cee5b679f66e85f459096cc2cb05265bc4d93d023bddcc08e38f0e902d77add473e4245f661bc936a9498e7332a34e53d8f194c86310917a9d2471e1384d8cec0172b60371d0897fdf87590c1f320dd38bcb3605f297853bf41b126fa7f9a0a75845487d763e301dc2ce266549085e5f7f7d665db35c16fdbb2f8d7d167c0255ac2a65123438ff6da885bcea016f6c6df1aa10a899823ef8d82195fc075ae223ba09ba08308932d7eef0acbd82662648163d5205afa70f5d82e7eeba0ac21736968203db8883dfff40e8ef5167eacfcbf4ce9e003b3c1bdaf6a50f7e75f62127992825197ad67bfe4849269769a89a6c132efffb93fcc87af7de1be891060baa2fc166568d5cd072b554d77a912c14400ab6fedc13964b613e963a86c4f11cc69df7674ec52d660d451a86d2ae27ad5c197044446cacfcc1890a15ef7943d4657a1c2d7174ae92d19e4d129962a09711606b19e48d9ee7e49cedd78df4c849ea343bb3a9a202f13c47409216b618cfcc677209fb7e929243f173cff80fb218bdbaafc6ab0d8818db27dcad00797f3b439ae98d4ad568c59885daa6da59d04073ab7b84f52e471a87f87e2ec7e7622fb2c6a2ab58eb7b3c926386a8f85a7891d2fcea58e24af1cec834cd17f31ae1f77f592d23c4a1f2eb9f9be2e607d4f91be2eb590d57d35570fa2f27100082946a54330fb2848ca9aeca5e57d691930cf6730cc2c44bcc3547241308acb158ba2dfcd0f92c4bd9f0ac2b7c474fbbcec9980807f765ecc4497816b1cd6e161022261d076ba9ab8cba13b43f6f321bd3edab40a6b31860c02980289aed4e5cdec93a2341dbde6f893dabfb7c87be360190bfd715cbe8ba3c9dbb1166759deba637b4de6a7bd0ee5af58c8afe1f189c01dba83369c9da193cbcf4693570e51c983b86b314ca931be4d9a9250f1edd3faeae6a233e73809bc23f70a7c34b8dc950860cf04e6b394f015f6c2d01e11ac4c37710bde09ba3069d58e2c2ab13e466b19499fe66959c8d45cd7dcbf1a9a773d2a3d002a78167fcfdb572cd5164f14f1c46937f43875358490793997f990964aff8ed45df9d6c6fd189898ff405d76a49935a9d8177dbcdb2e5e522dbc22105b3bb745009ac158b24aa2dee0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">输入密码，查看文章</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Record the 2nd lunch meeting.</summary>
    
    
    
    <category term="Secret" scheme="https://tongyiheng.top/categories/Secret/"/>
    
    
  </entry>
  
  <entry>
    <title>Lunch Meeting（一）</title>
    <link href="https://tongyiheng.top/2021/04/20/Secret/JingYing/lunch-meeting-1st/"/>
    <id>https://tongyiheng.top/2021/04/20/Secret/JingYing/lunch-meeting-1st/</id>
    <published>2021-04-20T08:40:46.000Z</published>
    <updated>2022-04-07T02:43:42.793Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7d0b0d54d85d45374271014dfd715c810d1495be83c28dd39ca0232d0e27dda0">1a1d9abe5672c7bc37baaec17a6e5159515451f0571d00edcbb5bd7cff710270a8fba6795f0fa45552155e3314c529b9430dd98844ed59e1d3849ba2f9801aa179a362a6c66bc4e171789d8f46e5ed6e05586456ad0fa87bd468ffe3c71d7082d2c9955a2a23b038d97fa88891783f442bcfeae19275dc45ea2232ee5e593c91caf567e6f43ade044b037fa83b422a20f5f6609b53b606527aeed509f182500daea841a9f24032752a62684e443dcb6bd522d0cd938cb09c27ee7033e4f27cac7c861568705640a74e1bcd866bc2151c7fa330ef34599cb47c1010dd8d8c573a85a7eaca354b345790f1dba17507774346f6e47cabd85c6c8fc429865de1acd549a5ef39955b2ffbbc30e2840cc769b23c1dbefb4a33c65f12229d537aa7e265780959db24510e3483ea4781a99a6bd7d094afea90cf4a4727919a701e0287037b618cf82506ad4fe6942961a35a6e3c4c5eaaa9a76a6c523e4d9c216274795421b7e5b40b3dbc84b05b0225cc04125808ebf50bb877c79d17cd7f623e017e47ba60655af40e53ab6b5319f1712aa08a6a9e3925e9074863c5a1f7c151f31cba28aca970e2eaef9b9f713ec31140d2402b39ff2cec97a1bbb11c4a396d2a0d91119718aeaeb9a9d7ba3697a6efe85482fe17a3aebb2e3099b04e3e318fb68e55644806b61d10ce05af275f7da2ed84948c3985eace3009e07c25bd272234f86e2fcc437ade5e8090a004df40f23de06554bbc3c702a3f9a57973bc593a27a54543096745d65ca77dbabf921debfbc744b1924d25997c77816e75ec0da49d172a00aca2264f690f477b00af8fa0ba276664e766bf9bb783f9c4a14955b116b8453fb982c7eb71bc96d1c052efa0ef14891150d6716c4367c4d138ef938b7ad1f371a0f2e3a09cca61b82085c1b8a79bd804de7840fcb40ce18f95977d32e4432e812d4266bca0cba9964cf9a75f47acabb118a768154845bda692757350f425e6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">输入密码，查看文章</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Record the 1st lunch meeting.</summary>
    
    
    
    <category term="Secret" scheme="https://tongyiheng.top/categories/Secret/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Studio Code环境配置和使用技巧</title>
    <link href="https://tongyiheng.top/2021/03/20/Configuration/vscode/"/>
    <id>https://tongyiheng.top/2021/03/20/Configuration/vscode/</id>
    <published>2021-03-20T12:21:35.000Z</published>
    <updated>2022-04-07T02:44:18.104Z</updated>
    
    <content type="html"><![CDATA[<p>This is different from most blogs and videos about the configuration for vscode and it takes only 2 minutes starting from zero.</p><span id="more"></span><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>无数的博客和视频都在讲怎么配置vscode的环境，但99%都会教你怎么copy他们在用的json文件，解释一大通有的没的，不是说json文件的含义不重要，只是作为一个beginner关注点不在这里，而是我怎么配才能跑出来一个<code>Hello World</code>。横向对比不同博客提供的json文件，你会发现千差万别，然后开始怀疑到底谁的json文件是对的或者纠结到底用谁的…</p><p>这篇博客不会摆长篇的json文件让你copy，而是让你通过vscode的选项生成json文件，以最快的速度能够在vscode中run code successfully，最后根据自己的需要修改一些json文件的配置选项。</p><p>Windows:下载mingw，添加环境变量，然后在文件夹下新建测试文件，点击运行和调试，在弹出的窗口中直接选择gcc或g++即可自动生成json文件。</p><p>Linux:打开Terminal通过<code>sudo apt install</code>安装gcc和g++，然后在文件夹下新建测试文件，点击运行和调试，在弹出的窗口中直接选择gcc或g++即可自动生成json文件。</p><h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2><h3 id="step1-下载mingw"><a class="markdownIt-Anchor" href="#step1-下载mingw"></a> Step1: 下载MinGW</h3><p>官网下载地址:  <a href="https://sourceforge.net/projects/mingw-w64/">MinGW-w64 - for 32 and 64 bit Windows</a></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210605.png" alt="1" /></p><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210606.png" alt="2" /></p><p>不同版本区别如下：<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210607.png" alt="3" /></p><p>这里建议选择x86_64-posix-sehz。下载后，解压到自己常用的软件安装路径下，这里以D盘为例。<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210608.png" alt="4" /></p><h3 id="step2-添加环境变量"><a class="markdownIt-Anchor" href="#step2-添加环境变量"></a> Step2: 添加环境变量</h3><p>1.以windows10为例，右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量。<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210609.png" alt="5" /></p><p>2.找到系统变量下的Path，点击编辑，新建，将bin目录的路径复制即可。<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210610.png" alt="6" /><br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210611.png" alt="7" /><br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210612.png" alt="8" /></p><h3 id="step3-生成json文件"><a class="markdownIt-Anchor" href="#step3-生成json文件"></a> Step3: 生成json文件</h3><p>1.打开vscode，选择或新建一个空文件夹目录打开作为项目目录。<br />2.新建<code>test.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>Ctrl+F5</code>以非调试模式运行<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/202110151325422.png" alt="9" /><br />4.选择C++(GDB/LLDB)<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/202110151327232.png" alt="10" /><br />5.选择g++.exe<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/202110151331621.png" alt="11" /><br />点击终端，已经正常运行显示结果。</p><h3 id="step4-运行和调试"><a class="markdownIt-Anchor" href="#step4-运行和调试"></a> Step4: 运行和调试</h3><p><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210613.png" alt="12" /></p><p>launch.json文件中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口，true使用控制台（小黑框），false使用内置终端  </span><br></pre></td></tr></table></figure><p>若使用控制台，需要在main函数return之前暂停一下，否则小黑框会一闪而过，可以使用stdlib.h库中的system(“pause”)，也可简单地使用getchar()。<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210615.png" alt="13" /><br />若使用内置终端，则会直接在内置的终端输出。<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210614.png" alt="14" /></p><p>调试过程与其他IDE类似，略。</p><p><strong>Hint</strong>: 使用freopen重定向输入输出流，可以不用每次都复制一遍输入，或者无法辨别某个数据是输入还是输出（不方便比对正确结果）。<br />Demo:<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210616.png" alt="15" /></p><h3 id="插件推荐"><a class="markdownIt-Anchor" href="#插件推荐"></a> 插件推荐</h3><p>1.Code Runner<br />安装后即可直接运行代码，使用内置终端。一些设置如下：<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210617.png" alt="16" /><br /><strong>Warning</strong>: 一定要将“<strong>Run In Terminal</strong>”的选项勾上，否则运行之后你找不到任何地方可以输入数据！</p><p>2.Theme<br />Light: Atom one light, Night Owl Light, GitHub Light.<br />Dark: One Dark Pro, Dark+.</p><p>3.Icon: Material Icon Theme.</p><p>4.filesize: 统计文件大小。</p><p>5.gitlens: 方便用git。</p><h2 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h2><p>略<br />真的是非常easy啊！毕竟，一个连虚拟机或者双系统都拥有的人难道还不会配vscode吗？</p><h2 id="update"><a class="markdownIt-Anchor" href="#update"></a> Update</h2><p>1.2021-03-27: C<ins>17标准不支持#include&lt;bits/stdc</ins>.h&gt;，编译时会报一长串错误，C<ins>14标准支持，如果想使用这个头文件，可以在json文件中将C</ins>标准改为C++14。终于解决了一个困扰已久的问题。<br />2.2021-04-23：vscode-cpptools占用C盘空间过大问题<br />vscode-cpptools中是为了加速cpp编译的预编译文件，默认为5120MB约为5G，可以改为512MB（给vscode个面子）或者0（我觉得不过分）。<br /><img src="https://raw.githubusercontent.com/TongYiheng/MarkdownPictures/main/vscode/20210627210618.png" alt="14" /><br />点击文件-&gt;首选项-&gt;设置-&gt;搜索C_Cpp.intelliSenseCacheSize-&gt;设置大小</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;This is different from most blogs and videos about the configuration for vscode and it takes only 2 minutes starting from zero.&lt;/p&gt;</summary>
    
    
    
    <category term="Configuration" scheme="https://tongyiheng.top/categories/Configuration/"/>
    
    
    <category term="vscode" scheme="https://tongyiheng.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://tongyiheng.top/2020/12/31/CS/DataStructures/"/>
    <id>https://tongyiheng.top/2020/12/31/CS/DataStructures/</id>
    <published>2020-12-31T13:13:36.000Z</published>
    <updated>2022-01-03T11:34:58.067Z</updated>
    
    <content type="html"><![CDATA[<p>Revision notes of the course “<strong>Data Structure</strong>”</p><span id="more"></span><p><mark>不在实验中的章节：</mark></p><ol><li>跳表</li><li>AVL树 B树 HBLT树</li></ol><p><mark>要记的东西：</mark></p><ol><li>chain的复制构造函数，析构函数</li><li>稀疏矩阵的操作</li><li>栈在表达式计算的应用</li><li>散列的课后题、删除操作</li><li>链表散列和线性探查的平均性能公式</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Revision notes of the course “&lt;strong&gt;Data Structure&lt;/strong&gt;”&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://tongyiheng.top/categories/Computer-Science/"/>
    
    <category term="Data Structures" scheme="https://tongyiheng.top/categories/Computer-Science/Data-Structures/"/>
    
    
    <category term="data structure" scheme="https://tongyiheng.top/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统</title>
    <link href="https://tongyiheng.top/2020/12/31/CS/DatabaseSystem/"/>
    <id>https://tongyiheng.top/2020/12/31/CS/DatabaseSystem/</id>
    <published>2020-12-31T13:12:24.000Z</published>
    <updated>2021-11-17T13:32:22.992Z</updated>
    
    <content type="html"><![CDATA[<p>Revision notes of the course “<strong>Database System</strong>”</p><span id="more"></span><p><mark>证明题：</mark></p><ol><li>BCNF一定是3NF（定义证明）</li><li>无损连接的充分条件（见PPT）</li><li>4NF一定是BCNF（定义证明，见课本）</li><li>两阶段封锁协议保证可串行化（见作业或真题答案）以及严格两阶段封锁协议（提交顺序与封锁点顺序一致）</li></ol><p><mark>SQL和关系代数关系演算：</mark></p><ol><li>全部的概念的SQL 关系代数 关系演算。</li><li>稍微难一点的关系演算，看课后题。</li></ol><p><mark>背一些概念</mark><br />DBMS：由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。<br />超码：是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组。<br />候选码：最小的超码。<br />主码：被数据库设计者选中的、主要用来在一个关系中区分不同元组的候选码。<br />参照完整性约束：在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值。<br />数据定义语言：提供定义关系模式、删除关系以及修改关系模式的命令。<br />数据操纵语言：提供从数据库查询信息，以及在数据库中插入元组、删除元组、修改元组的能力。<br />视图的优点：方便查询、方便安全性（选某些行、列、属性开放查询）<br />弱实体集：没有足够的属性以形成主码的实体集。<br />强实体集：有主码的实体集。<br />标识性联系从弱实体集到强实体集多对一，弱实体集在联系中的参与是全部的。弱实体集的主码由标识实体集的主码加上该弱实体集的分辨符构成。</p><p>1NF：关系模式R的所有属性的域都是原子的。<br />F+：能够从给定F集合推导出的所有函数依赖的集合。<br />BCNF：对F+所有形如alpha-&gt;beta的函数依赖，下面至少有一项成立：</p><ul><li>alpha-&gt;beta是平凡的函数依赖</li><li>alpha是模式R的一个超码</li></ul><p>任何只包含两个属性的模式都属于BCNF。<br />3NF：对F+所有形如alpha-&gt;beta的函数依赖，下面至少有一项成立：</p><ul><li>alpha-&gt;beta是平凡的函数依赖</li><li>alpha是模式R的一个超码</li><li>beta-alpha的每个属性A都包含于R的一个候选码中</li></ul><p>F的闭包是被F逻辑蕴含的所有函数依赖的集合，记为F+。<br />如果去除函数依赖中的一个属性不改变该函数依赖集的闭包，则称该属性是无关的。</p><p>无损分解：令R1和R2为R的分解，如果用两个关系模式r1(R1)和r2(R2)替代r®时没有信息损失，称该分解是无损分解。<br />4NF：对D+中所有形如alpha-&gt;-&gt;beta的多值依赖，至少有以下一项成立：</p><ul><li>alpha-&gt;-&gt;beta是平凡的多值依赖</li><li>alpha是R的一个超码</li></ul><p><mark>CH8</mark><br />Armstrong公理证明、正则覆盖定义和求解、BCNF分解、3NF分解<br />保持依赖的定义和判定，BCNF和3NF的判定</p><p><mark>注意：</mark><br />1.关系代数的投影是去除重复的。<br />2.关系代数中赋值运算，前面用箭头，最后result用等号。<br />3.有时间看一眼SQL的实验。<br />4.注意写SQL结果是关系，画成表！！！<br />5.想一下校园卡门禁系统或者用餐系统，看一下P159大学模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Revision notes of the course “&lt;strong&gt;Database System&lt;/strong&gt;”&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://tongyiheng.top/categories/Computer-Science/"/>
    
    <category term="Database System" scheme="https://tongyiheng.top/categories/Computer-Science/Database-System/"/>
    
    
    <category term="database" scheme="https://tongyiheng.top/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>DSA：（十二）图</title>
    <link href="https://tongyiheng.top/2020/12/23/CS/DSA/DSA_12/"/>
    <id>https://tongyiheng.top/2020/12/23/CS/DSA/DSA_12/</id>
    <published>2020-12-23T12:13:46.000Z</published>
    <updated>2021-10-19T07:15:25.736Z</updated>
    
    <content type="html"><![CDATA[<p>  图的表示可以通过邻接矩阵，邻接链表和邻接数组。本文通过邻接链表实现无向无权图的表示，成员方法包括插入一条边，删除一条边，广度优先搜索，深度优先搜索，求连通分量个数，求两点之间的最短路径（BFS）。linkedGraph类中含有迭代器类myIterator，通过顶点创建迭代器，依次返回该顶点的所有邻接点。</p><span id="more"></span><h2 id="p1019图论基础"><a class="markdownIt-Anchor" href="#p1019图论基础"></a> P1019:图论基础</h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>创建无向图类，存储结构使用邻接链表，提供操作：插入一条边，删除一条边，BFS，DFS。</p><h3 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h3><h4 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h4><p>第一行四个整数n，m，s，t。n (10≤n≤100000) 代表图中点的个数，m (10≤m≤200000) 代表接下来共有m个操作，s代表起始点，t代表终点。<br />接下来m行，每行代表一次插入或删除边的操作，操作格式为：</p><ul><li>0 u v 在点u和v之间增加一条边</li><li>1 u v 删除点u和v之间的边</li></ul><h4 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h4><p>第一行输出图中有多少个连通分量。<br />第二行输出所有连通子图中最小点的编号（升序），编号间用空格分隔。<br />第三行输出从s点开始的dfs序列长度。<br />第四行输出从s点开始的字典序最小的dfs序列。<br />第五行输出从t点开始的bfs序列的长度。<br />第六行输出从t点开始字典序最小的bfs序列。<br />第七行输出从s点到t点的最短路径，若是不存在路径则输出-1。</p><h3 id="样例"><a class="markdownIt-Anchor" href="#样例"></a> 样例</h3><h4 id="输入-2"><a class="markdownIt-Anchor" href="#输入-2"></a> 输入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">10</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">8</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">8</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">8</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="输出-2"><a class="markdownIt-Anchor" href="#输出-2"></a> 输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">7</span> <span class="number">6</span> <span class="number">9</span> <span class="number">10</span> <span class="number">3</span> </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">1</span> <span class="number">9</span> <span class="number">6</span> <span class="number">10</span> <span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h3><p>1s, 10240KiB for each test case.</p><h3 id="算法描述"><a class="markdownIt-Anchor" href="#算法描述"></a> 算法描述</h3><p>  使用邻接链表存储结构，封装无向图类linkedGraph。protected成员包括图的顶点数n，边数e，邻接表aList，深度优先搜索递归方法rDfs，静态成员标记数组reach，标记label，路径数组path，路径长度length。public成员包括构造函数，析构函数，返回顶点个数，返回边数，插入一条边，删除一条边，广度优先搜索，深度优先搜索，返回无向图的构件个数，通过BFS求两点之间的最短路径，对aList链表数组的每个元素进行排序。定义迭代器myIterator，提供next方法依次返回当前顶点的邻接顶点，若不存在返回0。方法iterator返回myIterator类的指针。<br />  对chain类进行扩展，增加方法eraseElement(theVertex)删除顶点为theVertex的元素和冒泡排序方法bubbleSort。</p><ul><li>insertEdge：插入一条边i, j。首先通过aList[i].indexOf(j)判断图中是否已经存在这条边，若已经存在则不需要再次插入，若不存在，调用aList[i]和aList[j]的insert方法，将邻接顶点插入到链表头，图的边数e加一。</li><li>eraseEdge：删除一条边i, j。首先通过aList[i].eraseElement (j)判断图中是否存在这条边，若不存在则不需要进行删除，若存在，调用aList[i]和aList[j]的eraseElement方法删除邻接点，图的边数e减一。</li><li>labelComponents：返回无向图的构件个数。首先将标记构件号的数组c和标记label初始化，然后遍历每个顶点，如果顶点i未到达，对其实施BFS，进行标记。</li><li>findPath：寻找一条从顶点theSource到顶点theDestination的最短路径，返回一个数组path，从索引1开始表示路径，path[0]表示路径长度。如果路径不存在，返回NULL。首先对path，length，reach等进行初始化，定义bool型变量exists表示路径是否存在，用parent数组存储每个节点的前驱节点。利用BFS搜索路径，每次从队列中删除一个有标记的顶点，判断是否到达theDestination，若未到达，则标记所有邻接于顶点w的还未到达的顶点，使用parent数组存储前驱节点。如果到达theDestination，exists赋值为true，跳出while循环。如果找到了最短路径，根据parent逆向寻找路径中的各个顶点，通过栈结构将其放入path数组中，path[0]记录路径长度。如果不存在路径，输出-1然后返回。</li></ul><h3 id="c实现代码"><a class="markdownIt-Anchor" href="#c实现代码"></a> C++实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------graphChain类---------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chainNode</span>           <span class="comment">//节点类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//数据成员</span></span><br><span class="line">    T element;</span><br><span class="line">    chainNode&lt;T&gt;* next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="built_in">chainNode</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;element=element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element,chainNode&lt;T&gt;* next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;element=element;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next=next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">linkedGraph</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graphChain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">linkedGraph</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    chainNode&lt;T&gt;* firstNode;                    <span class="comment">//指向链表第一个节点的指针</span></span><br><span class="line">    <span class="type">int</span> listSize;                               <span class="comment">//线性表的元素个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">graphChain</span>();                               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">graphChain</span>(<span class="type">const</span> graphChain&lt;T&gt;&amp; theList);   <span class="comment">//复制构造函数</span></span><br><span class="line">    ~<span class="built_in">graphChain</span>();                              <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> listSize==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> listSize;&#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> theIndex)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span></span>;                   <span class="comment">//返回元素theElement首次出现时的索引，若不存在返回-1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement)</span></span>;      <span class="comment">//在索引为theIndex的位置插入元素theElement</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span></span>;                           <span class="comment">//删除链表中索引为theIndex的元素</span></span><br><span class="line">    <span class="function">T* <span class="title">eraseElement</span><span class="params">(T&amp; theVertex)</span></span>;                      <span class="comment">//删除顶点为theVertex的元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">()</span></span>;                                  <span class="comment">//冒泡排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        chainNode&lt;T&gt;* node;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//用C++的typedef语句实现前向迭代器</span></span><br><span class="line">        <span class="keyword">typedef</span> bidirectional_iterator_tag __iterator_category;</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">        <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iterator</span>(chainNode&lt;T&gt;* theNode=<span class="literal">NULL</span>) <span class="comment">//构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            node=theNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解引用操作符</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>* () <span class="type">const</span> &#123;<span class="keyword">return</span> node-&gt;element;&#125;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt; () <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;node-&gt;element;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器加法操作</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++ ()<span class="comment">//前++</span></span><br><span class="line">        &#123;</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator <span class="keyword">operator</span>++ (<span class="type">int</span>)<span class="comment">//后++</span></span><br><span class="line">        &#123;</span><br><span class="line">            iterator old=*<span class="keyword">this</span>;</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相等检验</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> iterator&amp; right) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node!=right.node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> iterator&amp; right) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node==right.node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(firstNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">graphChain&lt;T&gt;::<span class="built_in">graphChain</span>()   <span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    firstNode=<span class="literal">NULL</span>;</span><br><span class="line">    listSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">graphChain&lt;T&gt;::<span class="built_in">graphChain</span>(<span class="type">const</span> graphChain&lt;T&gt;&amp; theList) <span class="comment">//复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    listSize=theList.listSize;</span><br><span class="line">    <span class="comment">//链表为空</span></span><br><span class="line">    <span class="keyword">if</span>(listSize==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        firstNode=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表不为空</span></span><br><span class="line">    chainNode&lt;T&gt;* sourceNode=theList.firstNode;</span><br><span class="line">    firstNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourceNode-&gt;element);<span class="comment">//复制theList的首元素</span></span><br><span class="line">    sourceNode=sourceNode-&gt;next;</span><br><span class="line">    chainNode&lt;T&gt;* targetNode=firstNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sourceNode!=<span class="literal">NULL</span>) <span class="comment">//复制剩余元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        targetNode-&gt;next=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourceNode-&gt;element);</span><br><span class="line">        targetNode=targetNode-&gt;next;</span><br><span class="line">        sourceNode=sourceNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    targetNode-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//尾结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">graphChain&lt;T&gt;::~<span class="built_in">graphChain</span>() <span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(firstNode!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chainNode&lt;T&gt;* nextNode=firstNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> firstNode;</span><br><span class="line">        firstNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; graphChain&lt;T&gt;::<span class="built_in">get</span>(<span class="type">int</span> theIndex) <span class="type">const</span></span><br><span class="line">&#123;<span class="comment">//返回索引为theIndex的元素</span></span><br><span class="line">    <span class="comment">//移向需要的节点</span></span><br><span class="line">    chainNode&lt;T&gt;* currentNode=firstNode;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;theIndex;i++)</span><br><span class="line">        currentNode=currentNode-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> currentNode-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> graphChain&lt;T&gt;::<span class="built_in">indexOf</span>(<span class="type">const</span> T&amp; theElement)</span><br><span class="line">&#123;<span class="comment">//返回元素theElement首次出现时的索引，若不存在返回-1</span></span><br><span class="line">    <span class="comment">//搜索链表寻找theElement</span></span><br><span class="line">    chainNode&lt;T&gt;* currentNode=firstNode;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (currentNode!=<span class="literal">NULL</span> &amp;&amp; currentNode-&gt;element!=theElement)</span><br><span class="line">    &#123;</span><br><span class="line">        currentNode=currentNode-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(currentNode==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> graphChain&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement) <span class="comment">//插入操作</span></span><br><span class="line">&#123;<span class="comment">//在索引为theIndex的位置插入元素theElement</span></span><br><span class="line">    <span class="keyword">if</span>(theIndex==<span class="number">0</span>)<span class="comment">//在链表头插入</span></span><br><span class="line">        firstNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(theElement,firstNode);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">//寻找前驱</span></span><br><span class="line">        chainNode&lt;T&gt;* p=firstNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;theIndex<span class="number">-1</span>;i++)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        <span class="comment">//在p之后插入</span></span><br><span class="line">        p-&gt;next=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(theElement,p-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    listSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> graphChain&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">int</span> theIndex)</span><br><span class="line">&#123;<span class="comment">//删除链表中索引为theIndex的元素</span></span><br><span class="line">    chainNode&lt;T&gt;* deleteNode;</span><br><span class="line">    <span class="keyword">if</span>(theIndex==<span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//删除链表的首节点</span></span><br><span class="line">        deleteNode=firstNode;</span><br><span class="line">        firstNode=firstNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        chainNode&lt;T&gt;* p=firstNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;theIndex<span class="number">-1</span>;i++)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">        deleteNode=p-&gt;next;</span><br><span class="line">        p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    listSize--;</span><br><span class="line">    <span class="keyword">delete</span> deleteNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T* graphChain&lt;T&gt;::<span class="built_in">eraseElement</span>(T &amp;theVertex)</span><br><span class="line">&#123;<span class="comment">//删除顶点为theVertex的元素</span></span><br><span class="line">    chainNode&lt;T&gt;* deleteNode;   <span class="comment">//要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span>(firstNode-&gt;element==theVertex) <span class="comment">//删除的是链表的首节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode=firstNode;</span><br><span class="line">        firstNode=firstNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//删除的不是链表的首节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        chainNode&lt;T&gt;* previousNode=firstNode;</span><br><span class="line">        chainNode&lt;T&gt;* currentNode=firstNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode!=<span class="literal">NULL</span> &amp;&amp; currentNode-&gt;element!=theVertex)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode=currentNode-&gt;next;</span><br><span class="line">            previousNode=previousNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentNode==<span class="literal">NULL</span>)   <span class="comment">//链表中不存在要删除的元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//链表中存在要删除的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            deleteNode=currentNode;</span><br><span class="line">            previousNode-&gt;next=currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T* pElement=&amp;deleteNode-&gt;element;</span><br><span class="line">    listSize--;</span><br><span class="line">    <span class="keyword">delete</span> deleteNode;</span><br><span class="line">    <span class="keyword">return</span> pElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> graphChain&lt;T&gt;::<span class="built_in">bubbleSort</span>()</span><br><span class="line">&#123;<span class="comment">//冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span>(chainNode&lt;T&gt;* p=firstNode;p!=<span class="literal">NULL</span>;p=p-&gt;next)</span><br><span class="line">        <span class="keyword">for</span>(chainNode&lt;T&gt;* q=p-&gt;next;q!= <span class="literal">NULL</span>;q=q-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;element &gt; q-&gt;element)</span><br><span class="line">                <span class="built_in">swap</span>(p-&gt;element,q-&gt;element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------arrayQueue类---------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">arrayQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> queueFront;     <span class="comment">//队列首元素的下一个位置（逆时针方向）</span></span><br><span class="line">    <span class="type">int</span> queueBack;      <span class="comment">//队列最后一个元素的位置</span></span><br><span class="line">    <span class="type">int</span> arrayLength;    <span class="comment">//数组大小</span></span><br><span class="line">    T* queue;           <span class="comment">//存储队列的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">arrayQueue</span>(<span class="type">int</span> initialCapacity=<span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">arrayQueue</span>() &#123;<span class="keyword">delete</span> []queue;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> queueFront==queueBack;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> (arrayLength+queueBack-queueFront)%arrayLength;&#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>;                   <span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;                    <span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;                         <span class="comment">//删除队首元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span></span>;     <span class="comment">//元素插入到队尾</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">arrayQueue&lt;T&gt;::<span class="built_in">arrayQueue</span>(<span class="type">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    arrayLength=initialCapacity;</span><br><span class="line">    queue=<span class="keyword">new</span> T[arrayLength];</span><br><span class="line">    queueFront=queueBack=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; arrayQueue&lt;T&gt;::<span class="built_in">front</span>() <span class="type">const</span></span><br><span class="line">&#123;<span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="keyword">return</span> queue[(queueFront+<span class="number">1</span>)%arrayLength];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; arrayQueue&lt;T&gt;::<span class="built_in">back</span>() <span class="type">const</span></span><br><span class="line">&#123;<span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="keyword">return</span> queue[queueBack];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> arrayQueue&lt;T&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;<span class="comment">//删除队首元素</span></span><br><span class="line">    queueFront=(queueFront+<span class="number">1</span>)%arrayLength;</span><br><span class="line">    queue[queueFront].~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> arrayQueue&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp; theElement)</span><br><span class="line">&#123;<span class="comment">//元素插入到队尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果插入一个元素后队列满，需要扩充容量</span></span><br><span class="line">    <span class="keyword">if</span>((queueBack+<span class="number">1</span>)%arrayLength==queueFront)</span><br><span class="line">    &#123;</span><br><span class="line">        T* newQueue=<span class="keyword">new</span> T[<span class="number">2</span>*arrayLength];</span><br><span class="line">        <span class="type">int</span> start=(queueFront+<span class="number">1</span>)%arrayLength;</span><br><span class="line">        <span class="comment">//复制元素</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;<span class="number">2</span>) <span class="comment">//原队列中没有形成环</span></span><br><span class="line">            <span class="built_in">copy</span>(queue+start,queue+start+arrayLength<span class="number">-1</span>,newQueue);</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//原队列中形成环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">copy</span>(queue+start,queue+arrayLength,newQueue);</span><br><span class="line">            <span class="built_in">copy</span>(queue,queue+queueBack+<span class="number">1</span>,newQueue+arrayLength-start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queueFront=<span class="number">2</span>*arrayLength<span class="number">-1</span>;</span><br><span class="line">        queueBack=arrayLength<span class="number">-2</span>;</span><br><span class="line">        arrayLength*=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">delete</span> []queue;</span><br><span class="line">        queue=newQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    queueBack=(queueBack+<span class="number">1</span>)%arrayLength;</span><br><span class="line">    queue[queueBack]=theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------arrayStack类---------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">arrayStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> stackTop;       <span class="comment">//栈顶</span></span><br><span class="line">    <span class="type">int</span> arrayLength;    <span class="comment">//栈容量</span></span><br><span class="line">    T* stack;           <span class="comment">//元素数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数、析构函数</span></span><br><span class="line">    <span class="built_in">arrayStack</span>(<span class="type">int</span> initialCapacity=<span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">arrayStack</span>() &#123;<span class="keyword">delete</span> []stack;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ADT方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> stackTop==<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> stackTop+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">arrayStack&lt;T&gt;::<span class="built_in">arrayStack</span>(<span class="type">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    arrayLength=initialCapacity;</span><br><span class="line">    stack=<span class="keyword">new</span> T[arrayLength];</span><br><span class="line">    stackTop=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; arrayStack&lt;T&gt;::<span class="built_in">top</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stack[stackTop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> arrayStack&lt;T&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    stack[stackTop--].~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> arrayStack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackTop==arrayLength<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="comment">//空间已满，容量加倍</span></span><br><span class="line">        T* newStack=<span class="keyword">new</span> T[arrayLength*<span class="number">2</span>];</span><br><span class="line">        arrayLength*=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=stackTop;i++)</span><br><span class="line">            newStack[i]=stack[i];</span><br><span class="line">        <span class="keyword">delete</span> []stack;</span><br><span class="line">        stack=newStack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在栈顶插入</span></span><br><span class="line">    stack[++stackTop]=theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------linkedGraph类---------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">linkedGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> n;                      <span class="comment">//顶点数</span></span><br><span class="line">    <span class="type">int</span> e;                      <span class="comment">//边数</span></span><br><span class="line">    graphChain&lt;<span class="type">int</span>&gt; *aList;     <span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rDfs</span><span class="params">(<span class="type">int</span> v)</span></span>;           <span class="comment">//深度优先搜索递归方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rDfs_output</span><span class="params">(<span class="type">int</span> v)</span></span>;    <span class="comment">//深度优先搜索递归方法（输出DFS序列）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> *reach;          <span class="comment">//标记数组</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> label;           <span class="comment">//标记</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> *path;           <span class="comment">//路径</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> length;          <span class="comment">//路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">linkedGraph</span>(<span class="type">int</span> numberOfVertices=<span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//构造函数</span></span><br><span class="line">        n=numberOfVertices;</span><br><span class="line">        e=<span class="number">0</span>;</span><br><span class="line">        aList=<span class="keyword">new</span> graphChain&lt;<span class="type">int</span>&gt;[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">linkedGraph</span>() &#123;<span class="keyword">delete</span> []aList;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfVertices</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;        <span class="comment">//返回顶点数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfEdges</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> e;&#125;           <span class="comment">//返回边数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>;                   <span class="comment">//插入一条边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eraseEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>;                    <span class="comment">//删除一条边</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span>;          <span class="comment">//广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs_output</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span>;   <span class="comment">//广度优先搜索（输出BFS序列）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span>;          <span class="comment">//深度优先搜索</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_output</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span>;   <span class="comment">//深度优先搜索（输出DFS序列）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">labelComponents</span><span class="params">(<span class="type">int</span> c[])</span></span>;                   <span class="comment">//返回无向图的构件个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">findPath</span><span class="params">(<span class="type">int</span> theSource,<span class="type">int</span> theDestination)</span></span>;<span class="comment">//通过BFS求两点之间的最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortedAList</span><span class="params">()</span>                              <span class="comment">//对aList[i]进行排序</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            aList[i].<span class="built_in">bubbleSort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myIterator</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        graphChain&lt;<span class="type">int</span>&gt; chain;</span><br><span class="line">        chainNode&lt;<span class="type">int</span>&gt;* currentVertexNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">myIterator</span>(graphChain&lt;<span class="type">int</span>&gt;&amp; theGraphChain)</span><br><span class="line">        &#123;</span><br><span class="line">            chain=theGraphChain;</span><br><span class="line">            currentVertexNode=chain.firstNode;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">myIterator</span>() &#123;chain.firstNode=<span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="comment">//返回下一个顶点。若不存在则返回0</span></span><br><span class="line">         <span class="comment">//寻找下一个邻接的顶点</span></span><br><span class="line">            <span class="keyword">while</span>(currentVertexNode!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                chainNode&lt;<span class="type">int</span>&gt;* p=currentVertexNode;</span><br><span class="line">                currentVertexNode=currentVertexNode-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> p-&gt;element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在下一个邻接的顶点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">myIterator* <span class="title">iterator</span><span class="params">(<span class="type">int</span> theVertex)</span>             <span class="comment">//访问指定顶点的相邻顶点</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//返回顶点theVertex的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">myIterator</span>(aList[theVertex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* linkedGraph::reach=<span class="literal">NULL</span>;           <span class="comment">//标记数组</span></span><br><span class="line"><span class="type">int</span> linkedGraph::label=<span class="number">0</span>;               <span class="comment">//标记</span></span><br><span class="line"><span class="type">int</span>* linkedGraph::path=<span class="literal">NULL</span>;            <span class="comment">//路径</span></span><br><span class="line"><span class="type">int</span> linkedGraph::length=<span class="number">0</span>;              <span class="comment">//路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::insertEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//插入一条边i,j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是新边</span></span><br><span class="line">    <span class="keyword">if</span>(aList[i].<span class="built_in">indexOf</span>(j)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aList[i].<span class="built_in">insert</span>(<span class="number">0</span>,j);</span><br><span class="line">        aList[j].<span class="built_in">insert</span>(<span class="number">0</span>,i);</span><br><span class="line">        e++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::eraseEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除一条边i,j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断边i,j是否存在</span></span><br><span class="line">    <span class="type">int</span> *v=aList[i].<span class="built_in">eraseElement</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(v!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aList[j].<span class="built_in">eraseElement</span>(i);</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linkedGraph::labelComponents</span><span class="params">(<span class="type">int</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回无向图的构件个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//令所有顶点是非构件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        c[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    label=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//确定构件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]==<span class="number">0</span>) <span class="comment">//顶点i未到达</span></span><br><span class="line">        &#123;</span><br><span class="line">            label++;</span><br><span class="line">            <span class="built_in">bfs</span>(i,c,label); <span class="comment">//给新构件做标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::bfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">arrayQueue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    reach[v]=label;</span><br><span class="line">    q.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从队列中删除一个有标记的顶点</span></span><br><span class="line">        <span class="type">int</span> w=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标记所有邻接于顶点w的还没有到达的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(chainNode&lt;<span class="type">int</span>&gt;* u=aList[w].firstNode;u!=<span class="literal">NULL</span>;u=u-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//访问顶点w的一个关联的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(reach[u-&gt;element]==<span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//u-&gt;element是一个没有到达的顶点</span></span><br><span class="line">                q.<span class="built_in">push</span>(u-&gt;element);</span><br><span class="line">                reach[u-&gt;element]=label;    <span class="comment">//到达标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::bfs_output</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">arrayQueue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    reach[v]=label;</span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从队列中删除一个有标记的顶点</span></span><br><span class="line">        <span class="type">int</span> w=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标记所有邻接于顶点w的还没有到达的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(chainNode&lt;<span class="type">int</span>&gt;* u=aList[w].firstNode;u!=<span class="literal">NULL</span>;u=u-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//访问顶点w的一个关联的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(reach[u-&gt;element]==<span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//u-&gt;element是一个没有到达的顶点</span></span><br><span class="line">                q.<span class="built_in">push</span>(u-&gt;element);</span><br><span class="line">                reach[u-&gt;element]=label;    <span class="comment">//到达标记</span></span><br><span class="line">                cout&lt;&lt;u-&gt;element&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linkedGraph::reach=reach;</span><br><span class="line">    linkedGraph::label=label;</span><br><span class="line">    <span class="built_in">rDfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::rDfs</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//深度优先搜索递归方法</span></span><br><span class="line">    reach[v]=label;</span><br><span class="line">    myIterator* iv=<span class="built_in">iterator</span>(v);</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="keyword">while</span>((u=iv-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)    <span class="comment">//访问与v相邻的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(reach[u]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">rDfs</span>(u);    <span class="comment">//u是一个没有到达的顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::dfs_output</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linkedGraph::reach=reach;</span><br><span class="line">    linkedGraph::label=label;</span><br><span class="line">    <span class="built_in">rDfs_output</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkedGraph::rDfs_output</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//深度优先搜索递归方法</span></span><br><span class="line">    reach[v]=label;</span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    myIterator* iv=<span class="built_in">iterator</span>(v);</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="keyword">while</span>((u=iv-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)    <span class="comment">//访问与v相邻的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(reach[u]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">rDfs_output</span>(u);    <span class="comment">//u是一个没有到达的顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">linkedGraph::findPath</span><span class="params">(<span class="type">int</span> theSource, <span class="type">int</span> theDestination)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//寻找一条从顶点theSource到顶点theDestination的最短路径</span></span><br><span class="line"> <span class="comment">//返回一个数组path，从索引1开始表示路径，path[0]表示路径长度</span></span><br><span class="line"> <span class="comment">//如果路径不存在，返回NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为寻找路径的算法初始化</span></span><br><span class="line">    <span class="type">bool</span> exists=<span class="literal">false</span>;</span><br><span class="line">    path=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    path[<span class="number">1</span>]=theSource;</span><br><span class="line">    length=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *parent=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];   <span class="comment">//节点的父节点</span></span><br><span class="line">    reach=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        reach[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索路径</span></span><br><span class="line">    <span class="function">arrayQueue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    reach[theSource]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(theSource);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从队列中删除一个有标记的顶点</span></span><br><span class="line">        <span class="type">int</span> w=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(w==theDestination)   <span class="comment">//到达theDestination</span></span><br><span class="line">        &#123;</span><br><span class="line">            exists=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标记所有邻接于顶点w的还没有到达的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(chainNode&lt;<span class="type">int</span>&gt;* u=aList[w].firstNode;u!=<span class="literal">NULL</span>;u=u-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//访问顶点w的一个关联的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(reach[u-&gt;element]==<span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//u-&gt;element是一个没有到达的顶点</span></span><br><span class="line">                q.<span class="built_in">push</span>(u-&gt;element);</span><br><span class="line">                reach[u-&gt;element]=label;    <span class="comment">//到达标记</span></span><br><span class="line">                parent[u-&gt;element]=w;       <span class="comment">//存储父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(theSource==theDestination || exists) <span class="comment">//找到一条最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据parent逆向寻找路径</span></span><br><span class="line">        <span class="type">int</span> i=theDestination;</span><br><span class="line">        arrayStack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push</span>(theDestination);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        <span class="keyword">while</span> (parent[i]!=theSource)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(parent[i]);</span><br><span class="line">            i=parent[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length=stack.<span class="built_in">size</span>();</span><br><span class="line">        path[<span class="number">0</span>]=length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=length+<span class="number">1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            path[k]=stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;path[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//不存在路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []path;</span><br><span class="line">        path=<span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []reach;</span><br><span class="line">    <span class="keyword">delete</span> []parent;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(T* array,<span class="type">int</span> size)</span> <span class="comment">//及时终止的冒泡排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted=<span class="literal">false</span>;<span class="comment">//判断是否有序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>&amp;&amp;!sorted;i++)<span class="comment">//size个数最多进行(size-1)次冒泡</span></span><br><span class="line">    &#123;</span><br><span class="line">        sorted=<span class="literal">true</span>;<span class="comment">//每次初始化为有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j+<span class="number">1</span>]&lt;array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(array[j],array[j+<span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">false</span>;<span class="comment">//发生了交换,仍处于无序状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,s,t;        <span class="comment">//n个顶点，m个操作，s代表起始点，t代表终点</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> instruction,u,v;</span><br><span class="line">    <span class="function">linkedGraph <span class="title">LG</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;instruction&gt;&gt;u&gt;&gt;v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instruction==<span class="number">0</span>)</span><br><span class="line">            LG.<span class="built_in">insertEdge</span>(u,v);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LG.<span class="built_in">eraseEdge</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *c=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];            <span class="comment">//c[i]是顶点i的构件号</span></span><br><span class="line">    <span class="type">int</span> *reachDFS=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];     <span class="comment">//DFS搜索时的标记数组</span></span><br><span class="line">    <span class="type">int</span> *reachBFS=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];     <span class="comment">//BFS搜索时的标记数组</span></span><br><span class="line">    <span class="type">int</span> cntDFS=<span class="number">0</span>,cntBFS=<span class="number">0</span>;          <span class="comment">//DFS和BFS序列长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//初始化</span></span><br><span class="line">        reachDFS[i]=reachBFS[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一行输出图中有多少个连通分量</span></span><br><span class="line">    <span class="type">int</span> components=LG.<span class="built_in">labelComponents</span>(c);</span><br><span class="line">    cout&lt;&lt;components&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二行输出所有连通子图中最小点的编号（升序），编号间用空格分隔</span></span><br><span class="line">    <span class="type">int</span> *min=<span class="keyword">new</span> <span class="type">int</span>[components];   <span class="comment">//每个连通子图中的最小点的编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;components;i++)   <span class="comment">//初始化</span></span><br><span class="line">        min[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(min[c[i]<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">            min[c[i]<span class="number">-1</span>]=i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;min[c[i]<span class="number">-1</span>])</span><br><span class="line">                min[c[i]<span class="number">-1</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对min[i]排序后输出</span></span><br><span class="line">    <span class="built_in">bubble_sort</span>(min,components);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;components;i++)</span><br><span class="line">        cout&lt;&lt;min[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三行输出从s点开始的dfs序列长度</span></span><br><span class="line">    LG.<span class="built_in">dfs</span>(s,reachDFS,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(reachDFS[i]==<span class="number">1</span>)</span><br><span class="line">            cntDFS++;</span><br><span class="line">    cout&lt;&lt;cntDFS&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四行输出从s点开始的字典序最小的dfs序列</span></span><br><span class="line">    LG.<span class="built_in">sortedAList</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        reachDFS[i]=<span class="number">0</span>;</span><br><span class="line">    LG.<span class="built_in">dfs_output</span>(s,reachDFS,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五行输出从t点开始的bfs序列的长度</span></span><br><span class="line">    LG.<span class="built_in">bfs</span>(t,reachBFS,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(reachBFS[i]==<span class="number">1</span>)</span><br><span class="line">            cntBFS++;</span><br><span class="line">    cout&lt;&lt;cntBFS&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第六行输出从t点开始字典序最小的bfs序列</span></span><br><span class="line">    LG.<span class="built_in">sortedAList</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        reachBFS[i]=<span class="number">0</span>;</span><br><span class="line">    LG.<span class="built_in">bfs_output</span>(t,reachBFS,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第七行输出从s点到t点的最短路径，若是不存在路径则输出-1</span></span><br><span class="line">    <span class="type">int</span> *path=LG.<span class="built_in">findPath</span>(s,t);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> []c;</span><br><span class="line">    <span class="keyword">delete</span> []reachDFS;</span><br><span class="line">    <span class="keyword">delete</span> []reachBFS;</span><br><span class="line">    <span class="keyword">delete</span> []path;</span><br><span class="line">    <span class="keyword">delete</span> []min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h3><p>1.求字典序最小的BFS和DFS序列，一种办法是在求之前对邻接表的每个链表排序，另一种办法是在插入边的时候，按照有序链表进行插入。<br />2.求所有连通子图最小点的编号，需要先求出连通子图个数，然后根据连通子图个数声明一个数组，用来保存每个连通子图的最小点编号。遍历所有顶点，根据该顶点的label值和数组中已经存储的编号，最终得到所有连通子图最小点的编号。进行排序后，即可按照升序输出。<br />3.求无权图中两个点之间的最短路径，使用BFS搜索即可，在搜索过程中保存当前节点的前驱节点，搜索结束后逆向寻找这条路径中的各个顶点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;  图的表示可以通过邻接矩阵，邻接链表和邻接数组。本文通过邻接链表实现无向无权图的表示，成员方法包括插入一条边，删除一条边，广度优先搜索，深度优先搜索，求连通分量个数，求两点之间的最短路径（BFS）。linkedGraph类中含有迭代器类myIterator，通过顶点创建迭代器，依次返回该顶点的所有邻接点。&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://tongyiheng.top/categories/Computer-Science/"/>
    
    <category term="Data Structures" scheme="https://tongyiheng.top/categories/Computer-Science/Data-Structures/"/>
    
    
    <category term="cpp" scheme="https://tongyiheng.top/tags/cpp/"/>
    
    <category term="graph" scheme="https://tongyiheng.top/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>DSA：（十一）搜索树</title>
    <link href="https://tongyiheng.top/2020/12/23/CS/DSA/DSA_11/"/>
    <id>https://tongyiheng.top/2020/12/23/CS/DSA/DSA_11/</id>
    <published>2020-12-23T11:47:14.000Z</published>
    <updated>2021-10-19T07:15:22.940Z</updated>
    
    <content type="html"><![CDATA[<p>  二叉搜索树查找、删除、插入操作的平均性能为O(logn)，最坏情况下的性能为O(n)。索引二叉搜索树为每个节点增加了leftSize域，记录该节点左子树的元素个数，可以按名次进行查找和删除操作，在插入和删除后需要对一些节点的leftSize值进行更新。</p><span id="more"></span><h2 id="p1018二叉搜索树"><a class="markdownIt-Anchor" href="#p1018二叉搜索树"></a> P1018:二叉搜索树</h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>创建带索引的二叉搜索树类。存储结构使用链表，提供操作:插入、删除、按名次删除、查找、按名次查找、升序输出所有元素。</p><h3 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h3><h4 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h4><p>输入第一行一个数字m (m&lt;=1000000)，表示有m个操作。<br />接下来m行，每一行有两个数字a，b：</p><ul><li>当输入的第一个数字a为0时，输入的第二个数字b表示向搜索树中插入b。</li><li>当输入的第一个数字a为1时，输入的第二个数字b表示向搜索树中查找b。</li><li>当输入的第一个数字a为2时，输入的第二个数字b表示向搜索树中删除b。</li><li>当输入的第一个数字a为3时，输入的第二个数字b表示查找搜索树中名次为b的元素。</li><li>当输入的第一个数字a为4时，输入的第二个数字b表示删除搜索树中名次为b的元素。</li></ul><h4 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h4><p>对于输入中的每一种操作，输出执行操作的过程中依次比较的元素值的异或值。</p><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><p>查询与删除操作中，待查询的元素也需要异或入答案中。<br />查找（删除）操作中，如果未找到，或者插入操作，已存在，输出0（不插入），不需要输出异或和。<br />查找（删除）第b大，如果不存在，输出0。<br />删除操作中，如果当前元素有两个孩子，替换的为右子树中最小的，如果只有一个孩子，直接用该孩子替换当前元素，如果没有孩子，直接删除。<br />删除操作的替换过程中所有比较操作不计入答案。</p><h3 id="样例"><a class="markdownIt-Anchor" href="#样例"></a> 样例</h3><h4 id="样例1"><a class="markdownIt-Anchor" href="#样例1"></a> 样例1</h4><h5 id="输入-2"><a class="markdownIt-Anchor" href="#输入-2"></a> 输入</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="输出-2"><a class="markdownIt-Anchor" href="#输出-2"></a> 输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="样例2"><a class="markdownIt-Anchor" href="#样例2"></a> 样例2</h4><h5 id="输入-3"><a class="markdownIt-Anchor" href="#输入-3"></a> 输入</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">0</span> <span class="number">43</span></span><br><span class="line"><span class="number">0</span> <span class="number">17</span></span><br><span class="line"><span class="number">0</span> <span class="number">55</span></span><br><span class="line"><span class="number">0</span> <span class="number">62</span></span><br><span class="line"><span class="number">0</span> <span class="number">57</span></span><br><span class="line"><span class="number">0</span> <span class="number">66</span></span><br><span class="line"><span class="number">0</span> <span class="number">67</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">67</span></span><br><span class="line"><span class="number">0</span> <span class="number">70</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">43</span></span><br></pre></td></tr></table></figure><h5 id="输出-3"><a class="markdownIt-Anchor" href="#输出-3"></a> 输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">96</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="number">58</span></span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure><h3 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h3><p>1s, 10240KiB for each test case.</p><h3 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h3><p>查找和删除第k大的元素时，可以先把第k的元素找到，再按照该元素查找和删除。</p><h3 id="算法描述"><a class="markdownIt-Anchor" href="#算法描述"></a> 算法描述</h3><p>  封装索引二叉搜索树类indexedBinarySearchTree，二叉树的存储结构使用链表，每个节点包括关键字key，左子树的元素个数leftSize，左孩子leftChild，右孩子rightChild。节点类的构造函数有四个，默认构造函数，通过theKey构造，通过theKey，theLeftChild，theRightChild构造（构造函数中计算leftSize值），通过theKey，theLeftSize，theLeftChild，theRightChild构造。索引二叉搜索树类中，非静态的私有成员包括根节点root，树的节点个数treeSize，静态的私有成员包括访问函数visit，前序遍历preOrder，中序遍历inOrder，后序遍历postOrder，删除t指向的节点dispose方法，输出该节点的关键字的output方法。公有成员包括构造函数，析构函数，empty方法，size方法，前序遍历，中序遍历，后序遍历，层次遍历，删除二叉树的erase方法，查找关键字的find方法，插入关键字的insert方法，删除关键字的erase方法，获取名次为b的节点的关键字的get方法，插入操作后更新leftSize域的updateLeftSizeAfterInsert方法，删除操作后更新leftSize域的updateLeftSizeAfterErase_1，updateLeftSizeAfterErase_2方法，两种方法针对删除操作中的两种情况进行相应更新。</p><ul><li>find：查找关键字为theKey的节点，如果找到输出查找过程中依次比较的元素值的异或和，如果未找到输出0，不需要输出异或和。指针p从根节点开始搜索，寻找关键字等于theKey的节点，直到p为空为止。循环体首先进行异或操作，然后根据theKey和p-&gt;key的大小关系判断是否找到以及进左子树还是右子树。</li><li>insert：插入关键字为theKey的节点，如果不存在关键字为theKey的节点，输出插入过程中依次比较的元素值的异或和，如果已存在关键字为theKey的节点，输出0，不需要输出异或和。指针p从根节点开始搜索，寻找插入的位置，用指针pp保存p的父节点，根据theKey和p-&gt;key的大小关系判断是否已经存在关键字为theKey的节点以及进左子树还是右子树。根据theKey建立一个新节点，根据root是否为空判断是否是插入到一颗空树中，然后通过pp将其连在搜索树上。插入后，treeSize加一，调用updateLeftSizeAfterInsert方法对从根节点到插入点的路径上的节点的leftSize值进行更新。指针x从根节点开始，如果theKey小于x-&gt;key，当前节点的leftSize需要加一，如果theKey大于x-&gt;key，当前节点的leftSize不需要更新。最后输出异或值。</li><li>erase：删除关键字为theKey的节点，输出删除过程中依次比较的元素值的异或和，替换过程中的所有比较操作不计入答案。如果当前节点有两个孩子，用右子树中关键字最小的节点进行替换。如果只有一个孩子，直接用该节点的孩子进行替换。如果没有孩子，直接删除。如果不存在，输出0。指针p从根节点开始搜索，pp为p的父节点。搜索完毕后根据p是否为空判断是否存在关键字为theKey的节点。若不存在，输出0然后返回。若存在，根据p的孩子个数分两种情况进行考虑。<br />（1）p有两个孩子：转化为第（2）中情况。在p的右子树中沿着leftChild寻找最小元素s替代被删除的节点。替代过程是根据s-&gt;key，p-&gt;leftSize，p-&gt;leftChild，p-&gt;rightChild新建一个节点，将其连在pp上，更新指针pp，删除p节点，然后让p指向s（这是为了保证（2）中对节点s的删除）。<br />（2）p至多有一个孩子：将孩子指针存在c中，将pp和c连起来，删除p，treeSize减一。最后输出异或值。<br />对leftSize的更新在（1）过程之后（如果有的话），（2）过程之前进行。使用flag标记（1）过程是否进行，如果（1）过程执行，即要删除的节点有两个孩子，调用updateLeftSizeAfterErase_2，否则调用updateLeftSizeAfterErase_1。</li><li>updateLeftSizeAfterErase_2：要删除的节点有两个孩子，对从root到p的路径上的节点的leftSize进行更新。参数为节点类的指针s。指针x从根节点开始，当x不等于s时，执行while循环，通过x-&gt;key和s-&gt;key的大小关系进行相应节点的leftSize的更新。注意等于的特殊情况，第一次遇到相等的情况，表示x为替换后的节点，因为是用右子树的最小元素进行替换，所以直接进入右子树即可，第二次遇到表示路径寻找完毕。</li><li>updateLeftSizeAfterErase_1：要删除的节点至多有一个孩子，对从root到p的路径上的节点的leftSize进行更新。参数为关键字值theKey。指针x从根节点开始，当x不为空时，执行while循环，通过theKey和x-&gt;key的大小关系进行相应节点的leftSize的更新，若相等则路径寻找完毕。</li><li>get：返回第index个元素的关键字的值（index从0开始）。指针x从根节点开始搜索，如果index等于x-&gt;leftSize，则找到该元素，如果index小于x-&gt;leftSize，则第index个元素是左子树的第index个元素，如果index大于x-&gt;leftSize，则第index个元素是右子树的第(index-(x-&gt;leftSize+1))个元素。</li></ul><h3 id="c实现代码"><a class="markdownIt-Anchor" href="#c实现代码"></a> C++实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">indexedBinarySearchTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T key;                      <span class="comment">//关键字</span></span><br><span class="line">    <span class="type">int</span> leftSize;               <span class="comment">//左子树的元素个数</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *leftChild,*rightChild;  <span class="comment">//左孩子和右孩子</span></span><br><span class="line">    <span class="built_in">indexedBinarySearchTreeNode</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        leftChild=rightChild=<span class="literal">NULL</span>;</span><br><span class="line">        leftSize=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">indexedBinarySearchTreeNode</span>(<span class="type">const</span> T&amp; theKey)</span><br><span class="line">    &#123;</span><br><span class="line">        key=theKey;</span><br><span class="line">        leftChild=rightChild=<span class="literal">NULL</span>;</span><br><span class="line">        leftSize=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">indexedBinarySearchTreeNode</span>(<span class="type">const</span> T&amp; theKey,indexedBinarySearchTreeNode&lt;T&gt; *theLeftChild,indexedBinarySearchTreeNode&lt;T&gt; *theRightChild)</span><br><span class="line">    &#123;</span><br><span class="line">        key=theKey;</span><br><span class="line">        leftChild=theLeftChild;</span><br><span class="line">        rightChild=theRightChild;</span><br><span class="line">        leftSize=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算leftSize的值</span></span><br><span class="line">        indexedBinarySearchTreeNode&lt;T&gt; *p=theLeftChild;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)      <span class="comment">//从根沿着右子树的路径计算节点个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            leftSize+=p-&gt;leftSize+<span class="number">1</span>;</span><br><span class="line">            p=p-&gt;rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">indexedBinarySearchTreeNode</span>(<span class="type">const</span> T&amp; theKey,<span class="type">int</span> theLeftSize,indexedBinarySearchTreeNode&lt;T&gt; *theLeftChild,indexedBinarySearchTreeNode&lt;T&gt; *theRightChild)</span><br><span class="line">    &#123;</span><br><span class="line">        key=theKey;</span><br><span class="line">        leftSize=theLeftSize;</span><br><span class="line">        leftChild=theLeftChild;</span><br><span class="line">        rightChild=theRightChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indexedBinarySearchTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *root;                                       <span class="comment">//根节点</span></span><br><span class="line">    <span class="type">int</span> treeSize;                                                               <span class="comment">//树的节点数量</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*visit)</span><span class="params">(indexedBinarySearchTreeNode&lt;T&gt; *)</span></span>;                     <span class="comment">//访问函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">preOrder</span><span class="params">(indexedBinarySearchTreeNode&lt;T&gt; *t)</span></span>;                    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">inOrder</span><span class="params">(indexedBinarySearchTreeNode&lt;T&gt; *t)</span></span>;                     <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">postOrder</span><span class="params">(indexedBinarySearchTreeNode&lt;T&gt; *t)</span></span>;                   <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">dispose</span><span class="params">(indexedBinarySearchTreeNode&lt;T&gt; *t)</span> </span>&#123;<span class="keyword">delete</span> t;&#125;          <span class="comment">//删除t指向的节点</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">output</span><span class="params">(indexedBinarySearchTreeNode&lt;T&gt; *t)</span> </span>&#123;cout&lt;&lt;t-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;  <span class="comment">//输出节点的关键字</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">indexedBinarySearchTree</span>() &#123;root=<span class="literal">NULL</span>; treeSize=<span class="number">0</span>;&#125;</span><br><span class="line">    ~<span class="built_in">indexedBinarySearchTree</span>() &#123;<span class="built_in">erase</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> treeSize==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> treeSize;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(<span class="type">void</span>(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visit=theVisit;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">void</span>(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visit=theVisit;</span><br><span class="line">        <span class="built_in">inOrder</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(<span class="type">void</span>(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visit=theVisit;</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrderOutput</span><span class="params">()</span> </span>&#123;<span class="built_in">inOrder</span>(output); cout&lt;&lt;endl;&#125;     <span class="comment">//输出中序序列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">()</span>            <span class="comment">//删除二叉树</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(dispose);</span><br><span class="line">        root=<span class="literal">NULL</span>;</span><br><span class="line">        treeSize=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">find</span><span class="params">(<span class="type">const</span> T&amp; theKey)</span> <span class="type">const</span></span>;                     <span class="comment">//查找关键字为theKey的节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; theKey)</span></span>;                       <span class="comment">//插入关键字为theKey的节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> T&amp; theKey)</span></span>;                        <span class="comment">//删除关键字为theKey的节点</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span></span>;                                   <span class="comment">//获得名次为b的节点的关键字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateLeftSizeAfterInsert</span><span class="params">(<span class="type">const</span> T&amp; theKey)</span></span>;    <span class="comment">//插入操作后对leftSize域的更新</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateLeftSizeAfterErase_1</span><span class="params">(<span class="type">const</span> T&amp; theKey)</span></span>;   <span class="comment">//要删除的节点p最多有一个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateLeftSizeAfterErase_2</span><span class="params">(indexedBinarySearchTreeNode&lt;T&gt; *s)</span></span>;  <span class="comment">//要删除的节点p有两个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="built_in">void</span> (*indexedBinarySearchTree&lt;T&gt;::visit)(indexedBinarySearchTreeNode&lt;T&gt;*)=<span class="literal">NULL</span>;    <span class="comment">//类的静态成员的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">preOrder</span>(indexedBinarySearchTreeNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        indexedBinarySearchTree&lt;T&gt;::<span class="built_in">visit</span>(t);</span><br><span class="line">        <span class="built_in">preOrder</span>(t-&gt;leftChild);</span><br><span class="line">        <span class="built_in">preOrder</span>(t-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">inOrder</span>(indexedBinarySearchTreeNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(t-&gt;leftChild);</span><br><span class="line">        indexedBinarySearchTree&lt;T&gt;::<span class="built_in">visit</span>(t);</span><br><span class="line">        <span class="built_in">inOrder</span>(t-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">postOrder</span>(indexedBinarySearchTreeNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(t-&gt;leftChild);</span><br><span class="line">        <span class="built_in">postOrder</span>(t-&gt;rightChild);</span><br><span class="line">        indexedBinarySearchTree&lt;T&gt;::<span class="built_in">visit</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T* indexedBinarySearchTree&lt;T&gt;::<span class="built_in">find</span>(<span class="type">const</span> T &amp;theKey) <span class="type">const</span></span><br><span class="line">&#123;<span class="comment">//查找关键字为theKey的节点</span></span><br><span class="line"> <span class="comment">//如果找到输出查找过程中依次比较的元素值的异或和</span></span><br><span class="line"> <span class="comment">//如果未找到输出0，不需要输出异或和</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value=<span class="number">0</span>;    <span class="comment">//异或和</span></span><br><span class="line">    <span class="comment">//指针p从根开始搜索，寻找关键字等于theKey的节点</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        value^=p-&gt;key;          <span class="comment">//异或</span></span><br><span class="line">        <span class="keyword">if</span>(theKey&lt;p-&gt;key)</span><br><span class="line">            p=p-&gt;leftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(theKey&gt;p-&gt;key)</span><br><span class="line">            p=p-&gt;rightChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> &amp;p-&gt;key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未找到关键字为theKey的节点</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> T &amp;theKey)</span><br><span class="line">&#123;<span class="comment">//插入关键字为theKey的节点</span></span><br><span class="line"> <span class="comment">//如果不存在关键字为theKey的节点，输出插入过程中依次比较的元素值的异或和</span></span><br><span class="line"> <span class="comment">//如果已存在关键字为theKey的节点，输出0，不需要输出异或和</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value=<span class="number">0</span>;    <span class="comment">//异或和</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *p=root,*pp=<span class="literal">NULL</span>;    <span class="comment">//p从根节点开始，pp为p的父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找插入点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        value^=p-&gt;key;  <span class="comment">//异或</span></span><br><span class="line">        pp=p;</span><br><span class="line">        <span class="comment">//将p移向孩子节点</span></span><br><span class="line">        <span class="keyword">if</span>(theKey&lt;p-&gt;key)</span><br><span class="line">            p=p-&gt;leftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(theKey&gt;p-&gt;key)</span><br><span class="line">            p=p-&gt;rightChild;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//已存在关键字为theKey的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为theKey建立一个新节点，并将该节点连接到pp</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *newNode=<span class="keyword">new</span> <span class="built_in">indexedBinarySearchTreeNode</span>&lt;T&gt;(theKey);</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)  <span class="comment">//树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theKey&lt;pp-&gt;key)</span><br><span class="line">            pp-&gt;leftChild=newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp-&gt;rightChild=newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//插入到空树中</span></span><br><span class="line">        root=newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新treeSize和路径上节点的leftSize</span></span><br><span class="line">    treeSize++;</span><br><span class="line">    <span class="built_in">updateLeftSizeAfterInsert</span>(theKey);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> T&amp; theKey)</span><br><span class="line">&#123;<span class="comment">//删除关键字为theKey的节点，输出删除过程中依次比较的元素值的异或和，替换过程中的所有比较操作不计入答案</span></span><br><span class="line"> <span class="comment">//如果当前节点有两个孩子，用右子树中关键字最小的节点进行替换</span></span><br><span class="line"> <span class="comment">//如果只有一个孩子，直接用该节点的孩子进行替换</span></span><br><span class="line"> <span class="comment">//如果没有孩子，直接删除</span></span><br><span class="line"> <span class="comment">//如果不存在，输出0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value=<span class="number">0</span>,flag=<span class="number">0</span>;     <span class="comment">//异或值和标记</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *p=root,*pp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;key!=theKey)</span><br><span class="line">    &#123;<span class="comment">//p移动到它的孩子节点</span></span><br><span class="line">        value^=p-&gt;key;</span><br><span class="line">        pp=p;</span><br><span class="line">        <span class="keyword">if</span>(theKey&lt;p-&gt;key)</span><br><span class="line">            p=p-&gt;leftChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="comment">//不存在关键字theKey的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新组织树结构</span></span><br><span class="line">    <span class="comment">//当p有两个孩子时的处理</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span> &amp;&amp; p-&gt;rightChild!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//两个孩子</span></span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//转化为空或只有一个孩子</span></span><br><span class="line">        <span class="comment">//在p的右子树中寻找最小元素</span></span><br><span class="line">        indexedBinarySearchTreeNode&lt;T&gt; *s=p-&gt;rightChild,*ps=p;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;leftChild!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;<span class="comment">//移动到最小元素</span></span><br><span class="line">            ps=s;</span><br><span class="line">            s=s-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将最小元素s移动到p</span></span><br><span class="line">        indexedBinarySearchTreeNode&lt;T&gt; *q=<span class="keyword">new</span> <span class="built_in">indexedBinarySearchTreeNode</span>&lt;T&gt;(s-&gt;key,p-&gt;leftSize,p-&gt;leftChild,p-&gt;rightChild);</span><br><span class="line">        <span class="keyword">if</span>(pp==<span class="literal">NULL</span>)    <span class="comment">//p为根节点</span></span><br><span class="line">            root=q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(p==pp-&gt;leftChild)</span><br><span class="line">                pp-&gt;leftChild=q;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp-&gt;rightChild=q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新p和p的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(ps==p)</span><br><span class="line">            pp=q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp=ps;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p=s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在进行删除前更新leftSize</span></span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="comment">//删除的节点有两个孩子</span></span><br><span class="line">        <span class="built_in">updateLeftSizeAfterErase_2</span>(p);</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//删除的节点最多有一个孩子</span></span><br><span class="line">        <span class="built_in">updateLeftSizeAfterErase_1</span>(theKey);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//p最多有一个孩子</span></span><br><span class="line">    <span class="comment">//把孩子指针存放在c</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *c;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span>)</span><br><span class="line">        c=p-&gt;leftChild;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c=p-&gt;rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除p</span></span><br><span class="line">    <span class="keyword">if</span>(p==root)</span><br><span class="line">        root=c;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//p是pp的左孩子还是右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p==pp-&gt;leftChild)</span><br><span class="line">            pp-&gt;leftChild=c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp-&gt;rightChild=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    treeSize--;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    value^=theKey;</span><br><span class="line">    cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T indexedBinarySearchTree&lt;T&gt;::<span class="built_in">get</span>(<span class="type">int</span> index)</span><br><span class="line">&#123;<span class="comment">//返回第index个元素的关键字的值</span></span><br><span class="line"> <span class="comment">//index从0开始</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *x=root;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index==x-&gt;leftSize)      <span class="comment">//第index个元素是x-&gt;key</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index&lt;x-&gt;leftSize)  <span class="comment">//第index个元素是左子树的第index个元素</span></span><br><span class="line">            x=x-&gt;leftChild;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//第index个元素是右子树的第(index-(x-&gt;leftSize+1))个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            index=index-(x-&gt;leftSize+<span class="number">1</span>);</span><br><span class="line">            x=x-&gt;rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">updateLeftSizeAfterInsert</span>(<span class="type">const</span> T &amp;theKey)</span><br><span class="line">&#123;<span class="comment">//插入操作后对leftSize域的更新</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *x=root;</span><br><span class="line">    <span class="comment">//寻找从根开始到关键字为theKey的节点的路径</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theKey&lt;x-&gt;key)   <span class="comment">//插入节点在x的左子树中，leftSize++</span></span><br><span class="line">        &#123;</span><br><span class="line">            x-&gt;leftSize++;</span><br><span class="line">            x=x-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(theKey&gt;x-&gt;key)  <span class="comment">//插入节点在x的右子树中</span></span><br><span class="line">            x=x-&gt;rightChild;</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//路径寻找完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">updateLeftSizeAfterErase_1</span>(<span class="type">const</span> T &amp;theKey)</span><br><span class="line">&#123;<span class="comment">//要删除的节点p最多有一个孩子，删除操作后对root到p的路径上节点的leftSize域</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *x=root;</span><br><span class="line">    <span class="comment">//寻找从根开始到关键字为theKey的节点的路径</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theKey&lt;x-&gt;key)       <span class="comment">//删除节点在x的左子树中，leftSize--</span></span><br><span class="line">        &#123;</span><br><span class="line">            x-&gt;leftSize--;</span><br><span class="line">            x=x-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(theKey&gt;x-&gt;key)  <span class="comment">//删除节点在x的右子树中</span></span><br><span class="line">            x=x-&gt;rightChild;</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//路径寻找完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> indexedBinarySearchTree&lt;T&gt;::<span class="built_in">updateLeftSizeAfterErase_2</span>(indexedBinarySearchTreeNode&lt;T&gt; *s)</span><br><span class="line">&#123;<span class="comment">//要删除的节点p有两个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新</span></span><br><span class="line">    indexedBinarySearchTreeNode&lt;T&gt; *x=root;</span><br><span class="line">    <span class="type">bool</span> meet=<span class="literal">false</span>;    <span class="comment">//标记是否是第一次遇到关键字为s-&gt;key的节点</span></span><br><span class="line">    <span class="comment">//寻找从根开始到s的路径</span></span><br><span class="line">    <span class="keyword">while</span>(x!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;key&lt;x-&gt;key)   <span class="comment">//删除节点在x的左子树中，leftSize--</span></span><br><span class="line">        &#123;</span><br><span class="line">            x-&gt;leftSize--;</span><br><span class="line">            x=x-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s-&gt;key&gt;x-&gt;key)  <span class="comment">//删除节点在x的右子树中</span></span><br><span class="line">            x=x-&gt;rightChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!meet)               <span class="comment">//第一次遇到相同关键字的节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                meet=<span class="literal">true</span>;          <span class="comment">//这个节点的关键字已经被右子树的最小元素替换</span></span><br><span class="line">                x=x-&gt;rightChild;    <span class="comment">//要删除的节点位于右子树，所以将指针指向右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>        <span class="comment">//第二次遇到，路径寻找完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    indexedBinarySearchTree&lt;<span class="type">int</span>&gt; IBST;</span><br><span class="line">    <span class="type">int</span> m,instruction,b;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;instruction;</span><br><span class="line">        <span class="keyword">switch</span> (instruction)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cin&gt;&gt;b;</span><br><span class="line">                IBST.<span class="built_in">insert</span>(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cin&gt;&gt;b;</span><br><span class="line">                IBST.<span class="built_in">find</span>(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cin&gt;&gt;b;</span><br><span class="line">                IBST.<span class="built_in">erase</span>(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cin&gt;&gt;b;</span><br><span class="line">                IBST.<span class="built_in">find</span>(IBST.<span class="built_in">get</span>(b<span class="number">-1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cin&gt;&gt;b;</span><br><span class="line">                IBST.<span class="built_in">erase</span>(IBST.<span class="built_in">get</span>(b<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h3><p>1.updateLeftSizeAfterErase_1和updateLeftSizeAfterErase_2可以合并成updateLeftSize AfterErase，参数为索引二叉搜索树节点类的指针。while循环条件是x!=s，如果s-&gt;key小于x-&gt;key，x-&gt;leftSize减一，x=x-&gt;leftChild，否则x=x-&gt;rightChild。<br />2.插入节点时，对leftSize更新不能边寻找边更新，因为有可能该节点已经存在，不需要再插入，所以需要在插入操作完成后再根据theKey更新。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;  二叉搜索树查找、删除、插入操作的平均性能为O(logn)，最坏情况下的性能为O(n)。索引二叉搜索树为每个节点增加了leftSize域，记录该节点左子树的元素个数，可以按名次进行查找和删除操作，在插入和删除后需要对一些节点的leftSize值进行更新。&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://tongyiheng.top/categories/Computer-Science/"/>
    
    <category term="Data Structures" scheme="https://tongyiheng.top/categories/Computer-Science/Data-Structures/"/>
    
    
    <category term="cpp" scheme="https://tongyiheng.top/tags/cpp/"/>
    
    <category term="indexed binary search tree" scheme="https://tongyiheng.top/tags/indexed-binary-search-tree/"/>
    
  </entry>
  
</feed>
