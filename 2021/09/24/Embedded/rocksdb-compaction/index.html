<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>RocksDB Compaction源码分析 - Avocado Pear</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Avocado Pear"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Avocado Pear"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="RocksDB的Compaction过程整体可分为三个部分，prepare keys、process keys、write keys。"><meta property="og:type" content="blog"><meta property="og:title" content="RocksDB Compaction源码分析"><meta property="og:url" content="https://tongyiheng.top/2021/09/24/Embedded/rocksdb-compaction/"><meta property="og:site_name" content="Avocado Pear"><meta property="og:description" content="RocksDB的Compaction过程整体可分为三个部分，prepare keys、process keys、write keys。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://tongyiheng.top/images/cover/rocksdb.jfif"><meta property="article:published_time" content="2021-09-24T12:30:00.000Z"><meta property="article:modified_time" content="2021-10-19T07:18:29.853Z"><meta property="article:author" content="TongYiheng"><meta property="article:tag" content="RocksDB"><meta property="article:tag" content="cpp"><meta property="article:tag" content="compaction"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/cover/rocksdb.jfif"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tongyiheng.top/2021/09/24/Embedded/rocksdb-compaction/"},"headline":"RocksDB Compaction源码分析","image":[],"datePublished":"2021-09-24T12:30:00.000Z","dateModified":"2021-10-19T07:18:29.853Z","author":{"@type":"Person","name":"TongYiheng"},"publisher":{"@type":"Organization","name":"Avocado Pear","logo":{"@type":"ImageObject","url":"https://tongyiheng.top/img/logo.svg"}},"description":"RocksDB的Compaction过程整体可分为三个部分，prepare keys、process keys、write keys。"}</script><link rel="canonical" href="https://tongyiheng.top/2021/09/24/Embedded/rocksdb-compaction/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Avocado Pear" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Avocado Pear" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/gallery">Gallery</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/TongYiheng/TongYiheng.github.io"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Email" href="mailto:yihengtong@outlook.com"><i class="fa fa-envelope"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/cover/rocksdb.jfif" alt="RocksDB Compaction源码分析"></span></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>RocksDB Compaction源码分析</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2021-09-24T12:30:00.000Z" title="2021-09-24T12:30:00.000Z">2021-09-24</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2021-10-19T07:18:29.853Z" title="2021-10-19T07:18:29.853Z">2021-10-19</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/Embedded/">Embedded</a><span> / </span><a class="link-muted" href="/categories/Embedded/KV-store/">KV store</a></span><span class="level-item"><i class="far fa-clock"></i> an hour read (About 10945 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>  RocksDB的Compaction过程整体可分为三个部分，prepare keys、process keys、write keys。</p>
<span id="more"></span>
<ul>
<li>入口：<code>db/db_impl_compaction_flush.cc</code>中的<code>BackgroundCompaction()</code></li>
</ul>
<h2 id="prepare-keys"><a class="markdownIt-Anchor" href="#prepare-keys"></a> Prepare keys</h2>
<h3 id="触发条件"><a class="markdownIt-Anchor" href="#触发条件"></a> 触发条件</h3>
<ul>
<li>
<p>RocksDB的compaction都是后台运行，通过线程<code>BGWorkCompaction</code>进行compaction的调度。Compaction分为两种：</p>
<ul>
<li>Manual compaction by <code>CompactFiles()</code></li>
<li>Auto compaction by <code>BackgroundCompaction()</code></li>
</ul>
</li>
<li>
<p><code>MaybeScheduleFlushOrCompaction</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (bg_compaction_scheduled_ &lt; bg_job_limits.max_compactions &amp;&amp;</span><br><span class="line">       unscheduled_compactions_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  CompactionArg* ca = <span class="keyword">new</span> CompactionArg;</span><br><span class="line">  ca-&gt;db = <span class="keyword">this</span>;</span><br><span class="line">  ca-&gt;prepicked_compaction = <span class="literal">nullptr</span>;</span><br><span class="line">  bg_compaction_scheduled_++; <span class="comment">//正在被调度的compaction线程数目</span></span><br><span class="line">  unscheduled_compactions_--; <span class="comment">//待调度的线程个数，及待调度的cfd的长度</span></span><br><span class="line">  <span class="comment">//调度BGWorkCompaction线程</span></span><br><span class="line">  env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkCompaction, ca, Env::Priority::LOW, <span class="keyword">this</span>,</span><br><span class="line">                 &amp;DBImpl::UnscheduleCompactionCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	可以看到最大线程数量限制是<code>bg_job_limits.max_compactions</code>。</p>
<ul>
<li>队列<code>DBImpl::compaction_queue_</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;ColumnFamilyData*&gt; compaction_queue_;</span><br></pre></td></tr></table></figure>
<p>​    这个队列的更新是在函数<code>SchedulePendingCompaction</code>更新的，且<code>unscheduled_compactions_</code>变量是和该函数一起更新的，也就是只有设置了该变量才能够正常调度compaction后台线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::SchedulePendingCompaction</span><span class="params">(ColumnFamilyData* cfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cfd-&gt;<span class="built_in">queued_for_compaction</span>() &amp;&amp; cfd-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="built_in">AddToCompactionQueue</span>(cfd);</span><br><span class="line">    ++unscheduled_compactions_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	上面的核心函数是<code>NeedsCompaction</code>,通过这个函数来判断是否有sst需要被compact。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionPicker::NeedsCompaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VersionStorageInfo* vstorage)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">ExpiredTtlFiles</span>().<span class="built_in">empty</span>()) &#123; <span class="comment">//有超时的sst(ExpiredTtlFiles)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">FilesMarkedForPeriodicCompaction</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">BottommostFilesMarkedForCompaction</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;<span class="built_in">FilesMarkedForCompaction</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= vstorage-&gt;<span class="built_in">MaxInputLevel</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vstorage-&gt;<span class="built_in">CompactionScore</span>(i) &gt;= <span class="number">1</span>) &#123; <span class="comment">//遍历所有的level的sst,根据score判断是否需要compact</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sst文件的选择"><a class="markdownIt-Anchor" href="#sst文件的选择"></a> SST文件的选择</h3>
<p>下面这两个变量分别保存了level以及每个level所对应的score，score越高，优先级越高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; compaction_score_; 	<span class="comment">//当前sst的score</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; compaction_level_; 		<span class="comment">//当前sst需要被compact到的层level</span></span><br></pre></td></tr></table></figure>
<p>这两个变量的更新在函数<code>VersionStorageInfo::ComputeCompactionScore</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionStorageInfo::ComputeCompactionScore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ImmutableOptions&amp; immutable_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt;= <span class="built_in">MaxInputLevel</span>(); level++) &#123;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      <span class="type">int</span> num_sorted_runs = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> total_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>* f : files_[level]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f-&gt;being_compacted) &#123;</span><br><span class="line">          total_size += f-&gt;compensated_file_size;</span><br><span class="line">          num_sorted_runs++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compaction_style_ == kCompactionStyleUniversal) &#123;</span><br><span class="line">        <span class="comment">// For universal compaction, we use level0 score to indicate</span></span><br><span class="line">        <span class="comment">// compaction score for the whole DB. Adding other levels as if</span></span><br><span class="line">        <span class="comment">// they are L0 files.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">num_levels</span>(); i++) &#123;</span><br><span class="line">          <span class="comment">// Its possible that a subset of the files in a level may be in a</span></span><br><span class="line">          <span class="comment">// compaction, due to delete triggered compaction or trivial move.</span></span><br><span class="line">          <span class="comment">// In that case, the below check may not catch a level being</span></span><br><span class="line">          <span class="comment">// compacted as it only checks the first file. The worst that can</span></span><br><span class="line">          <span class="comment">// happen is a scheduled compaction thread will find nothing to do.</span></span><br><span class="line">          <span class="keyword">if</span> (!files_[i].<span class="built_in">empty</span>() &amp;&amp; !files_[i][<span class="number">0</span>]-&gt;being_compacted) &#123;</span><br><span class="line">            num_sorted_runs++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (compaction_style_ == kCompactionStyleFIFO) &#123;</span><br><span class="line">        score = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(total_size) /</span><br><span class="line">                mutable_cf_options.compaction_options_fifo.max_table_files_size;</span><br><span class="line">        <span class="keyword">if</span> (mutable_cf_options.compaction_options_fifo.allow_compaction ||</span><br><span class="line">            mutable_cf_options.compaction_options_fifo.age_for_warm &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// Warm tier move can happen at any time. It&#x27;s too expensive to</span></span><br><span class="line">          <span class="comment">// check very file&#x27;s timestamp now. For now, just trigger it</span></span><br><span class="line">          <span class="comment">// slightly more frequently than FIFO compaction so that this</span></span><br><span class="line">          <span class="comment">// happens first.</span></span><br><span class="line">          score = std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num_sorted_runs) /</span><br><span class="line">                  mutable_cf_options.level0_file_num_compaction_trigger,</span><br><span class="line">              score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mutable_cf_options.ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          score = std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">GetExpiredTtlFilesCount</span>(</span><br><span class="line">                  immutable_options, mutable_cf_options, files_[level])),</span><br><span class="line">              score);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        score = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num_sorted_runs) /</span><br><span class="line">                mutable_cf_options.level0_file_num_compaction_trigger;</span><br><span class="line">        <span class="keyword">if</span> (compaction_style_ == kCompactionStyleLevel &amp;&amp; <span class="built_in">num_levels</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// Level-based involves L0-&gt;L0 compactions that can lead to oversized</span></span><br><span class="line">          <span class="comment">// L0 files. Take into account size as well to avoid later giant</span></span><br><span class="line">          <span class="comment">// compactions to the base level.</span></span><br><span class="line">          <span class="type">uint64_t</span> l0_target_size = mutable_cf_options.max_bytes_for_level_base;</span><br><span class="line">          <span class="keyword">if</span> (immutable_options.level_compaction_dynamic_level_bytes &amp;&amp;</span><br><span class="line">              level_multiplier_ != <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="comment">// Prevent L0 to Lbase fanout from growing larger than</span></span><br><span class="line">            <span class="comment">// `level_multiplier_`. This prevents us from getting stuck picking</span></span><br><span class="line">            <span class="comment">// L0 forever even when it is hurting write-amp. That could happen</span></span><br><span class="line">            <span class="comment">// in dynamic level compaction&#x27;s write-burst mode where the base</span></span><br><span class="line">            <span class="comment">// level&#x27;s target size can grow to be enormous.</span></span><br><span class="line">            l0_target_size =</span><br><span class="line">                std::<span class="built_in">max</span>(l0_target_size,</span><br><span class="line">                         <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(level_max_bytes_[base_level_] /</span><br><span class="line">                                               level_multiplier_));</span><br><span class="line">          &#125;</span><br><span class="line">          score =</span><br><span class="line">              std::<span class="built_in">max</span>(score, <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(total_size) / l0_target_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="type">uint64_t</span> level_bytes_no_compacting = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> f : files_[level]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f-&gt;being_compacted) &#123;</span><br><span class="line">          level_bytes_no_compacting += f-&gt;compensated_file_size;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      score = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(level_bytes_no_compacting) /</span><br><span class="line">              <span class="built_in">MaxBytesForLevel</span>(level);</span><br><span class="line">    &#125;</span><br><span class="line">    compaction_level_[level] = level;</span><br><span class="line">    compaction_score_[level] = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sort all the levels based on their score. Higher scores get listed</span></span><br><span class="line">  <span class="comment">// first. Use bubble sort because the number of entries are small.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num_levels</span>() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">num_levels</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compaction_score_[i] &lt; compaction_score_[j]) &#123;</span><br><span class="line">        <span class="type">double</span> score = compaction_score_[i];</span><br><span class="line">        <span class="type">int</span> level = compaction_level_[i];</span><br><span class="line">        compaction_score_[i] = compaction_score_[j];</span><br><span class="line">        compaction_level_[i] = compaction_level_[j];</span><br><span class="line">        compaction_score_[j] = score;</span><br><span class="line">        compaction_level_[j] = level;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ComputeFilesMarkedForCompaction</span>();</span><br><span class="line">  <span class="built_in">ComputeBottommostFilesMarkedForCompaction</span>();</span><br><span class="line">  <span class="keyword">if</span> (mutable_cf_options.ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ComputeExpiredTtlFiles</span>(immutable_options, mutable_cf_options.ttl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mutable_cf_options.periodic_compaction_seconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ComputeFilesMarkedForPeriodicCompaction</span>(</span><br><span class="line">        immutable_options, mutable_cf_options.periodic_compaction_seconds);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">EstimateCompactionBytesNeeded</span>(mutable_cf_options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="compaction每一层level大小的确定"><a class="markdownIt-Anchor" href="#compaction每一层level大小的确定"></a> compaction每一层level大小的确定</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionStorageInfo::CalculateBaseBytes</span><span class="params">(<span class="type">const</span> ImmutableOptions&amp; ioptions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> MutableCFOptions&amp; options)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special logic to set number of sorted runs.</span></span><br><span class="line">  <span class="comment">// It is to match the previous behavior when all files are in L0.</span></span><br><span class="line">  <span class="type">int</span> num_l0_count = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">if</span> (compaction_style_ == kCompactionStyleUniversal) &#123;</span><br><span class="line">    <span class="comment">// For universal compaction, we use level0 score to indicate</span></span><br><span class="line">    <span class="comment">// compaction score for the whole DB. Adding other levels as if</span></span><br><span class="line">    <span class="comment">// they are L0 files.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">num_levels</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!files_[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        num_l0_count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set_l0_delay_trigger_count</span>(num_l0_count);</span><br><span class="line"></span><br><span class="line">  level_max_bytes_.<span class="built_in">resize</span>(ioptions.num_levels);</span><br><span class="line">  <span class="keyword">if</span> (!ioptions.level_compaction_dynamic_level_bytes) &#123;</span><br><span class="line">    base_level_ = (ioptions.compaction_style == kCompactionStyleLevel) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate for static bytes base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ioptions.num_levels; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ioptions.compaction_style == kCompactionStyleUniversal) &#123;</span><br><span class="line">        level_max_bytes_[i] = options.max_bytes_for_level_base;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        level_max_bytes_[i] = <span class="built_in">MultiplyCheckOverflow</span>(</span><br><span class="line">            <span class="built_in">MultiplyCheckOverflow</span>(level_max_bytes_[i - <span class="number">1</span>],</span><br><span class="line">                                  options.max_bytes_for_level_multiplier),</span><br><span class="line">            options.<span class="built_in">MaxBytesMultiplerAdditional</span>(i - <span class="number">1</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        level_max_bytes_[i] = options.max_bytes_for_level_base;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> max_level_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first_non_empty_level = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Find size of non-L0 level of most data.</span></span><br><span class="line">    <span class="comment">// Cannot use the size of the last level because it can be empty or less</span></span><br><span class="line">    <span class="comment">// than previous levels after compaction.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num_levels_; i++) &#123;</span><br><span class="line">      <span class="type">uint64_t</span> total_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : files_[i]) &#123;</span><br><span class="line">        total_size += f-&gt;fd.<span class="built_in">GetFileSize</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (total_size &gt; <span class="number">0</span> &amp;&amp; first_non_empty_level == <span class="number">-1</span>) &#123;</span><br><span class="line">        first_non_empty_level = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (total_size &gt; max_level_size) &#123;</span><br><span class="line">        max_level_size = total_size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prefill every level&#x27;s max bytes to disallow compaction from there.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_levels_; i++) &#123;</span><br><span class="line">      level_max_bytes_[i] = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_level_size == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// No data for L1 and up. L0 compacts to last level directly.</span></span><br><span class="line">      <span class="comment">// No compaction from L1+ needs to be scheduled.</span></span><br><span class="line">      base_level_ = num_levels_ - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">uint64_t</span> l0_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : files_[<span class="number">0</span>]) &#123;</span><br><span class="line">        l0_size += f-&gt;fd.<span class="built_in">GetFileSize</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> base_bytes_max =</span><br><span class="line">          std::<span class="built_in">max</span>(options.max_bytes_for_level_base, l0_size);</span><br><span class="line">      <span class="type">uint64_t</span> base_bytes_min = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">          base_bytes_max / options.max_bytes_for_level_multiplier);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try whether we can make last level&#x27;s target size to be max_level_size</span></span><br><span class="line">      <span class="type">uint64_t</span> cur_level_size = max_level_size;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = num_levels_ - <span class="number">2</span>; i &gt;= first_non_empty_level; i--) &#123; <span class="comment">//从倒数第二层level往上到first non empty level</span></span><br><span class="line">        <span class="comment">// Round up after dividing</span></span><br><span class="line">        cur_level_size = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">            cur_level_size / options.max_bytes_for_level_multiplier);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Calculate base level and its size.</span></span><br><span class="line">      <span class="type">uint64_t</span> base_level_size;</span><br><span class="line">      <span class="keyword">if</span> (cur_level_size &lt;= base_bytes_min) &#123;</span><br><span class="line">        <span class="comment">// Case 1. If we make target size of last level to be max_level_size,</span></span><br><span class="line">        <span class="comment">// target size of the first non-empty level would be smaller than</span></span><br><span class="line">        <span class="comment">// base_bytes_min. We set it be base_bytes_min.</span></span><br><span class="line">        base_level_size = base_bytes_min + <span class="number">1U</span>;</span><br><span class="line">        base_level_ = first_non_empty_level;</span><br><span class="line">        <span class="built_in">ROCKS_LOG_INFO</span>(ioptions.logger,</span><br><span class="line">                       <span class="string">&quot;More existing levels in DB than needed. &quot;</span></span><br><span class="line">                       <span class="string">&quot;max_bytes_for_level_multiplier may not be guaranteed.&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find base level (where L0 data is compacted to).</span></span><br><span class="line">        base_level_ = first_non_empty_level;</span><br><span class="line">        <span class="keyword">while</span> (base_level_ &gt; <span class="number">1</span> &amp;&amp; cur_level_size &gt; base_bytes_max) &#123;</span><br><span class="line">          --base_level_;</span><br><span class="line">          cur_level_size = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">              cur_level_size / options.max_bytes_for_level_multiplier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_level_size &gt; base_bytes_max) &#123;</span><br><span class="line">          <span class="comment">// Even L1 will be too large</span></span><br><span class="line">          <span class="built_in">assert</span>(base_level_ == <span class="number">1</span>);</span><br><span class="line">          base_level_size = base_bytes_max;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          base_level_size = cur_level_size;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      level_multiplier_ = options.max_bytes_for_level_multiplier;</span><br><span class="line">      <span class="built_in">assert</span>(base_level_size &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (l0_size &gt; base_level_size &amp;&amp;</span><br><span class="line">          (l0_size &gt; options.max_bytes_for_level_base ||</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(files_[<span class="number">0</span>].<span class="built_in">size</span>() / <span class="number">2</span>) &gt;=</span><br><span class="line">               options.level0_file_num_compaction_trigger)) &#123;</span><br><span class="line">        <span class="comment">// We adjust the base level according to actual L0 size, and adjust</span></span><br><span class="line">        <span class="comment">// the level multiplier accordingly, when:</span></span><br><span class="line">        <span class="comment">//   1. the L0 size is larger than level size base, or</span></span><br><span class="line">        <span class="comment">//   2. number of L0 files reaches twice the L0-&gt;L1 compaction trigger</span></span><br><span class="line">        <span class="comment">// We don&#x27;t do this otherwise to keep the LSM-tree structure stable</span></span><br><span class="line">        <span class="comment">// unless the L0 compaction is backlogged.</span></span><br><span class="line">        base_level_size = l0_size;</span><br><span class="line">        <span class="keyword">if</span> (base_level_ == num_levels_ - <span class="number">1</span>) &#123;</span><br><span class="line">          level_multiplier_ = <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          level_multiplier_ = std::<span class="built_in">pow</span>(</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(max_level_size) /</span><br><span class="line">                  <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(base_level_size),</span><br><span class="line">              <span class="number">1.0</span> / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num_levels_ - base_level_ - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> level_size = base_level_size;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = base_level_; i &lt; num_levels_; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; base_level_) &#123;</span><br><span class="line">          level_size = <span class="built_in">MultiplyCheckOverflow</span>(level_size, level_multiplier_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don&#x27;t set any level below base_bytes_max. Otherwise, the LSM can</span></span><br><span class="line">        <span class="comment">// assume an hourglass shape where L1+ sizes are smaller than L0. This</span></span><br><span class="line">        <span class="comment">// causes compaction scoring, which depends on level sizes, to favor L1+</span></span><br><span class="line">        <span class="comment">// at the expense of L0, which may fill up and stall.</span></span><br><span class="line">        level_max_bytes_[i] = std::<span class="built_in">max</span>(level_size, base_bytes_max);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>static：每一层的大小都是固定的</p>
</li>
<li>
<p>dynamic：动态根据每一层大小进行计算</p>
</li>
</ol>
<ul>
<li>引入base level的概念，通常使用空间放大来衡量空间效率，忽略数据压缩的影响，空间放大 = size_on_file_system / size_of_user_data。</li>
</ul>
<h3 id="挑选参与compaction的文件"><a class="markdownIt-Anchor" href="#挑选参与compaction的文件"></a> 挑选参与compaction的文件</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">LevelCompactionBuilder::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pick up the first file to start compaction. It may have been extended</span></span><br><span class="line">  <span class="comment">// to a clean cut.</span></span><br><span class="line">  <span class="built_in">SetupInitialFiles</span>();</span><br><span class="line">  <span class="keyword">if</span> (start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(start_level_ &gt;= <span class="number">0</span> &amp;&amp; output_level_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it is a L0 -&gt; base level compaction, we need to set up other L0</span></span><br><span class="line">  <span class="comment">// files if needed.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SetupOtherL0FilesIfNeeded</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick files in the output level and expand more files in the start level</span></span><br><span class="line">  <span class="comment">// if needed.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SetupOtherInputsIfNeeded</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Form a compaction object containing the files we picked.</span></span><br><span class="line">  Compaction* c = <span class="built_in">GetCompaction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;LevelCompactionPicker::PickCompaction:Return&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里PickCompaction分别调用了三个主要的函数。</p>
<ul>
<li><code>SetupInitialFiles</code> 初始化需要compact的文件</li>
<li><code>SetupOtherL0FilesIfNeeded</code> 如果需要的话，setup一些其他的L0文件</li>
<li><code>SetupOtherInputsIfNeeded</code> 如果需要的话，setup一些其他的inputs</li>
</ul>
<p>下面首先分析<code>SetupInitialFiles</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelCompactionBuilder::SetupInitialFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Find the compactions by size on all levels.</span></span><br><span class="line">  <span class="type">bool</span> skipped_l0_to_base = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; compaction_picker_-&gt;<span class="built_in">NumberLevels</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    start_level_score_ = vstorage_-&gt;<span class="built_in">CompactionScore</span>(i);</span><br><span class="line">    start_level_ = vstorage_-&gt;<span class="built_in">CompactionScoreLevel</span>(i);</span><br><span class="line">    <span class="built_in">assert</span>(i == <span class="number">0</span> || start_level_score_ &lt;= vstorage_-&gt;<span class="built_in">CompactionScore</span>(i - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (start_level_score_ &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (skipped_l0_to_base &amp;&amp; start_level_ == vstorage_-&gt;<span class="built_in">base_level</span>()) &#123;</span><br><span class="line">        <span class="comment">// If L0-&gt;base_level compaction is pending, don&#x27;t schedule further</span></span><br><span class="line">        <span class="comment">// compaction from base level. Otherwise L0-&gt;base_level compaction</span></span><br><span class="line">        <span class="comment">// may starve.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      output_level_ =</span><br><span class="line">          (start_level_ == <span class="number">0</span>) ? vstorage_-&gt;<span class="built_in">base_level</span>() : start_level_ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">PickFileToCompact</span>()) &#123;</span><br><span class="line">        <span class="comment">// found the compaction!</span></span><br><span class="line">        <span class="keyword">if</span> (start_level_ == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// L0 score = `num L0 files` / `level0_file_num_compaction_trigger`</span></span><br><span class="line">          compaction_reason_ = CompactionReason::kLevelL0FilesNum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// L1+ score = `Level files size` / `MaxBytesForLevel`</span></span><br><span class="line">          compaction_reason_ = CompactionReason::kLevelMaxLevelSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// didn&#x27;t find the compaction, clear the inputs</span></span><br><span class="line">        start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (start_level_ == <span class="number">0</span>) &#123;</span><br><span class="line">          skipped_l0_to_base = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// L0-&gt;base_level may be blocked due to ongoing L0-&gt;base_level</span></span><br><span class="line">          <span class="comment">// compactions. It may also be blocked by an ongoing compaction from</span></span><br><span class="line">          <span class="comment">// base_level downwards.</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// In these cases, to reduce L0 file count and thus reduce likelihood</span></span><br><span class="line">          <span class="comment">// of write stalls, we can attempt compacting a span of files within</span></span><br><span class="line">          <span class="comment">// L0.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">PickIntraL0Compaction</span>()) &#123;</span><br><span class="line">            output_level_ = <span class="number">0</span>;</span><br><span class="line">            compaction_reason_ = CompactionReason::kLevelL0FilesNum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compaction scores are sorted in descending order, no further scores</span></span><br><span class="line">      <span class="comment">// will be &gt;= 1.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we didn&#x27;t find a compaction, check if there are any files marked for</span></span><br><span class="line">  <span class="comment">// compaction</span></span><br><span class="line">  parent_index_ = base_index_ = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  compaction_picker_-&gt;<span class="built_in">PickFilesMarkedForCompaction</span>(</span><br><span class="line">      cf_name_, vstorage_, &amp;start_level_, &amp;output_level_, &amp;start_level_inputs_);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kFilesMarkedForCompaction;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bottommost Files Compaction on deleting tombstones</span></span><br><span class="line">  <span class="built_in">PickFileToCompact</span>(vstorage_-&gt;<span class="built_in">BottommostFilesMarkedForCompaction</span>(), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kBottommostFiles;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TTL Compaction</span></span><br><span class="line">  <span class="built_in">PickFileToCompact</span>(vstorage_-&gt;<span class="built_in">ExpiredTtlFiles</span>(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kTtl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Periodic Compaction</span></span><br><span class="line">  <span class="built_in">PickFileToCompact</span>(vstorage_-&gt;<span class="built_in">FilesMarkedForPeriodicCompaction</span>(), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (!start_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compaction_reason_ = CompactionReason::kPeriodicCompaction;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>首先遍历所有的level，从之前计算好的的compaction信息中得到每个level对应的score，只有当score&gt;=1才能继续进行compact的处理。</p>
</li>
<li>
<p>通过<code>PickFileToCompact</code>来选择input以及output文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionBuilder::PickFileToCompact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// level 0 files are overlapping. So we cannot pick more</span></span><br><span class="line">  <span class="comment">// than one concurrent compactions at this level. This</span></span><br><span class="line">  <span class="comment">// could be made better by looking at key-ranges that are</span></span><br><span class="line">  <span class="comment">// being compacted at level 0.</span></span><br><span class="line">  <span class="keyword">if</span> (start_level_ == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      !compaction_picker_-&gt;<span class="built_in">level0_compactions_in_progress</span>()-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;LevelCompactionPicker::PickCompactionBySize:0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(start_level_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick the largest file in this level that is not already</span></span><br><span class="line">  <span class="comment">// being compacted</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; file_size =</span><br><span class="line">      vstorage_-&gt;<span class="built_in">FilesByCompactionPri</span>(start_level_);</span><br><span class="line">  <span class="type">const</span> std::vector&lt;FileMetaData*&gt;&amp; level_files =</span><br><span class="line">      vstorage_-&gt;<span class="built_in">LevelFiles</span>(start_level_);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cmp_idx;</span><br><span class="line">  <span class="keyword">for</span> (cmp_idx = vstorage_-&gt;<span class="built_in">NextCompactionIndex</span>(start_level_);</span><br><span class="line">       cmp_idx &lt; file_size.<span class="built_in">size</span>(); cmp_idx++) &#123;</span><br><span class="line">    <span class="type">int</span> index = file_size[cmp_idx];</span><br><span class="line">    <span class="keyword">auto</span>* f = level_files[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not pick a file to compact if it is being compacted</span></span><br><span class="line">    <span class="comment">// from n-1 level.</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;being_compacted) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_level_inputs_.files.<span class="built_in">push_back</span>(f);</span><br><span class="line">    start_level_inputs_.level = start_level_;</span><br><span class="line">    <span class="keyword">if</span> (!compaction_picker_-&gt;<span class="built_in">ExpandInputsToCleanCut</span>(cf_name_, vstorage_,</span><br><span class="line">                                                    &amp;start_level_inputs_) ||</span><br><span class="line">        compaction_picker_-&gt;<span class="built_in">FilesRangeOverlapWithCompaction</span>(</span><br><span class="line">            &#123;start_level_inputs_&#125;, output_level_)) &#123;</span><br><span class="line">      <span class="comment">// A locked (pending compaction) input-level file was pulled in due to</span></span><br><span class="line">      <span class="comment">// user-key overlap.</span></span><br><span class="line">      start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that input level is fully expanded, we check whether any output files</span></span><br><span class="line">    <span class="comment">// are locked due to pending compaction.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note we rely on ExpandInputsToCleanCut() to tell us whether any output-</span></span><br><span class="line">    <span class="comment">// level files are locked, not just the extra ones pulled in for user-key</span></span><br><span class="line">    <span class="comment">// overlap.</span></span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    compaction_picker_-&gt;<span class="built_in">GetRange</span>(start_level_inputs_, &amp;smallest, &amp;largest);</span><br><span class="line">    CompactionInputFiles output_level_inputs;</span><br><span class="line">    output_level_inputs.level = output_level_;</span><br><span class="line">    vstorage_-&gt;<span class="built_in">GetOverlappingInputs</span>(output_level_, &amp;smallest, &amp;largest,</span><br><span class="line">                                    &amp;output_level_inputs.files);</span><br><span class="line">    <span class="keyword">if</span> (!output_level_inputs.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">        !compaction_picker_-&gt;<span class="built_in">ExpandInputsToCleanCut</span>(cf_name_, vstorage_,</span><br><span class="line">                                                    &amp;output_level_inputs)) &#123;</span><br><span class="line">      start_level_inputs_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base_index_ = index;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store where to start the iteration in the next call to PickCompaction</span></span><br><span class="line">  vstorage_-&gt;<span class="built_in">SetNextCompactionIndex</span>(start_level_, cmp_idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> start_level_inputs_.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>首先得到当前level(start_level_)的未compacted的最大大小的文件。</p>
</li>
<li>
<p>通过cmp_idx索引到对应的文件。</p>
</li>
<li>
<p>通过<code>ExpandInputsToCleanCut</code>扩展当前文件的key的范围，需要满足&quot;<a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Choose-Level-Compaction-Files">clean cut</a>&quot;。</p>
</li>
<li>
<p>通过<code>FilesRangeOverlapWithCompaction</code>判断是否有正在compact的out_level的文件范围和已经选择好的文件的key有overlap，如果有则跳过（clear start_level_inputs然后continue）。</p>
</li>
<li>
<p>最后在output_level中选择和start_level已经选择的文件的key有overlap的文件，通过<code>ExpandInputsToCleanCut</code>来判断output level files是否有被lock的，如果有则跳过（clear start_level_inputs然后continue）。</p>
</li>
</ul>
</li>
</ul>
<p>继续分析<code>PickCompaction</code>，在RocksDB中level-0比较特殊，因为只有level-0中的sst文件之间是无序的，因此接下来我们需要特殊处理level-0的情况，这个函数就是<code>SetupOtherL0FilesIfNeeded</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionBuilder::SetupOtherL0FilesIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start_level_ == <span class="number">0</span> &amp;&amp; output_level_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> compaction_picker_-&gt;<span class="built_in">GetOverlappingL0Files</span>(</span><br><span class="line">        vstorage_, &amp;start_level_inputs_, output_level_, &amp;parent_index_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用start_level_ == 0 且 output_level_ != 0则调用<code>GetOverlappingL0Files</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompactionPicker::GetOverlappingL0Files</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionStorageInfo* vstorage, CompactionInputFiles* start_level_inputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> output_level, <span class="type">int</span>* parent_index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Two level 0 compaction won&#x27;t run at the same time, so don&#x27;t need to worry</span></span><br><span class="line">  <span class="comment">// about files on level 0 being compacted.</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">level0_compactions_in_progress</span>()-&gt;<span class="built_in">empty</span>());</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  <span class="built_in">GetRange</span>(*start_level_inputs, &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">  <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">  <span class="comment">// which will include the picked file.</span></span><br><span class="line">  start_level_inputs-&gt;files.<span class="built_in">clear</span>();</span><br><span class="line">  vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(<span class="number">0</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;(start_level_inputs-&gt;files));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we include more L0 files in the same compaction run it can</span></span><br><span class="line">  <span class="comment">// cause the &#x27;smallest&#x27; and &#x27;largest&#x27; key to get extended to a</span></span><br><span class="line">  <span class="comment">// larger range. So, re-invoke GetRange to get the new key range</span></span><br><span class="line">  <span class="built_in">GetRange</span>(*start_level_inputs, &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsRangeInCompaction</span>(vstorage, &amp;smallest, &amp;largest, output_level,</span><br><span class="line">                          parent_index)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(!start_level_inputs-&gt;files.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从level-0中得到所有的重合key的文件，然后加入到start_level_inputs中。</li>
</ul>
<p>最后调用<code>SetupOtherInputsIfNeeded()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LevelCompactionBuilder::SetupOtherInputsIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Setup input files from output level. For output to L0, we only compact</span></span><br><span class="line">  <span class="comment">// spans of files that do not interact with any pending compactions, so don&#x27;t</span></span><br><span class="line">  <span class="comment">// need to consider other levels.</span></span><br><span class="line">  <span class="keyword">if</span> (output_level_ != <span class="number">0</span>) &#123;</span><br><span class="line">    output_level_inputs_.level = output_level_;</span><br><span class="line">    <span class="keyword">if</span> (!compaction_picker_-&gt;<span class="built_in">SetupOtherInputs</span>(</span><br><span class="line">            cf_name_, mutable_cf_options_, vstorage_, &amp;start_level_inputs_,</span><br><span class="line">            &amp;output_level_inputs_, &amp;parent_index_, base_index_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compaction_inputs_.<span class="built_in">push_back</span>(start_level_inputs_);</span><br><span class="line">    <span class="keyword">if</span> (!output_level_inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      compaction_inputs_.<span class="built_in">push_back</span>(output_level_inputs_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In some edge cases we could pick a compaction that will be compacting</span></span><br><span class="line">    <span class="comment">// a key range that overlap with another running compaction, and both</span></span><br><span class="line">    <span class="comment">// of them have the same output level. This could happen if</span></span><br><span class="line">    <span class="comment">// (1) we are running a non-exclusive manual compaction</span></span><br><span class="line">    <span class="comment">// (2) AddFile ingest a new file into the LSM tree</span></span><br><span class="line">    <span class="comment">// We need to disallow this from happening.</span></span><br><span class="line">    <span class="keyword">if</span> (compaction_picker_-&gt;<span class="built_in">FilesRangeOverlapWithCompaction</span>(compaction_inputs_,</span><br><span class="line">                                                            output_level_)) &#123;</span><br><span class="line">      <span class="comment">// This compaction output could potentially conflict with the output</span></span><br><span class="line">      <span class="comment">// of a currently running compaction, we cannot run it.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    compaction_picker_-&gt;<span class="built_in">GetGrandparents</span>(vstorage_, start_level_inputs_,</span><br><span class="line">                                        output_level_inputs_, &amp;grandparents_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compaction_inputs_.<span class="built_in">push_back</span>(start_level_inputs_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>调用<code>SetupOtherInputs</code>，扩展start_level_inputs对应的output。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Populates the set of inputs of all other levels that overlap with the</span></span><br><span class="line"><span class="comment">// start level.</span></span><br><span class="line"><span class="comment">// Now we assume all levels except start level and output level are empty.</span></span><br><span class="line"><span class="comment">// Will also attempt to expand &quot;start level&quot; if that doesn&#x27;t expand</span></span><br><span class="line"><span class="comment">// &quot;output level&quot; or cause &quot;level&quot; to include a file for compaction that has an</span></span><br><span class="line"><span class="comment">// overlapping user-key with another file.</span></span><br><span class="line"><span class="comment">// REQUIRES: input_level and output_level are different</span></span><br><span class="line"><span class="comment">// REQUIRES: inputs-&gt;empty() == false</span></span><br><span class="line"><span class="comment">// Returns false if files on parent level are currently in compaction, which</span></span><br><span class="line"><span class="comment">// means that we can&#x27;t compact them</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompactionPicker::SetupOtherInputs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; cf_name, <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionStorageInfo* vstorage, CompactionInputFiles* inputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    CompactionInputFiles* output_level_inputs, <span class="type">int</span>* parent_index,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> base_index)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!inputs-&gt;<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">assert</span>(output_level_inputs-&gt;<span class="built_in">empty</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> input_level = inputs-&gt;level;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> output_level = output_level_inputs-&gt;level;</span><br><span class="line">  <span class="keyword">if</span> (input_level == output_level) &#123;</span><br><span class="line">    <span class="comment">// no possibility of conflict</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For now, we only support merging two levels, start level and output level.</span></span><br><span class="line">  <span class="comment">// We need to assert other levels are empty.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = input_level + <span class="number">1</span>; l &lt; output_level; l++) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(vstorage-&gt;<span class="built_in">NumLevelFiles</span>(l) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the range one last time.</span></span><br><span class="line">  <span class="built_in">GetRange</span>(*inputs, &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Populate the set of next-level files (inputs_GetOutputLevelInputs()) to</span></span><br><span class="line">  <span class="comment">// include in compaction</span></span><br><span class="line">  vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(output_level, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;output_level_inputs-&gt;files, *parent_index,</span><br><span class="line">                                 parent_index);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">AreFilesInCompaction</span>(output_level_inputs-&gt;files)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!output_level_inputs-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ExpandInputsToCleanCut</span>(cf_name, vstorage, output_level_inputs)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we can further grow the number of inputs in &quot;level&quot; without</span></span><br><span class="line">  <span class="comment">// changing the number of &quot;level+1&quot; files we pick up. We also choose NOT</span></span><br><span class="line">  <span class="comment">// to expand if this would cause &quot;level&quot; to include some entries for some</span></span><br><span class="line">  <span class="comment">// user key, while excluding other entries for the same user key. This</span></span><br><span class="line">  <span class="comment">// can happen when one user key spans multiple files.</span></span><br><span class="line">  <span class="keyword">if</span> (!output_level_inputs-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> limit = mutable_cf_options.max_compaction_bytes;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> output_level_inputs_size =</span><br><span class="line">        <span class="built_in">TotalCompensatedFileSize</span>(output_level_inputs-&gt;files);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> inputs_size = <span class="built_in">TotalCompensatedFileSize</span>(inputs-&gt;files);</span><br><span class="line">    <span class="type">bool</span> expand_inputs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CompactionInputFiles expanded_inputs;</span><br><span class="line">    expanded_inputs.level = input_level;</span><br><span class="line">    <span class="comment">// Get closed interval of output level</span></span><br><span class="line">    InternalKey all_start, all_limit;</span><br><span class="line">    <span class="built_in">GetRange</span>(*inputs, *output_level_inputs, &amp;all_start, &amp;all_limit);</span><br><span class="line">    <span class="type">bool</span> try_overlapping_inputs = <span class="literal">true</span>;</span><br><span class="line">    vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(input_level, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;expanded_inputs.files, base_index, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">uint64_t</span> expanded_inputs_size =</span><br><span class="line">        <span class="built_in">TotalCompensatedFileSize</span>(expanded_inputs.files);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ExpandInputsToCleanCut</span>(cf_name, vstorage, &amp;expanded_inputs)) &#123;</span><br><span class="line">      try_overlapping_inputs = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (try_overlapping_inputs &amp;&amp; expanded_inputs.<span class="built_in">size</span>() &gt; inputs-&gt;<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        output_level_inputs_size + expanded_inputs_size &lt; limit &amp;&amp;</span><br><span class="line">        !<span class="built_in">AreFilesInCompaction</span>(expanded_inputs.files)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      <span class="built_in">GetRange</span>(expanded_inputs, &amp;new_start, &amp;new_limit);</span><br><span class="line">      CompactionInputFiles expanded_output_level_inputs;</span><br><span class="line">      expanded_output_level_inputs.level = output_level;</span><br><span class="line">      vstorage-&gt;<span class="built_in">GetOverlappingInputs</span>(output_level, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded_output_level_inputs.files,</span><br><span class="line">                                     *parent_index, parent_index);</span><br><span class="line">      <span class="built_in">assert</span>(!expanded_output_level_inputs.<span class="built_in">empty</span>());</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">AreFilesInCompaction</span>(expanded_output_level_inputs.files) &amp;&amp;</span><br><span class="line">          <span class="built_in">ExpandInputsToCleanCut</span>(cf_name, vstorage,</span><br><span class="line">                                 &amp;expanded_output_level_inputs) &amp;&amp;</span><br><span class="line">          expanded_output_level_inputs.<span class="built_in">size</span>() == output_level_inputs-&gt;<span class="built_in">size</span>()) &#123;</span><br><span class="line">        expand_inputs = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!expand_inputs) &#123;</span><br><span class="line">      vstorage-&gt;<span class="built_in">GetCleanInputsWithinInterval</span>(input_level, &amp;all_start,</span><br><span class="line">                                             &amp;all_limit, &amp;expanded_inputs.files,</span><br><span class="line">                                             base_index, <span class="literal">nullptr</span>);</span><br><span class="line">      expanded_inputs_size = <span class="built_in">TotalCompensatedFileSize</span>(expanded_inputs.files);</span><br><span class="line">      <span class="keyword">if</span> (expanded_inputs.<span class="built_in">size</span>() &gt; inputs-&gt;<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">          output_level_inputs_size + expanded_inputs_size &lt; limit &amp;&amp;</span><br><span class="line">          !<span class="built_in">AreFilesInCompaction</span>(expanded_inputs.files)) &#123;</span><br><span class="line">        expand_inputs = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expand_inputs) &#123;</span><br><span class="line">      <span class="built_in">ROCKS_LOG_INFO</span>(ioptions_.logger,</span><br><span class="line">                     <span class="string">&quot;[%s] Expanding@%d %&quot;</span> ROCKSDB_PRIszt <span class="string">&quot;+%&quot;</span> ROCKSDB_PRIszt</span><br><span class="line">                     <span class="string">&quot;(%&quot;</span> PRIu64 <span class="string">&quot;+%&quot;</span> PRIu64 <span class="string">&quot; bytes) to %&quot;</span> ROCKSDB_PRIszt</span><br><span class="line">                     <span class="string">&quot;+%&quot;</span> ROCKSDB_PRIszt <span class="string">&quot; (%&quot;</span> PRIu64 <span class="string">&quot;+%&quot;</span> PRIu64 <span class="string">&quot; bytes)\n&quot;</span>,</span><br><span class="line">                     cf_name.<span class="built_in">c_str</span>(), input_level, inputs-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                     output_level_inputs-&gt;<span class="built_in">size</span>(), inputs_size,</span><br><span class="line">                     output_level_inputs_size, expanded_inputs.<span class="built_in">size</span>(),</span><br><span class="line">                     output_level_inputs-&gt;<span class="built_in">size</span>(), expanded_inputs_size,</span><br><span class="line">                     output_level_inputs_size);</span><br><span class="line">      inputs-&gt;files = expanded_inputs.files;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将start_level_inputs和output_level_inputs加入到compaction_inputs中。</p>
</li>
<li>
<p>防止一些可能会出现的conflict情况，进行一些判断。</p>
</li>
</ul>
<p>回到<code>PickCompaction</code>函数，最后构造一个compaction然后返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Form a compaction object containing the files we picked.</span></span><br><span class="line">Compaction* c = <span class="built_in">GetCompaction</span>();</span><br><span class="line"><span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;LevelCompactionPicker::PickCompaction:Return&quot;</span>, c);</span><br><span class="line"><span class="keyword">return</span> c;</span><br></pre></td></tr></table></figure>
<h3 id="compaction-job根据获取到数据分配compaction线程"><a class="markdownIt-Anchor" href="#compaction-job根据获取到数据分配compaction线程"></a> Compaction job:根据获取到数据分配compaction线程</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:BeforeCompaction&quot;</span>,</span><br><span class="line">                             c-&gt;<span class="built_in">column_family_data</span>());</span><br><span class="line">    <span class="type">int</span> output_level __attribute__((__unused__));</span><br><span class="line">    output_level = c-&gt;<span class="built_in">output_level</span>();</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:NonTrivial&quot;</span>,</span><br><span class="line">                             &amp;output_level);</span><br><span class="line">    std::vector&lt;SequenceNumber&gt; snapshot_seqs;</span><br><span class="line">    SequenceNumber earliest_write_conflict_snapshot;</span><br><span class="line">    SnapshotChecker* snapshot_checker;</span><br><span class="line">    <span class="built_in">GetSnapshotContext</span>(job_context, &amp;snapshot_seqs,</span><br><span class="line">                       &amp;earliest_write_conflict_snapshot, &amp;snapshot_checker);</span><br><span class="line">    <span class="built_in">assert</span>(is_snapshot_supported_ || snapshots_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="function">CompactionJob <span class="title">compaction_job</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        job_context-&gt;job_id, c.get(), immutable_db_options_,</span></span></span><br><span class="line"><span class="params"><span class="function">        mutable_db_options_, file_options_for_compaction_, versions_.get(),</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;shutting_down_, preserve_deletes_seqnum_.load(), log_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        directories_.GetDbDir(),</span></span></span><br><span class="line"><span class="params"><span class="function">        GetDataDir(c-&gt;column_family_data(), c-&gt;output_path_id()),</span></span></span><br><span class="line"><span class="params"><span class="function">        GetDataDir(c-&gt;column_family_data(), <span class="number">0</span>), stats_, &amp;mutex_,</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;error_handler_, snapshot_seqs, earliest_write_conflict_snapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">        snapshot_checker, table_cache_, &amp;event_logger_,</span></span></span><br><span class="line"><span class="params"><span class="function">        c-&gt;mutable_cf_options()-&gt;paranoid_file_checks,</span></span></span><br><span class="line"><span class="params"><span class="function">        c-&gt;mutable_cf_options()-&gt;report_bg_io_stats, dbname_,</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;compaction_job_stats, thread_pri, io_tracer_,</span></span></span><br><span class="line"><span class="params"><span class="function">        is_manual ? &amp;manual_compaction_paused_ : <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        is_manual ? manual_compaction-&gt;canceled : <span class="literal">nullptr</span>, db_id_,</span></span></span><br><span class="line"><span class="params"><span class="function">        db_session_id_, c-&gt;column_family_data()-&gt;GetFullHistoryTsLow(),</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;blob_callback_)</span></span>;</span><br><span class="line">    compaction_job.<span class="built_in">Prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NotifyOnCompactionBegin</span>(c-&gt;<span class="built_in">column_family_data</span>(), c.<span class="built_in">get</span>(), status,</span><br><span class="line">                            compaction_job_stats, job_context-&gt;job_id);</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(</span><br><span class="line">        <span class="string">&quot;DBImpl::BackgroundCompaction:NonTrivial:BeforeRun&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// Should handle erorr?</span></span><br><span class="line">    compaction_job.<span class="built_in">Run</span>().<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:NonTrivial:AfterRun&quot;</span>);</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">    status = compaction_job.<span class="built_in">Install</span>(*c-&gt;<span class="built_in">mutable_cf_options</span>());</span><br><span class="line">    io_s = compaction_job.<span class="built_in">io_status</span>();</span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">InstallSuperVersionAndScheduleWork</span>(c-&gt;<span class="built_in">column_family_data</span>(),</span><br><span class="line">                                         &amp;job_context-&gt;superversion_contexts[<span class="number">0</span>],</span><br><span class="line">                                         *c-&gt;<span class="built_in">mutable_cf_options</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    *made_progress = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;DBImpl::BackgroundCompaction:AfterCompaction&quot;</span>,</span><br><span class="line">                             c-&gt;<span class="built_in">column_family_data</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>Prepare</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompactionJob::Prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_COMPACTION_PREPARE)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate file_levels_ for compaction before making Iterator</span></span><br><span class="line">  <span class="keyword">auto</span>* c = compact_-&gt;compaction;</span><br><span class="line">  <span class="built_in">assert</span>(c-&gt;<span class="built_in">column_family_data</span>() != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(c-&gt;<span class="built_in">column_family_data</span>()-&gt;<span class="built_in">current</span>()-&gt;<span class="built_in">storage_info</span>()-&gt;<span class="built_in">NumLevelFiles</span>(</span><br><span class="line">             compact_-&gt;compaction-&gt;<span class="built_in">level</span>()) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  write_hint_ =</span><br><span class="line">      c-&gt;<span class="built_in">column_family_data</span>()-&gt;<span class="built_in">CalculateSSTWriteHint</span>(c-&gt;<span class="built_in">output_level</span>());</span><br><span class="line">  bottommost_level_ = c-&gt;<span class="built_in">bottommost_level</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;<span class="built_in">ShouldFormSubcompactions</span>()) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">StopWatch <span class="title">sw</span><span class="params">(db_options_.clock, stats_, SUBCOMPACTION_SETUP_TIME)</span></span>;</span><br><span class="line">      <span class="built_in">GenSubcompactionBoundaries</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(sizes_.<span class="built_in">size</span>() == boundaries_.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= boundaries_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      Slice* start = i == <span class="number">0</span> ? <span class="literal">nullptr</span> : &amp;boundaries_[i - <span class="number">1</span>];</span><br><span class="line">      Slice* end = i == boundaries_.<span class="built_in">size</span>() ? <span class="literal">nullptr</span> : &amp;boundaries_[i];</span><br><span class="line">      compact_-&gt;sub_compact_states.<span class="built_in">emplace_back</span>(c, start, end, sizes_[i],</span><br><span class="line">                                                <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RecordInHistogram</span>(stats_, NUM_SUBCOMPACTIONS_SCHEDULED,</span><br><span class="line">                      compact_-&gt;sub_compact_states.<span class="built_in">size</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> Slice* start = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> Slice* end = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">uint64_t</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    compact_-&gt;sub_compact_states.<span class="built_in">emplace_back</span>(c, start, end, size,</span><br><span class="line">                                              <span class="comment">/*sub_job_id*/</span> <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>调用<code>GenSubcompactionBoundaries</code>构造subcompaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompactionJob::GenSubcompactionBoundaries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* c = compact_-&gt;compaction;</span><br><span class="line">  <span class="keyword">auto</span>* cfd = c-&gt;<span class="built_in">column_family_data</span>();</span><br><span class="line">  <span class="type">const</span> Comparator* cfd_comparator = cfd-&gt;<span class="built_in">user_comparator</span>();</span><br><span class="line">  std::vector&lt;Slice&gt; bounds;</span><br><span class="line">  <span class="type">int</span> start_lvl = c-&gt;<span class="built_in">start_level</span>();</span><br><span class="line">  <span class="type">int</span> out_lvl = c-&gt;<span class="built_in">output_level</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the starting and/or ending key of certain input files as a potential</span></span><br><span class="line">  <span class="comment">// boundary</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> lvl_idx = <span class="number">0</span>; lvl_idx &lt; c-&gt;<span class="built_in">num_input_levels</span>(); lvl_idx++) &#123;</span><br><span class="line">    <span class="type">int</span> lvl = c-&gt;<span class="built_in">level</span>(lvl_idx);</span><br><span class="line">    <span class="keyword">if</span> (lvl &gt;= start_lvl &amp;&amp; lvl &lt;= out_lvl) &#123;</span><br><span class="line">      <span class="type">const</span> LevelFilesBrief* flevel = c-&gt;<span class="built_in">input_levels</span>(lvl_idx);</span><br><span class="line">      <span class="type">size_t</span> num_files = flevel-&gt;num_files;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num_files == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lvl == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// For level 0 add the starting and ending key of each file since the</span></span><br><span class="line">        <span class="comment">// files may have greatly differing key ranges (not range-partitioned)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">          bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[i].smallest_key);</span><br><span class="line">          bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[i].largest_key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For all other levels add the smallest/largest key in the level to</span></span><br><span class="line">        <span class="comment">// encompass the range covered by that level</span></span><br><span class="line">        bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[<span class="number">0</span>].smallest_key);</span><br><span class="line">        bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[num_files - <span class="number">1</span>].largest_key);</span><br><span class="line">        <span class="keyword">if</span> (lvl == out_lvl) &#123;</span><br><span class="line">          <span class="comment">// For the last level include the starting keys of all files since</span></span><br><span class="line">          <span class="comment">// the last level is the largest and probably has the widest key</span></span><br><span class="line">          <span class="comment">// range. Since it&#x27;s range partitioned, the ending key of one file</span></span><br><span class="line">          <span class="comment">// and the starting key of the next are very close (or identical).</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">            bounds.<span class="built_in">emplace_back</span>(flevel-&gt;files[i].smallest_key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(bounds.<span class="built_in">begin</span>(), bounds.<span class="built_in">end</span>(),</span><br><span class="line">            [cfd_comparator](<span class="type">const</span> Slice&amp; a, <span class="type">const</span> Slice&amp; b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> cfd_comparator-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(a),</span><br><span class="line">                                             <span class="built_in">ExtractUserKey</span>(b)) &lt; <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">  <span class="comment">// Remove duplicated entries from bounds</span></span><br><span class="line">  bounds.<span class="built_in">erase</span>(</span><br><span class="line">      std::<span class="built_in">unique</span>(bounds.<span class="built_in">begin</span>(), bounds.<span class="built_in">end</span>(),</span><br><span class="line">                  [cfd_comparator](<span class="type">const</span> Slice&amp; a, <span class="type">const</span> Slice&amp; b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cfd_comparator-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(a),</span><br><span class="line">                                                   <span class="built_in">ExtractUserKey</span>(b)) == <span class="number">0</span>;</span><br><span class="line">                  &#125;),</span><br><span class="line">      bounds.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Combine consecutive pairs of boundaries into ranges with an approximate</span></span><br><span class="line">  <span class="comment">// size of data covered by keys in that range</span></span><br><span class="line">  <span class="type">uint64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;RangeWithSize&gt; ranges;</span><br><span class="line">  <span class="comment">// Get input version from CompactionState since it&#x27;s already referenced</span></span><br><span class="line">  <span class="comment">// earlier in SetInputVersioCompaction::SetInputVersion and will not change</span></span><br><span class="line">  <span class="comment">// when db_mutex_ is released below</span></span><br><span class="line">  <span class="keyword">auto</span>* v = compact_-&gt;compaction-&gt;<span class="built_in">input_version</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = bounds.<span class="built_in">begin</span>();;) &#123;</span><br><span class="line">    <span class="type">const</span> Slice a = *it;</span><br><span class="line">    ++it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it == bounds.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Slice b = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApproximateSize could potentially create table reader iterator to seek</span></span><br><span class="line">    <span class="comment">// to the index block and may incur I/O cost in the process. Unlock db</span></span><br><span class="line">    <span class="comment">// mutex to reduce contention</span></span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="type">uint64_t</span> size = versions_-&gt;<span class="built_in">ApproximateSize</span>(<span class="built_in">SizeApproximationOptions</span>(), v, a,</span><br><span class="line">                                               b, start_lvl, out_lvl + <span class="number">1</span>,</span><br><span class="line">                                               TableReaderCaller::kCompaction);</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">    ranges.<span class="built_in">emplace_back</span>(a, b, size);</span><br><span class="line">    sum += size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Group the ranges into subcompactions</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> min_file_fill_percent = <span class="number">4.0</span> / <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> base_level = v-&gt;<span class="built_in">storage_info</span>()-&gt;<span class="built_in">base_level</span>();</span><br><span class="line">  <span class="type">uint64_t</span> max_output_files = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(std::<span class="built_in">ceil</span>(</span><br><span class="line">      sum / min_file_fill_percent /</span><br><span class="line">      <span class="built_in">MaxFileSizeForLevel</span>(</span><br><span class="line">          *(c-&gt;<span class="built_in">mutable_cf_options</span>()), out_lvl,</span><br><span class="line">          c-&gt;<span class="built_in">immutable_options</span>()-&gt;compaction_style, base_level,</span><br><span class="line">          c-&gt;<span class="built_in">immutable_options</span>()-&gt;level_compaction_dynamic_level_bytes)));</span><br><span class="line">  <span class="type">uint64_t</span> subcompactions =</span><br><span class="line">      std::<span class="built_in">min</span>(&#123;<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(ranges.<span class="built_in">size</span>()),</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(c-&gt;<span class="built_in">max_subcompactions</span>()),</span><br><span class="line">                max_output_files&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subcompactions &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">double</span> mean = sum * <span class="number">1.0</span> / subcompactions;</span><br><span class="line">    <span class="comment">// Greedily add ranges to the subcompaction until the sum of the ranges&#x27;</span></span><br><span class="line">    <span class="comment">// sizes becomes &gt;= the expected mean size of a subcompaction</span></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      sum += ranges[i].size;</span><br><span class="line">      <span class="keyword">if</span> (subcompactions == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s only one left to schedule then it goes to the end so no</span></span><br><span class="line">        <span class="comment">// need to put an end boundary</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &gt;= mean) &#123;</span><br><span class="line">        boundaries_.<span class="built_in">emplace_back</span>(<span class="built_in">ExtractUserKey</span>(ranges[i].range.limit));</span><br><span class="line">        sizes_.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">        subcompactions--;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sizes_.<span class="built_in">emplace_back</span>(sum + ranges.<span class="built_in">back</span>().size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Only one range so its size is the total sum of sizes computed above</span></span><br><span class="line">    sizes_.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历所有的需要compact的level,然后取得每一个level的边界(最大key和最小key)加入到bounds数组之中。</li>
<li>然后对获取到的bounds进行排序去重。</li>
<li>计算理想情况下所需要的subcompactions的个数以及输出文件的个数。</li>
<li>最后更新<code>boundaries_</code>，这里会根据文件的大小，通过平均的size,把所有的range分为几份，最终这些都会保存在<code>boundaries_</code>中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Run</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CompactionJob::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_COMPACTION_RUN)</span></span>;</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;CompactionJob::Run():Start&quot;</span>);</span><br><span class="line">  log_buffer_-&gt;<span class="built_in">FlushBufferToLog</span>();</span><br><span class="line">  <span class="built_in">LogCompaction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> num_threads = compact_-&gt;sub_compact_states.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">assert</span>(num_threads &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> start_micros = db_options_.clock-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Launch a thread for each of subcompactions 1...num_threads-1</span></span><br><span class="line">  std::vector&lt;port::Thread&gt; thread_pool;</span><br><span class="line">  thread_pool.<span class="built_in">reserve</span>(num_threads - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; compact_-&gt;sub_compact_states.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    thread_pool.<span class="built_in">emplace_back</span>(&amp;CompactionJob::ProcessKeyValueCompaction, <span class="keyword">this</span>,</span><br><span class="line">                             &amp;compact_-&gt;sub_compact_states[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Always schedule the first subcompaction (whether or not there are also</span></span><br><span class="line">  <span class="comment">// others) in the current thread to be efficient with resources</span></span><br><span class="line">  <span class="built_in">ProcessKeyValueCompaction</span>(&amp;compact_-&gt;sub_compact_states[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for all other threads (if there are any) to finish execution</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : thread_pool) &#123;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compaction_stats_.micros = db_options_.clock-&gt;<span class="built_in">NowMicros</span>() - start_micros;</span><br><span class="line">  compaction_stats_.cpu_micros = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; compact_-&gt;sub_compact_states.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    compaction_stats_.cpu_micros +=</span><br><span class="line">        compact_-&gt;sub_compact_states[i].compaction_job_stats.cpu_micros;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RecordTimeToHistogram</span>(stats_, COMPACTION_TIME, compaction_stats_.micros);</span><br><span class="line">  <span class="built_in">RecordTimeToHistogram</span>(stats_, COMPACTION_CPU_TIME,</span><br><span class="line">                        compaction_stats_.cpu_micros);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;CompactionJob::Run:BeforeVerify&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if any thread encountered an error during execution</span></span><br><span class="line">  Status status;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line">  <span class="type">bool</span> wrote_new_blob_files = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      status = state.status;</span><br><span class="line">      io_s = state.io_status;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.blob_file_additions.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      wrote_new_blob_files = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (io_status_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    io_status_ = io_s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> IODebugContext* dbg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_directory_) &#123;</span><br><span class="line">      io_s = output_directory_-&gt;<span class="built_in">Fsync</span>(<span class="built_in">IOOptions</span>(), dbg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>() &amp;&amp; wrote_new_blob_files &amp;&amp; blob_output_directory_ &amp;&amp;</span><br><span class="line">        blob_output_directory_ != output_directory_) &#123;</span><br><span class="line">      io_s = blob_output_directory_-&gt;<span class="built_in">Fsync</span>(<span class="built_in">IOOptions</span>(), dbg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (io_status_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    io_status_ = io_s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = io_s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    thread_pool.<span class="built_in">clear</span>();</span><br><span class="line">    std::vector&lt;<span class="type">const</span> CompactionJob::SubcompactionState::Output*&gt; files_output;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : state.outputs) &#123;</span><br><span class="line">        files_output.<span class="built_in">emplace_back</span>(&amp;output);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ColumnFamilyData* cfd = compact_-&gt;compaction-&gt;<span class="built_in">column_family_data</span>();</span><br><span class="line">    <span class="keyword">auto</span> prefix_extractor =</span><br><span class="line">        compact_-&gt;compaction-&gt;<span class="built_in">mutable_cf_options</span>()-&gt;prefix_extractor.<span class="built_in">get</span>();</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">size_t</span>&gt; <span class="title">next_file_idx</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> verify_table = [&amp;](Status&amp; output_status) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> file_idx = next_file_idx.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (file_idx &gt;= files_output.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Verify that the table is usable</span></span><br><span class="line">        <span class="comment">// We set for_compaction to false and don&#x27;t OptimizeForCompactionTableRead</span></span><br><span class="line">        <span class="comment">// here because this is a special case after we finish the table building</span></span><br><span class="line">        <span class="comment">// No matter whether use_direct_io_for_flush_and_compaction is true,</span></span><br><span class="line">        <span class="comment">// we will regard this verification as user reads since the goal is</span></span><br><span class="line">        <span class="comment">// to cache it here for further user reads</span></span><br><span class="line">        ReadOptions read_options;</span><br><span class="line">        InternalIterator* iter = cfd-&gt;<span class="built_in">table_cache</span>()-&gt;<span class="built_in">NewIterator</span>(</span><br><span class="line">            read_options, file_options_, cfd-&gt;<span class="built_in">internal_comparator</span>(),</span><br><span class="line">            files_output[file_idx]-&gt;meta, <span class="comment">/*range_del_agg=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            prefix_extractor,</span><br><span class="line">            <span class="comment">/*table_reader_ptr=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            cfd-&gt;<span class="built_in">internal_stats</span>()-&gt;<span class="built_in">GetFileReadHist</span>(</span><br><span class="line">                compact_-&gt;compaction-&gt;<span class="built_in">output_level</span>()),</span><br><span class="line">            TableReaderCaller::kCompactionRefill, <span class="comment">/*arena=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            <span class="comment">/*skip_filters=*/</span><span class="literal">false</span>, compact_-&gt;compaction-&gt;<span class="built_in">output_level</span>(),</span><br><span class="line">            <span class="built_in">MaxFileSizeForL0MetaPin</span>(</span><br><span class="line">                *compact_-&gt;compaction-&gt;<span class="built_in">mutable_cf_options</span>()),</span><br><span class="line">            <span class="comment">/*smallest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            <span class="comment">/*largest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            <span class="comment">/*allow_unprepared_value=*/</span><span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">auto</span> s = iter-&gt;<span class="built_in">status</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; paranoid_file_checks_) &#123;</span><br><span class="line">          <span class="function">OutputValidator <span class="title">validator</span><span class="params">(cfd-&gt;internal_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="comment">/*_enable_order_check=*/</span><span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="comment">/*_enable_hash=*/</span><span class="literal">true</span>)</span></span>;</span><br><span class="line">          <span class="keyword">for</span> (iter-&gt;<span class="built_in">SeekToFirst</span>(); iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">            s = validator.<span class="built_in">Add</span>(iter-&gt;<span class="built_in">key</span>(), iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            s = iter-&gt;<span class="built_in">status</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp;</span><br><span class="line">              !validator.<span class="built_in">CompareValidator</span>(files_output[file_idx]-&gt;validator)) &#123;</span><br><span class="line">            s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Paranoid checksums do not match&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> iter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          output_status = s;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; compact_-&gt;sub_compact_states.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      thread_pool.<span class="built_in">emplace_back</span>(verify_table,</span><br><span class="line">                               std::<span class="built_in">ref</span>(compact_-&gt;sub_compact_states[i].status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">verify_table</span>(compact_-&gt;sub_compact_states[<span class="number">0</span>].status);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : thread_pool) &#123;</span><br><span class="line">      thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!state.status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        status = state.status;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TablePropertiesCollection tp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : compact_-&gt;sub_compact_states) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : state.outputs) &#123;</span><br><span class="line">      <span class="keyword">auto</span> fn =</span><br><span class="line">          <span class="built_in">TableFileName</span>(state.compaction-&gt;<span class="built_in">immutable_options</span>()-&gt;cf_paths,</span><br><span class="line">                        output.meta.fd.<span class="built_in">GetNumber</span>(), output.meta.fd.<span class="built_in">GetPathId</span>());</span><br><span class="line">      tp[fn] = output.table_properties;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  compact_-&gt;compaction-&gt;<span class="built_in">SetOutputTableProperties</span>(std::<span class="built_in">move</span>(tp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish up all book-keeping to unify the subcompaction results</span></span><br><span class="line">  <span class="built_in">AggregateStatistics</span>();</span><br><span class="line">  <span class="built_in">UpdateCompactionStats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RecordCompactionIOStats</span>();</span><br><span class="line">  <span class="built_in">LogFlush</span>(db_options_.info_log);</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;CompactionJob::Run():End&quot;</span>);</span><br><span class="line"></span><br><span class="line">  compact_-&gt;status = status;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历所有的sub_compact,然后启动线程来进行对应的compact工作，最后等到所有的线程完成，然后退出。</li>
<li>通过<code>ProcessKeyValueCompaction</code>拿到的sub_compact_states进行真正的compaction处理实际的key-value数据。</li>
</ul>
</li>
</ul>
<h2 id="process-keys"><a class="markdownIt-Anchor" href="#process-keys"></a> Process keys</h2>
<h3 id="构造能够访问所有key的迭代器"><a class="markdownIt-Anchor" href="#构造能够访问所有key的迭代器"></a> 构造能够访问所有key的迭代器</h3>
<p>首先进入到<code>ProcessKeyValueCompaction</code>函数中，通过之前步骤中填充的sub_compact数据取出对应的key-value数据，构造一个InternalIterator。这一部分主要做key之间的排序以及inernal key的merge操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;InternalIterator&gt; <span class="title">raw_input</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    versions_-&gt;MakeInputIterator(read_options, sub_compact-&gt;compaction,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 &amp;range_del_agg, file_options_for_read_))</span></span>;</span><br><span class="line">InternalIterator* input = raw_input.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>构造的过程是通过函数<code>MakeInputIterator</code>进行的，我们进入到该函数，这个函数构造迭代器的逻辑同样区分level-0和level-其他。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InternalIterator* <span class="title">VersionSet::MakeInputIterator</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ReadOptions&amp; read_options, <span class="type">const</span> Compaction* c,</span></span></span><br><span class="line"><span class="params"><span class="function">    RangeDelAggregator* range_del_agg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FileOptions&amp; file_options_compactions)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> cfd = c-&gt;<span class="built_in">column_family_data</span>();</span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> space = (c-&gt;<span class="built_in">level</span>() == <span class="number">0</span> ? c-&gt;<span class="built_in">input_levels</span>(<span class="number">0</span>)-&gt;num_files +</span><br><span class="line">                                              c-&gt;<span class="built_in">num_input_levels</span>() - <span class="number">1</span></span><br><span class="line">                                        : c-&gt;<span class="built_in">num_input_levels</span>());</span><br><span class="line">  InternalIterator** list = <span class="keyword">new</span> InternalIterator* [space];</span><br><span class="line">  <span class="type">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> which = <span class="number">0</span>; which &lt; c-&gt;<span class="built_in">num_input_levels</span>(); which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;<span class="built_in">input_levels</span>(which)-&gt;num_files != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;<span class="built_in">level</span>(which) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> LevelFilesBrief* flevel = c-&gt;<span class="built_in">input_levels</span>(which);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; flevel-&gt;num_files; i++) &#123;</span><br><span class="line">          list[num++] = cfd-&gt;<span class="built_in">table_cache</span>()-&gt;<span class="built_in">NewIterator</span>(</span><br><span class="line">              read_options, file_options_compactions,</span><br><span class="line">              cfd-&gt;<span class="built_in">internal_comparator</span>(), *flevel-&gt;files[i].file_metadata,</span><br><span class="line">              range_del_agg, c-&gt;<span class="built_in">mutable_cf_options</span>()-&gt;prefix_extractor.<span class="built_in">get</span>(),</span><br><span class="line">              <span class="comment">/*table_reader_ptr=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*file_read_hist=*/</span><span class="literal">nullptr</span>, TableReaderCaller::kCompaction,</span><br><span class="line">              <span class="comment">/*arena=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*skip_filters=*/</span><span class="literal">false</span>,</span><br><span class="line">              <span class="comment">/*level=*/</span><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c-&gt;<span class="built_in">level</span>(which)),</span><br><span class="line">              <span class="built_in">MaxFileSizeForL0MetaPin</span>(*c-&gt;<span class="built_in">mutable_cf_options</span>()),</span><br><span class="line">              <span class="comment">/*smallest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*largest_compaction_key=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">              <span class="comment">/*allow_unprepared_value=*/</span><span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        list[num++] = <span class="keyword">new</span> <span class="built_in">LevelIterator</span>(</span><br><span class="line">            cfd-&gt;<span class="built_in">table_cache</span>(), read_options, file_options_compactions,</span><br><span class="line">            cfd-&gt;<span class="built_in">internal_comparator</span>(), c-&gt;<span class="built_in">input_levels</span>(which),</span><br><span class="line">            c-&gt;<span class="built_in">mutable_cf_options</span>()-&gt;prefix_extractor.<span class="built_in">get</span>(),</span><br><span class="line">            <span class="comment">/*should_sample=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*no per level latency histogram=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">            TableReaderCaller::kCompaction, <span class="comment">/*skip_filters=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*level=*/</span><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c-&gt;<span class="built_in">level</span>(which)), range_del_agg,</span><br><span class="line">            c-&gt;<span class="built_in">boundaries</span>(which));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(num &lt;= space);</span><br><span class="line">  InternalIterator* result =</span><br><span class="line">      <span class="built_in">NewMergingIterator</span>(&amp;c-&gt;<span class="built_in">column_family_data</span>()-&gt;<span class="built_in">internal_comparator</span>(), list,</span><br><span class="line">                         <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">  <span class="keyword">delete</span>[] list;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>首先获取当前sub_compact所属的cfd。</p>
</li>
<li>
<p>针对level-0,为其中的每一个sst文件构建一个table_cache迭代器，放入list中。</p>
</li>
<li>
<p>针对其他非level-0的层，每一层直接创建一个级联的迭代器并放入list中。也就是这个迭代器从它的start就能够顺序访问到该层最后一个sst文件的最后一个key。</p>
</li>
<li>
<p>将所有层的迭代器添加到一个迭代器数组list中，通过<code>NewMergingIterator</code>迭代器维护一个底层的排序堆结构，完成所有层之间的key-value的排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InternalIterator* <span class="title">NewMergingIterator</span><span class="params">(<span class="type">const</span> InternalKeyComparator* cmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     InternalIterator** list, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     Arena* arena, <span class="type">bool</span> prefix_seek_mode)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewEmptyInternalIterator</span>&lt;Slice&gt;(arena);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arena == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MergingIterator</span>(cmp, list, n, <span class="literal">false</span>, prefix_seek_mode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> mem = arena-&gt;<span class="built_in">AllocateAligned</span>(<span class="built_in">sizeof</span>(MergingIterator));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">new</span> (mem) <span class="built_in">MergingIterator</span>(cmp, list, n, <span class="literal">true</span>, prefix_seek_mode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果list是空的，则直接返回空。</p>
</li>
<li>
<p>如果只有一个，那么认为这个迭代器本身就是有序的，不需要构建一个堆排序的迭代器（level-0的sst内部是有序的，之前创建的时候是为level-0每一个sst创建一个list元素；非level-0的整层都是有序的）。</p>
</li>
<li>
<p>如果有多个，那么直接通过<code>MergingIterator</code>来创建堆排序的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MergingIterator</span>(<span class="type">const</span> InternalKeyComparator* comparator,</span><br><span class="line">                  InternalIterator** children, <span class="type">int</span> n, <span class="type">bool</span> is_arena_mode,</span><br><span class="line">                  <span class="type">bool</span> prefix_seek_mode)</span><br><span class="line">      : <span class="built_in">is_arena_mode_</span>(is_arena_mode),</span><br><span class="line">        <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">current_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">        <span class="built_in">direction_</span>(kForward),</span><br><span class="line">        <span class="built_in">minHeap_</span>(comparator_),</span><br><span class="line">        <span class="built_in">prefix_seek_mode_</span>(prefix_seek_mode),</span><br><span class="line">        <span class="built_in">pinned_iters_mgr_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    children_.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Set</span>(children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; child : children_) &#123;</span><br><span class="line">      <span class="built_in">AddToMinHeapOrCheckStatus</span>(&amp;child);</span><br><span class="line">    &#125;</span><br><span class="line">    current_ = <span class="built_in">CurrentForward</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过将传入的list也就是函数中的children中的所有元素添加到一个vector中，再遍历其中的每一个key-value，通过函数 	<code>AddToMinHeapOrCheckStatus</code>构造底层结构堆，堆中的元素顺序是由用户参数<code>option.comparator</code>指定，默认是BytewiseComparator支持的lexicographical order，也就是字典顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergingIterator::AddToMinHeapOrCheckStatus</span><span class="params">(IteratorWrapper* child)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(child-&gt;<span class="built_in">status</span>().<span class="built_in">ok</span>());</span><br><span class="line">    minHeap_.<span class="built_in">push</span>(child);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">considerStatus</span>(child-&gt;<span class="built_in">status</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="通过seektofirst和next指针处理元素"><a class="markdownIt-Anchor" href="#通过seektofirst和next指针处理元素"></a> 通过SeekToFirst和Next指针处理元素</h3>
<p>回到<code>ProcessKeyValueCompaction</code>函数,使用构造好的internalIterator再构造一个包含所有状态的CompactionIterator，直接初始化就可以，构造完成需要将CompactionIterator的内部指针放在整个迭代器最开始的部位，通过Next指针来获取下一个key-value，同时还需要需要在每次迭代器元素内部移动的时候除了调整底层堆中的字典序结构之外，还兼顾处理各个不同type的key数据，将kValueType，kTypeDeletion，kTypeSingleDeletion，kValueDeleteRange,kTypeMerge 等不同的key type处理完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c_iter-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">while</span> (status.<span class="built_in">ok</span>() &amp;&amp; !cfd-&gt;<span class="built_in">IsDropped</span>() &amp;&amp; c_iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">  <span class="comment">// Invariant: c_iter.status() is guaranteed to be OK if c_iter-&gt;Valid()</span></span><br><span class="line">  <span class="comment">// returns true.</span></span><br><span class="line">  <span class="type">const</span> Slice&amp; key = c_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">  <span class="type">const</span> Slice&amp; value = c_iter-&gt;<span class="built_in">value</span>();</span><br><span class="line">  ......</span><br><span class="line">  c_iter-&gt;<span class="built_in">Next</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="write-keys"><a class="markdownIt-Anchor" href="#write-keys"></a> Write keys</h2>
<p>这一步也在<code>ProcessKeyValueCompaction</code>函数中，将key-value写入SST文件中。</p>
<ul>
<li>
<p>确认key 的valueType类型，如果是data_block或者index_block类型，则放入builder状态机中</p>
</li>
<li>
<p>优先创建filter_buiilder和index_builder，index builer创建成 分层格式(两层index leve, 第一层多个restart点，用来索引具体的datablock；第二层索引第一层的index block)，方便加载到内存进行二分查找，节约内存消耗，加速查找；其次再写data_block_builder</p>
</li>
<li>
<p>如果key的 valueType类型是 range_deletion，则加入到range_delete_block_builder之中</p>
</li>
<li>
<p>先将data_block builder 利用绑定的输出的文件的writer写入底层文件</p>
</li>
<li>
<p>将filter_block / index_builder / compress_builder/range_del_builder/properties_builder 按照对应的格式加入到 meta_data_builder之中，利用绑定ouput 文件的 writer写入底层存储</p>
</li>
<li>
<p>利用meta_data_handle 和 index_handle 封装footer,写入底层存储</p>
</li>
</ul>
<h3 id="将builder与输出文件的writer绑定"><a class="markdownIt-Anchor" href="#将builder与输出文件的writer绑定"></a> 将builder与输出文件的writer绑定</h3>
<p>默认的blockbase table SST文件有很多不同的block，除了data block之外，其他的block都是需要先写入到一个临时的数据结构builder，然后由builder通过其绑定的output文件的writer写入到底层磁盘形成磁盘的sst文件结构。</p>
<p>这里的逻辑就是将builder与output文件的writer进行绑定，创建好table builder。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open output file if necessary</span></span><br><span class="line"><span class="keyword">if</span> (sub_compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = <span class="built_in">OpenCompactionOutputFile</span>(sub_compact);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过table_builder的状态机添加block数据"><a class="markdownIt-Anchor" href="#通过table_builder的状态机添加block数据"></a> 通过table_builder的状态机添加block数据</h3>
<p>然后调用<code>builder-&gt;Add</code>函数构造对应的builder结构，添加的过程主要是通过拥有三个状态的状态机完成不同block的builder创建，状态机是由构造tablebuilder的时候创建的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status = sub_compact-&gt;<span class="built_in">AddToBuilder</span>(key, value);</span><br><span class="line"><span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">AddToBuilder</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> curr = <span class="built_in">current_output</span>();</span><br><span class="line">    <span class="built_in">assert</span>(builder != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">assert</span>(curr != <span class="literal">nullptr</span>);</span><br><span class="line">    Status s = curr-&gt;validator.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  ValueType value_type = <span class="built_in">ExtractValueType</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsValueType</span>(value_type)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;props.num_entries &gt; r-&gt;props.num_range_deletions) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(r-&gt;internal_comparator.<span class="built_in">Compare</span>(key, <span class="built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !NDEBUG</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;<span class="built_in">Update</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      <span class="built_in">Flush</span>();</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">        <span class="type">bool</span> exceeds_buffer_limit =</span><br><span class="line">            (r-&gt;buffer_limit != <span class="number">0</span> &amp;&amp; r-&gt;data_begin_offset &gt; r-&gt;buffer_limit);</span><br><span class="line">        <span class="type">bool</span> is_cache_full = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase cache reservation for the last buffered data block</span></span><br><span class="line">        <span class="comment">// only if the block is not going to be unbuffered immediately</span></span><br><span class="line">        <span class="comment">// and there exists a cache reservation manager</span></span><br><span class="line">        <span class="keyword">if</span> (!exceeds_buffer_limit &amp;&amp; r-&gt;cache_rev_mng != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          Status s = r-&gt;cache_rev_mng-&gt;<span class="built_in">UpdateCacheReservation</span>&lt;</span><br><span class="line">              CacheEntryRole::kCompressionDictionaryBuildingBuffer&gt;(</span><br><span class="line">              r-&gt;data_begin_offset);</span><br><span class="line">          is_cache_full = s.<span class="built_in">IsIncomplete</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exceeds_buffer_limit || is_cache_full) &#123;</span><br><span class="line">          <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add item to index block.</span></span><br><span class="line">      <span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line">      <span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line">      <span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line">      <span class="comment">// between the keys &quot;the quick brown fox&quot; and &quot;the who&quot;.  We can use</span></span><br><span class="line">      <span class="comment">// &quot;the r&quot; as the key for the index block entry since it is &gt;= all</span></span><br><span class="line">      <span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line">      <span class="comment">// blocks.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: PartitionedFilterBlockBuilder requires key being added to filter</span></span><br><span class="line">    <span class="comment">// builder after being added to index builder.</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">PushBack</span>(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">      <span class="comment">// Buffered keys will be replayed from data_block_buffers during</span></span><br><span class="line">      <span class="comment">// `Finish()` once compression dictionary has been finalized.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO offset passed in is not accurate for parallel compression case</span></span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;range_del_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="comment">// TODO offset passed in is not accurate for parallel compression case</span></span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r-&gt;props.num_entries++;</span><br><span class="line">  r-&gt;props.raw_key_size += key.<span class="built_in">size</span>();</span><br><span class="line">  r-&gt;props.raw_value_size += value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (value_type == kTypeDeletion || value_type == kTypeSingleDeletion) &#123;</span><br><span class="line">    r-&gt;props.num_deletions++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;props.num_deletions++;</span><br><span class="line">    r-&gt;props.num_range_deletions++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeMerge) &#123;</span><br><span class="line">    r-&gt;props.num_merge_operands++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>kBuffered</strong>为状态机的初始状态。处于这个状态的时候，内存有较多缓存的未压缩的datablock。在该状态的过程中，通过 EnterUnbuffered 函数构造compression block，依此构建对应的index block和filterblock。最终将状态置为下一个状态的：kUnbuffered。</li>
<li><strong>kUnbuffered</strong>这个状态时，compressing block已经通过之前的buffer中的data初步构造完成，且接下来将在这个状态通过 Finish 完成各个block的写入 或者通过 Abandon 丢弃当前的写入。</li>
<li><strong>kClosed</strong>这个状态之前已经完成了table builder的finish或者abandon，那么接下来将析构当前的table builder。</li>
</ul>
<p>对于第一个状态，进入下面的逻辑。如果data block能够满足flush的条件，则直接flush datablock的数据到当前bulider对应的datablock存储结构中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;<span class="built_in">Update</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      <span class="built_in">Flush</span>();</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">        <span class="type">bool</span> exceeds_buffer_limit =</span><br><span class="line">            (r-&gt;buffer_limit != <span class="number">0</span> &amp;&amp; r-&gt;data_begin_offset &gt; r-&gt;buffer_limit);</span><br><span class="line">        <span class="type">bool</span> is_cache_full = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase cache reservation for the last buffered data block</span></span><br><span class="line">        <span class="comment">// only if the block is not going to be unbuffered immediately</span></span><br><span class="line">        <span class="comment">// and there exists a cache reservation manager</span></span><br><span class="line">        <span class="keyword">if</span> (!exceeds_buffer_limit &amp;&amp; r-&gt;cache_rev_mng != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          Status s = r-&gt;cache_rev_mng-&gt;<span class="built_in">UpdateCacheReservation</span>&lt;</span><br><span class="line">              CacheEntryRole::kCompressionDictionaryBuildingBuffer&gt;(</span><br><span class="line">              r-&gt;data_begin_offset);</span><br><span class="line">          is_cache_full = s.<span class="built_in">IsIncomplete</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exceeds_buffer_limit || is_cache_full) &#123;</span><br><span class="line">          <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add item to index block.</span></span><br><span class="line">      <span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line">      <span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line">      <span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line">      <span class="comment">// between the keys &quot;the quick brown fox&quot; and &quot;the who&quot;.  We can use</span></span><br><span class="line">      <span class="comment">// &quot;the r&quot; as the key for the index block entry since it is &gt;= all</span></span><br><span class="line">      <span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line">      <span class="comment">// blocks.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>EnterUnbuffered</code>函数主要逻辑是构造compression block，如果我们开启了compression的选项则会构造。</p>
<p>同时依据之前flush添加到datablock中的数据来构造index block和filter block，用来索引datablock的数据。选择在这里构造的话主要还是因为flush的时候表示一个完整的datablock已经写入完成，这里需要通过一个完整的datablock数据才有必要构造一条indexblock的数据。</p>
<p>其中data_block_and_keys_buffers数组存放的是未经过压缩的datablock数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; <span class="built_in">ok</span>() &amp;&amp; i &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter = <span class="built_in">get_iterator_for_block</span>(i);</span><br><span class="line">      <span class="built_in">assert</span>(iter != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      next_block_iter = <span class="built_in">get_iterator_for_block</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">      Slice first_key_in_next_block;</span><br><span class="line">      <span class="type">const</span> Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first_key_in_next_block_ptr = r-&gt;first_key_in_next_block;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      std::vector&lt;std::string&gt; keys;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        keys.<span class="built_in">emplace_back</span>(iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">          r-&gt;compression_type, first_key_in_next_block_ptr, &amp;data_block, &amp;keys);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">      r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        Slice key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(<span class="built_in">Slice</span>(data_block), &amp;r-&gt;pending_handle, BlockType::kData);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        Slice first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line"></span><br><span class="line">        Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line"></span><br><span class="line">        iter-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">        std::string last_key = iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>();</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;last_key, first_key_in_next_block_ptr,</span><br><span class="line">                                        r-&gt;pending_handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>EnterUnbuffered</code>函数中创建index block。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (table_options.index_type ==</span><br><span class="line">    BlockBasedTableOptions::kTwoLevelIndexSearch) &#123;</span><br><span class="line">  p_index_builder_ = PartitionedIndexBuilder::<span class="built_in">CreateIndexBuilder</span>(</span><br><span class="line">      &amp;internal_comparator, use_delta_encoding_for_index_values,</span><br><span class="line">      table_options);</span><br><span class="line">  index_builder.<span class="built_in">reset</span>(p_index_builder_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  index_builder.<span class="built_in">reset</span>(IndexBuilder::<span class="built_in">CreateIndexBuilder</span>(</span><br><span class="line">      table_options.index_type, &amp;internal_comparator,</span><br><span class="line">      &amp;<span class="keyword">this</span>-&gt;internal_prefix_transform, use_delta_encoding_for_index_values,</span><br><span class="line">      table_options));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到<code>ProcessKeyValueCompaction</code>中的while循环中，不断遍历迭代器中的key，将其添加到对应的datablock，并完善indeblock和filter block，以及compression block。</p>
<h3 id="通过构建的meta_index_builder和footer完成数据的固化"><a class="markdownIt-Anchor" href="#通过构建的meta_index_builder和footer完成数据的固化"></a> 通过构建的meta_index_builder和Footer完成数据的固化</h3>
<p>接下来将通过<code>FinishCompactionOutputFil</code>对之前添加的builder数据进行整合，处理一些delete range的block以及更新当前compaction的边界。<br />
这个函数调用是当之前累计的builder中block数据的大小达到可以写入的sst文件本身的大小max_output_file_size，会触发当前函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close output file if it is big enough. Two possibilities determine it&#x27;s</span></span><br><span class="line">    <span class="comment">// time to close it: (1) the current key should be this file&#x27;s last key, (2)</span></span><br><span class="line">    <span class="comment">// the next key should not be in this file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// TODO(aekmekji): determine if file should be closed earlier than this</span></span><br><span class="line">    <span class="comment">// during subcompactions (i.e. if output size, estimated by input size, is</span></span><br><span class="line">    <span class="comment">// going to be 1.2MB and max_output_file_size = 1MB, prefer to have 0.6MB</span></span><br><span class="line">    <span class="comment">// and 0.6MB instead of 1MB and 0.2MB)</span></span><br><span class="line">    <span class="type">bool</span> output_file_ended = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (sub_compact-&gt;compaction-&gt;<span class="built_in">output_level</span>() != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        sub_compact-&gt;current_output_file_size &gt;=</span><br><span class="line">            sub_compact-&gt;compaction-&gt;<span class="built_in">max_output_file_size</span>()) &#123;</span><br><span class="line">      <span class="comment">// (1) this key terminates the file. For historical reasons, the iterator</span></span><br><span class="line">      <span class="comment">// status before advancing will be given to FinishCompactionOutputFile().</span></span><br><span class="line">      output_file_ended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(</span><br><span class="line">        <span class="string">&quot;CompactionJob::Run():PausingManualCompaction:2&quot;</span>,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;std::atomic&lt;<span class="type">int</span>&gt;*&gt;(manual_compaction_paused_)));</span><br><span class="line">    <span class="keyword">if</span> (partitioner.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      last_key_for_partitioner.<span class="built_in">assign</span>(c_iter-&gt;<span class="built_in">user_key</span>().data_,</span><br><span class="line">                                      c_iter-&gt;<span class="built_in">user_key</span>().size_);</span><br><span class="line">    &#125;</span><br><span class="line">    c_iter-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="keyword">if</span> (c_iter-&gt;<span class="built_in">status</span>().<span class="built_in">IsManualCompactionPaused</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!output_file_ended &amp;&amp; c_iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (((partitioner.<span class="built_in">get</span>() &amp;&amp;</span><br><span class="line">            partitioner-&gt;<span class="built_in">ShouldPartition</span>(<span class="built_in">PartitionerRequest</span>(</span><br><span class="line">                last_key_for_partitioner, c_iter-&gt;<span class="built_in">user_key</span>(),</span><br><span class="line">                sub_compact-&gt;current_output_file_size)) == kRequired) ||</span><br><span class="line">           (sub_compact-&gt;compaction-&gt;<span class="built_in">output_level</span>() != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            sub_compact-&gt;<span class="built_in">ShouldStopBefore</span>(</span><br><span class="line">                c_iter-&gt;<span class="built_in">key</span>(), sub_compact-&gt;current_output_file_size))) &amp;&amp;</span><br><span class="line">          sub_compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// (2) this key belongs to the next file. For historical reasons, the</span></span><br><span class="line">        <span class="comment">// iterator status after advancing will be given to</span></span><br><span class="line">        <span class="comment">// FinishCompactionOutputFile().</span></span><br><span class="line">        output_file_ended = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (output_file_ended) &#123;</span><br><span class="line">      <span class="type">const</span> Slice* next_key = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (c_iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">        next_key = &amp;c_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      CompactionIterationStats range_del_out_stats;</span><br><span class="line">      status = <span class="built_in">FinishCompactionOutputFile</span>(input-&gt;<span class="built_in">status</span>(), sub_compact,</span><br><span class="line">                                          &amp;range_del_agg, &amp;range_del_out_stats,</span><br><span class="line">                                          next_key);</span><br><span class="line">      <span class="built_in">RecordDroppedKeys</span>(range_del_out_stats,</span><br><span class="line">                        &amp;sub_compact-&gt;compaction_job_stats);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>FinishCompactionOutputFile</code>函数内部最终调用s=sub_compact-&gt;builder-&gt;Finish()完成所有数据的固化写入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BlockBasedTableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="type">bool</span> empty_data_block = r-&gt;data_block.<span class="built_in">empty</span>();</span><br><span class="line">  r-&gt;first_key_in_next_block = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StopParallelCompression</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; br : r-&gt;pc_rep-&gt;block_rep_buf) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(br.status.<span class="built_in">ok</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !NDEBUG</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// To make sure properties block is able to keep the accurate size of index</span></span><br><span class="line">    <span class="comment">// block, we will finish writing all index entries first.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_data_block) &#123;</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(</span><br><span class="line">          &amp;r-&gt;last_key, <span class="literal">nullptr</span> <span class="comment">/* no next data block */</span>, r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write meta blocks, metaindex block and footer in the following order.</span></span><br><span class="line">  <span class="comment">//    1. [meta block: filter]</span></span><br><span class="line">  <span class="comment">//    2. [meta block: index]</span></span><br><span class="line">  <span class="comment">//    3. [meta block: compression dictionary]</span></span><br><span class="line">  <span class="comment">//    4. [meta block: range deletion tombstone]</span></span><br><span class="line">  <span class="comment">//    5. [meta block: properties]</span></span><br><span class="line">  <span class="comment">//    6. [metaindex block]</span></span><br><span class="line">  <span class="comment">//    7. Footer</span></span><br><span class="line">  BlockHandle metaindex_block_handle, index_block_handle;</span><br><span class="line">  MetaIndexBuilder meta_index_builder;</span><br><span class="line">  <span class="built_in">WriteFilterBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteIndexBlock</span>(&amp;meta_index_builder, &amp;index_block_handle);</span><br><span class="line">  <span class="built_in">WriteCompressionDictBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteRangeDelBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WritePropertiesBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// flush the meta index block</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(meta_index_builder.<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                  &amp;metaindex_block_handle, BlockType::kMetaIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">WriteFooter</span>(metaindex_block_handle, index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;state = Rep::State::kClosed;</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(r-&gt;<span class="built_in">CopyIOStatus</span>());</span><br><span class="line">  Status ret_status = r-&gt;<span class="built_in">CopyStatus</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!ret_status.<span class="built_in">ok</span>() || <span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="keyword">return</span> ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="compaction参数设置"><a class="markdownIt-Anchor" href="#compaction参数设置"></a> Compaction参数设置</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>write_buffer_size</code></td>
<td>限定Memtable的大小</td>
<td>64MB</td>
</tr>
<tr>
<td><code>level0_file_num_compaction_trigger</code></td>
<td>限定Level 0层的文件数量</td>
<td>4</td>
</tr>
<tr>
<td><code>target_file_size_base</code></td>
<td>每一层单个目标文件的大小</td>
<td>64MB</td>
</tr>
<tr>
<td><code>target_file_size_multiplier</code></td>
<td>每一层单个目标文件的乘法因子</td>
<td>1</td>
</tr>
<tr>
<td><code>max_bytes_for_level_base</code></td>
<td>每一层所有文件的大小</td>
<td>256MB</td>
</tr>
<tr>
<td><code>max_bytes_for_level_multiplier</code></td>
<td>每一层所有文件的乘法因子</td>
<td>10</td>
</tr>
<tr>
<td><code>level_compaction_dynamic_level_bytes</code></td>
<td>是否将Compact的策略改为层级从下往上应用</td>
<td>False</td>
</tr>
<tr>
<td><code>num_levels</code></td>
<td>LSM的层级数量</td>
<td>7</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>参数<code>target_file_size_base</code>和<code>target_file_size_multiplier</code>用来限定Compact之后的每一层的单个文件大小。<code>target_file_size_base</code>是Level-1中每个文件的大小，Level N层可以用<code>target_file_size_base * target_file_size_multiplier ^ (L -1)</code> 计算。<code>target_file_size_base</code> 默认为64MB，<code>target_file_size_multiplier</code>默认为1。</p>
</li>
<li>
<p>参数<code>max_bytes_for_level_base</code>和<code>max_bytes_for_level_multiplier</code>用来限定每一层所有文件的限定大小。 <code>max_bytes_for_level_base</code>是Level-1层的所有文件的限定大小。Level N层的所有文件的限定大小可以用 <code>(max_bytes_for_level_base) * (max_bytes_for_level_multiplier ^ (L-1))</code>计算。<code>max_bytes_for_level_base</code>的默认为256MB，<code>max_bytes_for_level_multiplier</code>默认为10。</p>
</li>
<li>
<p>参数<code>level_compaction_dynamic_level_bytes</code>用来指示Compact的策略改为层级从下往上应用。<code>Target_Size(Ln-1) = Target_Size(Ln) / max_bytes_for_level_multiplier</code>来限定大小：假如 <code>max_bytes_for_level_base</code>是 1GB, <code>num_levels</code>设为6。最底层的实际容量是276GB, 所以L1-L6层的大小分别是 0, 0, 0.276GB, 2.76GB, 27.6GB and 276GB。</p>
</li>
<li>
<p>MutableDBOptions</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MutableDBOptions</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">kName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MutableDBOptions&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">MutableDBOptions</span>();</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutableDBOptions</span><span class="params">(<span class="type">const</span> MutableDBOptions&amp; options)</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutableDBOptions</span><span class="params">(<span class="type">const</span> DBOptions&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Dump</span><span class="params">(Logger* log)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> max_background_jobs;</span><br><span class="line">  <span class="type">int</span> base_background_compactions;</span><br><span class="line">  <span class="type">int</span> max_background_compactions;</span><br><span class="line">  <span class="type">uint32_t</span> max_subcompactions;</span><br><span class="line">  <span class="type">bool</span> avoid_flush_during_shutdown;</span><br><span class="line">  <span class="type">size_t</span> writable_file_max_buffer_size;</span><br><span class="line">  <span class="type">uint64_t</span> delayed_write_rate;</span><br><span class="line">  <span class="type">uint64_t</span> max_total_wal_size;</span><br><span class="line">  <span class="type">uint64_t</span> delete_obsolete_files_period_micros;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stats_dump_period_sec;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stats_persist_period_sec;</span><br><span class="line">  <span class="type">size_t</span> stats_history_buffer_size;</span><br><span class="line">  <span class="type">int</span> max_open_files;</span><br><span class="line">  <span class="type">uint64_t</span> bytes_per_sync;</span><br><span class="line">  <span class="type">uint64_t</span> wal_bytes_per_sync;</span><br><span class="line">  <span class="type">bool</span> strict_bytes_per_sync;</span><br><span class="line">  <span class="type">size_t</span> compaction_readahead_size;</span><br><span class="line">  <span class="type">int</span> max_background_flushes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>mutable_cf_options_</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MutableCFOptions</span><span class="params">(<span class="type">const</span> ColumnFamilyOptions&amp; options)</span></span></span><br><span class="line"><span class="function">      : write_buffer_size(options.write_buffer_size),</span></span><br><span class="line"><span class="function">        max_write_buffer_number(options.max_write_buffer_number),</span></span><br><span class="line"><span class="function">        arena_block_size(options.arena_block_size),</span></span><br><span class="line"><span class="function">        memtable_prefix_bloom_size_ratio(</span></span><br><span class="line"><span class="function">            options.memtable_prefix_bloom_size_ratio),</span></span><br><span class="line"><span class="function">        memtable_whole_key_filtering(options.memtable_whole_key_filtering),</span></span><br><span class="line"><span class="function">        memtable_huge_page_size(options.memtable_huge_page_size),</span></span><br><span class="line"><span class="function">        max_successive_merges(options.max_successive_merges),</span></span><br><span class="line"><span class="function">        inplace_update_num_locks(options.inplace_update_num_locks),</span></span><br><span class="line"><span class="function">        prefix_extractor(options.prefix_extractor),</span></span><br><span class="line"><span class="function">        disable_auto_compactions(options.disable_auto_compactions),</span></span><br><span class="line"><span class="function">        soft_pending_compaction_bytes_limit(</span></span><br><span class="line"><span class="function">            options.soft_pending_compaction_bytes_limit),</span></span><br><span class="line"><span class="function">        hard_pending_compaction_bytes_limit(</span></span><br><span class="line"><span class="function">            options.hard_pending_compaction_bytes_limit),</span></span><br><span class="line"><span class="function">        level0_file_num_compaction_trigger(</span></span><br><span class="line"><span class="function">            options.level0_file_num_compaction_trigger),</span></span><br><span class="line"><span class="function">        level0_slowdown_writes_trigger(options.level0_slowdown_writes_trigger),</span></span><br><span class="line"><span class="function">        level0_stop_writes_trigger(options.level0_stop_writes_trigger),</span></span><br><span class="line"><span class="function">        max_compaction_bytes(options.max_compaction_bytes),</span></span><br><span class="line"><span class="function">        target_file_size_base(options.target_file_size_base),</span></span><br><span class="line"><span class="function">        target_file_size_multiplier(options.target_file_size_multiplier),</span></span><br><span class="line"><span class="function">        max_bytes_for_level_base(options.max_bytes_for_level_base),</span></span><br><span class="line"><span class="function">        max_bytes_for_level_multiplier(options.max_bytes_for_level_multiplier),</span></span><br><span class="line"><span class="function">        ttl(options.ttl),</span></span><br><span class="line"><span class="function">        periodic_compaction_seconds(options.periodic_compaction_seconds),</span></span><br><span class="line"><span class="function">        max_bytes_for_level_multiplier_additional(</span></span><br><span class="line"><span class="function">            options.max_bytes_for_level_multiplier_additional),</span></span><br><span class="line"><span class="function">        compaction_options_fifo(options.compaction_options_fifo),</span></span><br><span class="line"><span class="function">        compaction_options_universal(options.compaction_options_universal),</span></span><br><span class="line"><span class="function">        enable_blob_files(options.enable_blob_files),</span></span><br><span class="line"><span class="function">        min_blob_size(options.min_blob_size),</span></span><br><span class="line"><span class="function">        blob_file_size(options.blob_file_size),</span></span><br><span class="line"><span class="function">        blob_compression_type(options.blob_compression_type),</span></span><br><span class="line"><span class="function">        enable_blob_garbage_collection(options.enable_blob_garbage_collection),</span></span><br><span class="line"><span class="function">        blob_garbage_collection_age_cutoff(</span></span><br><span class="line"><span class="function">            options.blob_garbage_collection_age_cutoff),</span></span><br><span class="line"><span class="function">        max_sequential_skip_in_iterations(</span></span><br><span class="line"><span class="function">            options.max_sequential_skip_in_iterations),</span></span><br><span class="line"><span class="function">        check_flush_compaction_key_order(</span></span><br><span class="line"><span class="function">            options.check_flush_compaction_key_order),</span></span><br><span class="line"><span class="function">        paranoid_file_checks(options.paranoid_file_checks),</span></span><br><span class="line"><span class="function">        report_bg_io_stats(options.report_bg_io_stats),</span></span><br><span class="line"><span class="function">        compression(options.compression),</span></span><br><span class="line"><span class="function">        bottommost_compression(options.bottommost_compression),</span></span><br><span class="line"><span class="function">        compression_opts(options.compression_opts),</span></span><br><span class="line"><span class="function">        bottommost_compression_opts(options.bottommost_compression_opts),</span></span><br><span class="line"><span class="function">        bottommost_temperature(options.bottommost_temperature),</span></span><br><span class="line"><span class="function">        sample_for_compression(</span></span><br><span class="line"><span class="function">            options.sample_for_compression) &#123;</span>  <span class="comment">// <span class="doctag">TODO:</span> is 0 fine here?</span></span><br><span class="line">    <span class="built_in">RefreshDerivedOptions</span>(options.num_levels, options.compaction_style);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="some-concepts"><a class="markdownIt-Anchor" href="#some-concepts"></a> Some Concepts</h2>
<ul>
<li><strong>Slice</strong> is a simple structure containing a pointer into some external storage and a size.</li>
<li><strong>parents</strong> &amp;&amp; <strong>grandparents</strong>: parent=level+1 grandparent==level+2</li>
<li><strong>column family</strong>(cfd)</li>
<li><strong>compaction filter</strong></li>
<li><strong>compression</strong></li>
<li><strong>sst file maneger</strong>(sfm)</li>
<li><strong>background</strong>(bg)</li>
</ul>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Compaction">RocksDB Compaction Wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Z_Stand/article/details/106959058">Rocksdb Compaction 源码详解（一）：SST文件详细格式源码解析</a></li>
<li><a target="_blank" rel="noopener" href="https://vigourtyy-zhg.blog.csdn.net/article/details/107592966?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.no_search_link?%7C">Rocksdb Compaction源码详解（二）：Compaction 完整实现过程 概览</a></li>
<li><a target="_blank" rel="noopener" href="http://rocksdb.org/blog/2015/07/23/dynamic-level.html">Dynamic Level Size for Level-Based Compaction</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_31951239/article/details/113019578">通过base level减少space amplification</a></li>
<li><a target="_blank" rel="noopener" href="https://www.leviathan.vip/2018/03/05/Rocksdb%E7%9A%84Compact/">RocksDB的Compact</a></li>
<li><a target="_blank" rel="noopener" href="http://rocksdb.org/blog/2016/01/29/compaction_pri.html">compaction_pri</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Compaction-Filter">compaction filter</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>RocksDB Compaction源码分析</p><p><a href="https://tongyiheng.top/2021/09/24/Embedded/rocksdb-compaction/">https://tongyiheng.top/2021/09/24/Embedded/rocksdb-compaction/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>TongYiheng</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-09-24</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-10-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i> </a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i> </a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i> </a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/RocksDB/">RocksDB, </a><a class="link-muted" rel="tag" href="/tags/cpp/">cpp, </a><a class="link-muted" rel="tag" href="/tags/compaction/">compaction </a></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=606d9ca4caff460011c58b12&amp;product=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/09/27/Tools/ffmpeg/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ffmpeg</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/07/Embedded/mysql-buffer-pool-design/"><span class="level-item">MySQL Buffer Pool Design</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "nUmwvAMIK3DjqBzyQlGQ429s-gzGzoHsz",
            appKey: "9jYGXFAbgktDDeSOnOKsDbyt",
            
            avatar: "robohash",
            avatarForce: true,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-96x96 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="TongYiheng"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TongYiheng</p><p class="is-size-6 is-block">Trust Your Trust</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>QingDao,China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">Posts</p><div><p class="title">28</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">Categories</p><div><p class="title">12</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">Tags</p><div><p class="title">28</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tongyiheng" target="_blank" rel="noopener"><i class="fab fa-github"></i>  Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/tongyiheng"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#prepare-keys"><span class="level-left"><span class="level-item">1</span><span class="level-item"> Prepare keys</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#触发条件"><span class="level-left"><span class="level-item">1.1</span><span class="level-item"> 触发条件</span></span></a></li><li><a class="level is-mobile" href="#sst文件的选择"><span class="level-left"><span class="level-item">1.2</span><span class="level-item"> SST文件的选择</span></span></a></li><li><a class="level is-mobile" href="#compaction每一层level大小的确定"><span class="level-left"><span class="level-item">1.3</span><span class="level-item"> compaction每一层level大小的确定</span></span></a></li><li><a class="level is-mobile" href="#挑选参与compaction的文件"><span class="level-left"><span class="level-item">1.4</span><span class="level-item"> 挑选参与compaction的文件</span></span></a></li><li><a class="level is-mobile" href="#compaction-job根据获取到数据分配compaction线程"><span class="level-left"><span class="level-item">1.5</span><span class="level-item"> Compaction job:根据获取到数据分配compaction线程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#process-keys"><span class="level-left"><span class="level-item">2</span><span class="level-item"> Process keys</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#构造能够访问所有key的迭代器"><span class="level-left"><span class="level-item">2.1</span><span class="level-item"> 构造能够访问所有key的迭代器</span></span></a></li><li><a class="level is-mobile" href="#通过seektofirst和next指针处理元素"><span class="level-left"><span class="level-item">2.2</span><span class="level-item"> 通过SeekToFirst和Next指针处理元素</span></span></a></li></ul></li><li><a class="level is-mobile" href="#write-keys"><span class="level-left"><span class="level-item">3</span><span class="level-item"> Write keys</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#将builder与输出文件的writer绑定"><span class="level-left"><span class="level-item">3.1</span><span class="level-item"> 将builder与输出文件的writer绑定</span></span></a></li><li><a class="level is-mobile" href="#通过table_builder的状态机添加block数据"><span class="level-left"><span class="level-item">3.2</span><span class="level-item"> 通过table_builder的状态机添加block数据</span></span></a></li><li><a class="level is-mobile" href="#通过构建的meta_index_builder和footer完成数据的固化"><span class="level-left"><span class="level-item">3.3</span><span class="level-item"> 通过构建的meta_index_builder和Footer完成数据的固化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#compaction参数设置"><span class="level-left"><span class="level-item">4</span><span class="level-item"> Compaction参数设置</span></span></a></li><li><a class="level is-mobile" href="#some-concepts"><span class="level-left"><span class="level-item">5</span><span class="level-item"> Some Concepts</span></span></a></li><li><a class="level is-mobile" href="#reference"><span class="level-left"><span class="level-item">6</span><span class="level-item"> Reference</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Avocado Pear" height="28"></a><p class="is-size-7"><span>&copy; 2022 TongYiheng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/TongYiheng/TongYiheng.github.io"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Email" href="mailto:yihengtong@outlook.com"><i class="fa fa-envelope"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>