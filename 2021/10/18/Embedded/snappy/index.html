<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Snappy Algorithm - TongYiheng&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TongYiheng&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TongYiheng&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="How to analyse the source codes of snappy ? In this blog, the pseudocode of compression and uncompression using snappy is given, which is aimed to help you understand snappy algorithm."><meta property="og:type" content="blog"><meta property="og:title" content="Snappy Algorithm"><meta property="og:url" content="https://tongyiheng.top/2021/10/18/Embedded/snappy/"><meta property="og:site_name" content="TongYiheng&#039;s Blog"><meta property="og:description" content="How to analyse the source codes of snappy ? In this blog, the pseudocode of compression and uncompression using snappy is given, which is aimed to help you understand snappy algorithm."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://tongyiheng.top/images/cover/snappy.jpg"><meta property="article:published_time" content="2021-10-18T14:18:42.000Z"><meta property="article:modified_time" content="2021-10-20T13:13:56.480Z"><meta property="article:author" content="TongYiheng"><meta property="article:tag" content="cpp"><meta property="article:tag" content="RocksDB"><meta property="article:tag" content="compression"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/cover/snappy.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tongyiheng.top/2021/10/18/Embedded/snappy/"},"headline":"Snappy Algorithm","image":["https://tongyiheng.top/images/cover/snappy.jpg"],"datePublished":"2021-10-18T14:18:42.000Z","dateModified":"2021-10-20T13:13:56.480Z","author":{"@type":"Person","name":"TongYiheng"},"publisher":{"@type":"Organization","name":"TongYiheng's Blog","logo":{"@type":"ImageObject","url":"https://tongyiheng.top/img/logo.svg"}},"description":"How to analyse the source codes of snappy ? In this blog, the pseudocode of compression and uncompression using snappy is given, which is aimed to help you understand snappy algorithm."}</script><link rel="canonical" href="https://tongyiheng.top/2021/10/18/Embedded/snappy/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="TongYiheng's Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="TongYiheng&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/gallery">Gallery</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/TongYiheng/TongYiheng.github.io"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Email" href="mailto:yihengtong@outlook.com"><i class="fa fa-envelope"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/cover/snappy.jpg" alt="Snappy Algorithm"></span></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Snappy Algorithm</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2021-10-18T14:18:42.000Z" title="2021-10-18T14:18:42.000Z">2021-10-18</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2021-10-20T13:13:56.480Z" title="2021-10-20T13:13:56.480Z">2021-10-20</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/Embedded/">Embedded</a><span> / </span><a class="link-muted" href="/categories/Embedded/KV-store/">KV store</a></span><span class="level-item"><i class="far fa-clock"></i> 35 minutes read (About 5269 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>How to analyse the source codes of snappy ? In this blog, the pseudocode of compression and uncompression using snappy is given, which is aimed to help you understand snappy algorithm.</p>
<span id="more"></span>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<p>Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression. For instance,      compared to the fastest mode of zlib, Snappy is an order of magnitude faster for most inputs, but the resulting compressed files are anywhere from 20% to 100% bigger. (For more information, see “Performance”, below.)</p>
<p>Snappy has the following properties:</p>
<ul>
<li>Fast: Compression speeds at 250 MB/sec and beyond, with no assembler code. See “Performance” below.</li>
<li>Stable: Over the last few years, Snappy has compressed and decompressed petabytes of data in Google’s production environment. The Snappy bitstream format is stable and will not change between versions.</li>
<li>Robust: The Snappy decompressor is designed not to crash in the face of corrupted or malicious input.</li>
<li>Free and open source software: Snappy is licensed under a BSD-type license. For more information, see the included COPYING file.</li>
</ul>
<p>Snappy has previously been called “Zippy” in some Google presentations and the like.</p>
<h2 id="snappy-in-rocksdb"><a class="markdownIt-Anchor" href="#snappy-in-rocksdb"></a> Snappy in RocksDB</h2>
<ul>
<li>
<p>How to link: <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/blob/main/build_tools/build_detect_platform">https://github.com/facebook/rocksdb/blob/main/build_tools/build_detect_platform</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! test $ROCKSDB_DISABLE_SNAPPY; then</span><br><span class="line">        # Test whether Snappy library is installed</span><br><span class="line">        <span class="meta"># http:<span class="comment">//code.google.com/p/snappy/</span></span></span><br><span class="line">        $CXX $PLATFORM_CXXFLAGS -x c++ - -o /dev/null <span class="number">2</span>&gt;/dev/null  &lt;&lt;EOF</span><br><span class="line">          <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;snappy.h&gt;</span></span></span><br><span class="line">          <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Where to use: <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/blob/main/util/compression.h">https://github.com/facebook/rocksdb/blob/main/util/compression.h</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Snappy_Compress</span><span class="params">(<span class="keyword">const</span> CompressionInfo&amp; <span class="comment">/*info*/</span>, <span class="keyword">const</span> <span class="keyword">char</span>* input,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">size_t</span> length, ::std::string* output)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SNAPPY</span></span><br><span class="line">  output-&gt;<span class="built_in">resize</span>(snappy::<span class="built_in">MaxCompressedLength</span>(length));</span><br><span class="line">  <span class="keyword">size_t</span> outlen;</span><br><span class="line">  snappy::<span class="built_in">RawCompress</span>(input, length, &amp;(*output)[<span class="number">0</span>], &amp;outlen);</span><br><span class="line">  output-&gt;<span class="built_in">resize</span>(outlen);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  (<span class="keyword">void</span>)input;</span><br><span class="line">  (<span class="keyword">void</span>)length;</span><br><span class="line">  (<span class="keyword">void</span>)output;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> CacheAllocationPtr <span class="title">Snappy_Uncompress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span>* input, <span class="keyword">size_t</span> length, <span class="keyword">size_t</span>* uncompressed_size,</span></span></span><br><span class="line"><span class="params"><span class="function">    MemoryAllocator* allocator = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SNAPPY</span></span><br><span class="line">  <span class="keyword">size_t</span> uncompressed_length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!snappy::<span class="built_in">GetUncompressedLength</span>(input, length, &amp;uncompressed_length)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CacheAllocationPtr output = <span class="built_in">AllocateBlock</span>(uncompressed_length, allocator);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!snappy::<span class="built_in">RawUncompress</span>(input, length, output.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *uncompressed_size = uncompressed_length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  (<span class="keyword">void</span>)input;</span><br><span class="line">  (<span class="keyword">void</span>)length;</span><br><span class="line">  (<span class="keyword">void</span>)uncompressed_size;</span><br><span class="line">  (<span class="keyword">void</span>)allocator;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RocksDB主要调用了两个接口<code>RawCompress</code>和<code>RawUncompress</code>。</p>
</li>
</ul>
<h2 id="snappy"><a class="markdownIt-Anchor" href="#snappy"></a> Snappy</h2>
<p>Source: <a target="_blank" rel="noopener" href="https://github.com/google/snappy/">https://github.com/google/snappy/</a></p>
<p>首先看一下Format，然后分别从RawCompress和RawUncompress入手分析Snappy的压缩和解压过程。</p>
<h3 id="format"><a class="markdownIt-Anchor" href="#format"></a> Format</h3>
<p><code>format_description.txt</code>说明了一些编码格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">Snappy compressed format description</span><br><span class="line">Last revised: 2011-10-05</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is not a formal specification, but should suffice to explain most</span><br><span class="line">relevant parts of how the Snappy format works. It is originally based on</span><br><span class="line">text by Zeev Tarantov.</span><br><span class="line"></span><br><span class="line">Snappy is a LZ77-type compressor with a fixed, byte-oriented encoding.</span><br><span class="line">There is no entropy encoder backend nor framing layer -- the latter is</span><br><span class="line">assumed to be handled by other parts of the system.</span><br><span class="line"></span><br><span class="line">This document only describes the format, not how the Snappy compressor nor</span><br><span class="line">decompressor actually works. The correctness of the decompressor should not</span><br><span class="line">depend on implementation details of the compressor, and vice versa.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Preamble</span><br><span class="line"></span><br><span class="line">The stream starts with the uncompressed length (up to a maximum of 2^32 - 1),</span><br><span class="line">stored as a little-endian varint. Varints consist of a series of bytes,</span><br><span class="line">where the lower 7 bits are data and the upper bit is set iff there are</span><br><span class="line">more bytes to be read. In other words, an uncompressed length of 64 would</span><br><span class="line">be stored as 0x40, and an uncompressed length of 2097150 (0x1FFFFE)</span><br><span class="line">would be stored as 0xFE 0xFF 0x7F.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. The compressed stream itself</span><br><span class="line"></span><br><span class="line">There are two types of elements in a Snappy stream: Literals and</span><br><span class="line">copies (backreferences). There is no restriction on the order of elements,</span><br><span class="line">except that the stream naturally cannot start with a copy. (Having</span><br><span class="line">two literals in a row is never optimal from a compression point of</span><br><span class="line">view, but nevertheless fully permitted.) Each element starts with a tag byte,</span><br><span class="line">and the lower two bits of this tag byte signal what type of element will</span><br><span class="line">follow:</span><br><span class="line"></span><br><span class="line">  00: Literal</span><br><span class="line">  01: Copy with 1-byte offset</span><br><span class="line">  10: Copy with 2-byte offset</span><br><span class="line">  11: Copy with 4-byte offset</span><br><span class="line"></span><br><span class="line">The interpretation of the upper six bits are element-dependent.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.1. Literals (00)</span><br><span class="line"></span><br><span class="line">Literals are uncompressed data stored directly in the byte stream.</span><br><span class="line">The literal length is stored differently depending on the length</span><br><span class="line">of the literal:</span><br><span class="line"></span><br><span class="line"> - For literals up to and including 60 bytes in length, the upper</span><br><span class="line">   six bits of the tag byte contain (len-1). The literal follows</span><br><span class="line">   immediately thereafter in the bytestream.</span><br><span class="line"> - For longer literals, the (len-1) value is stored after the tag byte,</span><br><span class="line">   little-endian. The upper six bits of the tag byte describe how</span><br><span class="line">   many bytes are used for the length; 60, 61, 62 or 63 for</span><br><span class="line">   1-4 bytes, respectively. The literal itself follows after the</span><br><span class="line">   length.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2. Copies</span><br><span class="line"></span><br><span class="line">Copies are references back into previous decompressed data, telling</span><br><span class="line">the decompressor to reuse data it has previously decoded.</span><br><span class="line">They encode two values: The _offset_, saying how many bytes back</span><br><span class="line">from the current position to read, and the _length_, how many bytes</span><br><span class="line">to copy. Offsets of zero can be encoded, but are not legal;</span><br><span class="line">similarly, it is possible to encode backreferences that would</span><br><span class="line">go past the end of the block (offset &gt; current decompressed position),</span><br><span class="line">which is also nonsensical and thus not allowed.</span><br><span class="line"></span><br><span class="line">As in most LZ77-based compressors, the length can be larger than the offset,</span><br><span class="line">yielding a form of run-length encoding (RLE). For instance,</span><br><span class="line">&quot;xababab&quot; could be encoded as</span><br><span class="line"></span><br><span class="line">  &lt;literal: &quot;xab&quot;&gt; &lt;copy: offset=2 length=4&gt;</span><br><span class="line"></span><br><span class="line">Note that since the current Snappy compressor works in 32 kB</span><br><span class="line">blocks and does not do matching across blocks, it will never produce</span><br><span class="line">a bitstream with offsets larger than about 32768. However, the</span><br><span class="line">decompressor should not rely on this, as it may change in the future.</span><br><span class="line"></span><br><span class="line">There are several different kinds of copy elements, depending on</span><br><span class="line">the amount of bytes to be copied (length), and how far back the</span><br><span class="line">data to be copied is (offset).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2.1. Copy with 1-byte offset (01)</span><br><span class="line"></span><br><span class="line">These elements can encode lengths between [4..11] bytes and offsets</span><br><span class="line">between [0..2047] bytes. (len-4) occupies three bits and is stored</span><br><span class="line">in bits [2..4] of the tag byte. The offset occupies 11 bits, of which the</span><br><span class="line">upper three are stored in the upper three bits ([5..7]) of the tag byte,</span><br><span class="line">and the lower eight are stored in a byte following the tag byte.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2.2. Copy with 2-byte offset (10)</span><br><span class="line"></span><br><span class="line">These elements can encode lengths between [1..64] and offsets from</span><br><span class="line">[0..65535]. (len-1) occupies six bits and is stored in the upper</span><br><span class="line">six bits ([2..7]) of the tag byte. The offset is stored as a</span><br><span class="line">little-endian 16-bit integer in the two bytes following the tag byte.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2.3. Copy with 4-byte offset (11)</span><br><span class="line"></span><br><span class="line">These are like the copies with 2-byte offsets (see previous subsection),</span><br><span class="line">except that the offset is stored as a 32-bit integer instead of a</span><br><span class="line">16-bit integer (and thus will occupy four bytes).</span><br></pre></td></tr></table></figure>
<h3 id="compress"><a class="markdownIt-Anchor" href="#compress"></a> Compress</h3>
<ul>
<li>
<p><code>RawCompress</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RawCompress</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* input, <span class="keyword">size_t</span> input_length, <span class="keyword">char</span>* compressed,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">size_t</span>* compressed_length)</span> </span>&#123;</span><br><span class="line">  <span class="function">ByteArraySource <span class="title">reader</span><span class="params">(input, input_length)</span></span>;</span><br><span class="line">  <span class="function">UncheckedByteArraySink <span class="title">writer</span><span class="params">(compressed)</span></span>;</span><br><span class="line">  <span class="built_in">Compress</span>(&amp;reader, &amp;writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute how many bytes were added</span></span><br><span class="line">  *compressed_length = (writer.<span class="built_in">CurrentDestination</span>() - compressed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先根据参数创建<code>reader</code>，<code>writer</code>，然后调用<code>Compress</code>进行压缩，最后计算<code>compressed_length</code>。</p>
<p>下面看一下<code>reader</code>和<code>writer</code>的结构。</p>
</li>
<li>
<p><code>ByteArraySource</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Source is an interface that yields a sequence of bytes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Source</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Source</span>() &#123; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Source</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the number of bytes left to read from the source</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">Available</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Peek at the next flat region of the source.  Does not reposition</span></span><br><span class="line">  <span class="comment">// the source.  The returned region is empty iff Available()==0.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns a pointer to the beginning of the region and store its</span></span><br><span class="line">  <span class="comment">// length in *len.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The returned region is valid until the next call to Skip() or</span></span><br><span class="line">  <span class="comment">// until this object is destroyed, whichever occurs first.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The returned region may be larger than Available() (for example</span></span><br><span class="line">  <span class="comment">// if this ByteSource is a view on a substring of a larger source).</span></span><br><span class="line">  <span class="comment">// The caller is responsible for ensuring that it only reads the</span></span><br><span class="line">  <span class="comment">// Available() bytes.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Peek</span><span class="params">(<span class="keyword">size_t</span>* len)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip the next n bytes.  Invalidates any buffer returned by</span></span><br><span class="line">  <span class="comment">// a previous call to Peek().</span></span><br><span class="line">  <span class="comment">// REQUIRES: Available() &gt;= n</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Skip</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// No copying</span></span><br><span class="line">  <span class="built_in">Source</span>(<span class="keyword">const</span> Source&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Source&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Source implementation that yields the contents of a flat array</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteArraySource</span> :</span> <span class="keyword">public</span> Source &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ByteArraySource</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">size_t</span> n) : <span class="built_in">ptr_</span>(p), <span class="built_in">left_</span>(n) &#123; &#125;</span><br><span class="line">  ~<span class="built_in">ByteArraySource</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">Available</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Peek</span><span class="params">(<span class="keyword">size_t</span>* len)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Skip</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr_;</span><br><span class="line">  <span class="keyword">size_t</span> left_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Available</code>: 表示还有多少个字节剩余。</li>
<li><code>Peek</code>: 返回前面可以窥探到的字节流，并且返回长度。返回的buffer必须持续有效直到<code>Skip</code>。</li>
<li><code>Skip</code>: 告诉Source某个部分的字节流已经不需要被使用了，将这一部分跳过。</li>
</ul>
</li>
<li>
<p><code>UncheckedByteArraySink</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Sink is an interface that consumes a sequence of bytes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sink</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Sink</span>() &#123; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Sink</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append &quot;bytes[0,n-1]&quot; to this.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* bytes, <span class="keyword">size_t</span> n)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns a writable buffer of the specified length for appending.</span></span><br><span class="line">  <span class="comment">// May return a pointer to the caller-owned scratch buffer which</span></span><br><span class="line">  <span class="comment">// must have at least the indicated length.  The returned buffer is</span></span><br><span class="line">  <span class="comment">// only valid until the next operation on this Sink.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// After writing at most &quot;length&quot; bytes, call Append() with the</span></span><br><span class="line">  <span class="comment">// pointer returned from this function and the number of bytes</span></span><br><span class="line">  <span class="comment">// written.  Many Append() implementations will avoid copying</span></span><br><span class="line">  <span class="comment">// bytes if this function returned an internal buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If a non-scratch buffer is returned, the caller may only pass a</span></span><br><span class="line">  <span class="comment">// prefix of it to Append().  That is, it is not correct to pass an</span></span><br><span class="line">  <span class="comment">// interior pointer of the returned array to Append().</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The default implementation always returns the scratch buffer.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">GetAppendBuffer</span><span class="params">(<span class="keyword">size_t</span> length, <span class="keyword">char</span>* scratch)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For higher performance, Sink implementations can provide custom</span></span><br><span class="line">  <span class="comment">// AppendAndTakeOwnership() and GetAppendBufferVariable() methods.</span></span><br><span class="line">  <span class="comment">// These methods can reduce the number of copies done during</span></span><br><span class="line">  <span class="comment">// compression/decompression.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append &quot;bytes[0,n-1] to the sink. Takes ownership of &quot;bytes&quot;</span></span><br><span class="line">  <span class="comment">// and calls the deleter function as (*deleter)(deleter_arg, bytes, n)</span></span><br><span class="line">  <span class="comment">// to free the buffer. deleter function must be non NULL.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The default implementation just calls Append and frees &quot;bytes&quot;.</span></span><br><span class="line">  <span class="comment">// Other implementations may avoid a copy while appending the buffer.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AppendAndTakeOwnership</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">char</span>* bytes, <span class="keyword">size_t</span> n, <span class="keyword">void</span> (*deleter)(<span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">void</span> *deleter_arg)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns a writable buffer for appending and writes the buffer&#x27;s capacity to</span></span><br><span class="line">  <span class="comment">// *allocated_size. Guarantees *allocated_size &gt;= min_size.</span></span><br><span class="line">  <span class="comment">// May return a pointer to the caller-owned scratch buffer which must have</span></span><br><span class="line">  <span class="comment">// scratch_size &gt;= min_size.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The returned buffer is only valid until the next operation</span></span><br><span class="line">  <span class="comment">// on this ByteSink.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// After writing at most *allocated_size bytes, call Append() with the</span></span><br><span class="line">  <span class="comment">// pointer returned from this function and the number of bytes written.</span></span><br><span class="line">  <span class="comment">// Many Append() implementations will avoid copying bytes if this function</span></span><br><span class="line">  <span class="comment">// returned an internal buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If the sink implementation allocates or reallocates an internal buffer,</span></span><br><span class="line">  <span class="comment">// it should use the desired_size_hint if appropriate. If a caller cannot</span></span><br><span class="line">  <span class="comment">// provide a reasonable guess at the desired capacity, it should set</span></span><br><span class="line">  <span class="comment">// desired_size_hint = 0.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If a non-scratch buffer is returned, the caller may only pass</span></span><br><span class="line">  <span class="comment">// a prefix to it to Append(). That is, it is not correct to pass an</span></span><br><span class="line">  <span class="comment">// interior pointer to Append().</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The default implementation always returns the scratch buffer.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">GetAppendBufferVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">size_t</span> min_size, <span class="keyword">size_t</span> desired_size_hint, <span class="keyword">char</span>* scratch,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">size_t</span> scratch_size, <span class="keyword">size_t</span>* allocated_size)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// No copying</span></span><br><span class="line">  <span class="built_in">Sink</span>(<span class="keyword">const</span> Sink&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Sink&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Sink implementation that writes to a flat array without any bound checks.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UncheckedByteArraySink</span> :</span> <span class="keyword">public</span> Sink &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UncheckedByteArraySink</span><span class="params">(<span class="keyword">char</span>* dest)</span> : dest_(dest) &#123;</span> &#125;</span><br><span class="line">  ~<span class="built_in">UncheckedByteArraySink</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">GetAppendBuffer</span><span class="params">(<span class="keyword">size_t</span> len, <span class="keyword">char</span>* scratch)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">GetAppendBufferVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">size_t</span> min_size, <span class="keyword">size_t</span> desired_size_hint, <span class="keyword">char</span>* scratch,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">size_t</span> scratch_size, <span class="keyword">size_t</span>* allocated_size)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AppendAndTakeOwnership</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">char</span>* bytes, <span class="keyword">size_t</span> n, <span class="keyword">void</span> (*deleter)(<span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">void</span> *deleter_arg)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current output pointer so that a caller can see how</span></span><br><span class="line">  <span class="comment">// many bytes were produced.</span></span><br><span class="line">  <span class="comment">// Note: this is not a Sink method.</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">CurrentDestination</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dest_; &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span>* dest_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Append</code>: 将bytes[0,n-1]这个字节流写入。</li>
<li><code>getAppendBuffer</code>: 交出一块length的buffer，这块length的buffer的话必须一直有效直到<code>Append</code>被调用。当然我们也可以直接返回scratch(外围框架分配的内存)。</li>
</ul>
</li>
<li>
<p><code>Compress</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Compress</span><span class="params">(Source* reader, Sink* writer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> N = reader-&gt;<span class="built_in">Available</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> uncompressed_size = N;</span><br><span class="line">  <span class="keyword">char</span> ulength[Varint::kMax32];</span><br><span class="line">  <span class="keyword">char</span>* p = Varint::<span class="built_in">Encode32</span>(ulength, N);</span><br><span class="line">  writer-&gt;<span class="built_in">Append</span>(ulength, p - ulength);</span><br><span class="line">  written += (p - ulength);</span><br><span class="line"></span><br><span class="line">  <span class="function">internal::WorkingMemory <span class="title">wmem</span><span class="params">(N)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Get next block to compress (without copying if possible)</span></span><br><span class="line">    <span class="keyword">size_t</span> fragment_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fragment = reader-&gt;<span class="built_in">Peek</span>(&amp;fragment_size);</span><br><span class="line">    <span class="built_in">assert</span>(fragment_size != <span class="number">0</span>);  <span class="comment">// premature end of input</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> num_to_read = std::<span class="built_in">min</span>(N, kBlockSize);</span><br><span class="line">    <span class="keyword">size_t</span> bytes_read = fragment_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pending_advance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt;= num_to_read) &#123;</span><br><span class="line">      <span class="comment">// Buffer returned by reader is large enough</span></span><br><span class="line">      pending_advance = num_to_read;</span><br><span class="line">      fragment_size = num_to_read;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">char</span>* scratch = wmem.<span class="built_in">GetScratchInput</span>();</span><br><span class="line">      std::<span class="built_in">memcpy</span>(scratch, fragment, bytes_read);</span><br><span class="line">      reader-&gt;<span class="built_in">Skip</span>(bytes_read);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (bytes_read &lt; num_to_read) &#123;</span><br><span class="line">        fragment = reader-&gt;<span class="built_in">Peek</span>(&amp;fragment_size);</span><br><span class="line">        <span class="keyword">size_t</span> n = std::min&lt;<span class="keyword">size_t</span>&gt;(fragment_size, num_to_read - bytes_read);</span><br><span class="line">        std::<span class="built_in">memcpy</span>(scratch + bytes_read, fragment, n);</span><br><span class="line">        bytes_read += n;</span><br><span class="line">        reader-&gt;<span class="built_in">Skip</span>(n);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">assert</span>(bytes_read == num_to_read);</span><br><span class="line">      fragment = scratch;</span><br><span class="line">      fragment_size = num_to_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(fragment_size == num_to_read);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get encoding table for compression</span></span><br><span class="line">    <span class="keyword">int</span> table_size;</span><br><span class="line">    <span class="keyword">uint16_t</span>* table = wmem.<span class="built_in">GetHashTable</span>(num_to_read, &amp;table_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compress input_fragment and append to dest</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_output = <span class="built_in">MaxCompressedLength</span>(num_to_read);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need a scratch buffer for the output, in case the byte sink doesn&#x27;t</span></span><br><span class="line">    <span class="comment">// have room for us directly.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since we encode kBlockSize regions followed by a region</span></span><br><span class="line">    <span class="comment">// which is &lt;= kBlockSize in length, a previously allocated</span></span><br><span class="line">    <span class="comment">// scratch_output[] region is big enough for this iteration.</span></span><br><span class="line">    <span class="keyword">char</span>* dest = writer-&gt;<span class="built_in">GetAppendBuffer</span>(max_output, wmem.<span class="built_in">GetScratchOutput</span>());</span><br><span class="line">    <span class="keyword">char</span>* end = internal::<span class="built_in">CompressFragment</span>(fragment, fragment_size, dest, table,</span><br><span class="line">                                           table_size);</span><br><span class="line">    writer-&gt;<span class="built_in">Append</span>(dest, end - dest);</span><br><span class="line">    written += (end - dest);</span><br><span class="line"></span><br><span class="line">    N -= num_to_read;</span><br><span class="line">    reader-&gt;<span class="built_in">Skip</span>(pending_advance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Report</span>(<span class="string">&quot;snappy_compress&quot;</span>, written, uncompressed_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>头部是原始串长度，使用变长整数方式<code>Encode</code>来编码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">Varint::Encode32</span><span class="params">(<span class="keyword">char</span>* sptr, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(sptr);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v &gt;&gt; <span class="number">7</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((v &gt;&gt; <span class="number">7</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v &gt;&gt; <span class="number">14</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>)) &#123;</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((v &gt;&gt; <span class="number">7</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((v &gt;&gt; <span class="number">14</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v &gt;&gt; <span class="number">21</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((v&gt;&gt;<span class="number">7</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((v&gt;&gt;<span class="number">14</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((v&gt;&gt;<span class="number">21</span>) | B);</span><br><span class="line">    *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v &gt;&gt; <span class="number">28</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取<code>fragment</code>和<code>fragmentsize</code>。</p>
</li>
<li>
<p>调用<code>CompressFragment</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flat array compression that does not emit the &quot;uncompressed length&quot;</span></span><br><span class="line"><span class="comment">// prefix. Compresses &quot;input&quot; string to the &quot;*op&quot; buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;input&quot; is at most &quot;kBlockSize&quot; bytes long.</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;op&quot; points to an array of memory that is at least</span></span><br><span class="line"><span class="comment">// &quot;MaxCompressedLength(input.size())&quot; in size.</span></span><br><span class="line"><span class="comment">// REQUIRES: All elements in &quot;table[0..table_size-1]&quot; are initialized to zero.</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;table_size&quot; is a power of two</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns an &quot;end&quot; pointer into &quot;op&quot; buffer.</span></span><br><span class="line"><span class="comment">// &quot;end - op&quot; is the compressed size of &quot;input&quot;.</span></span><br><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">CompressFragment</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* input, <span class="keyword">size_t</span> input_size, <span class="keyword">char</span>* op,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">uint16_t</span>* table, <span class="keyword">const</span> <span class="keyword">int</span> table_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// &quot;ip&quot; is the input pointer, and &quot;op&quot; is the output pointer.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ip = input;</span><br><span class="line">  <span class="built_in">assert</span>(input_size &lt;= kBlockSize);</span><br><span class="line">  <span class="built_in">assert</span>((table_size &amp; (table_size - <span class="number">1</span>)) == <span class="number">0</span>);  <span class="comment">// table must be power of two</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> mask = table_size - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ip_end = input + input_size;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* base_ip = ip;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> kInputMarginBytes = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_TRUE</span>(input_size &gt;= kInputMarginBytes)) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip_limit = input + input_size - kInputMarginBytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> preload = LittleEndian::<span class="built_in">Load32</span>(ip + <span class="number">1</span>);;) &#123;</span><br><span class="line">      <span class="comment">// Bytes in [next_emit, ip) will be emitted as literal bytes.  Or</span></span><br><span class="line">      <span class="comment">// [next_emit, ip_end) after the main loop.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* next_emit = ip++;</span><br><span class="line">      <span class="keyword">uint64_t</span> data = LittleEndian::<span class="built_in">Load64</span>(ip);</span><br><span class="line">      <span class="comment">// The body of this loop calls EmitLiteral once and then EmitCopy one or</span></span><br><span class="line">      <span class="comment">// more times.  (The exception is that when we&#x27;re close to exhausting</span></span><br><span class="line">      <span class="comment">// the input we goto emit_remainder.)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// In the first iteration of this loop we&#x27;re just starting, so</span></span><br><span class="line">      <span class="comment">// there&#x27;s nothing to copy, so calling EmitLiteral once is</span></span><br><span class="line">      <span class="comment">// necessary.  And we only start a new iteration when the</span></span><br><span class="line">      <span class="comment">// current iteration has determined that a call to EmitLiteral will</span></span><br><span class="line">      <span class="comment">// precede the next call to EmitCopy (if any).</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Step 1: Scan forward in the input looking for a 4-byte-long match.</span></span><br><span class="line">      <span class="comment">// If we get close to exhausting the input then goto emit_remainder.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Heuristic match skipping: If 32 bytes are scanned with no matches</span></span><br><span class="line">      <span class="comment">// found, start looking only at every other byte. If 32 more bytes are</span></span><br><span class="line">      <span class="comment">// scanned (or skipped), look at every third byte, etc.. When a match is</span></span><br><span class="line">      <span class="comment">// found, immediately go back to looking at every byte. This is a small</span></span><br><span class="line">      <span class="comment">// loss (~5% performance, ~0.1% density) for compressible data due to more</span></span><br><span class="line">      <span class="comment">// bookkeeping, but for non-compressible data (such as JPEG) it&#x27;s a huge</span></span><br><span class="line">      <span class="comment">// win since the compressor quickly &quot;realizes&quot; the data is incompressible</span></span><br><span class="line">      <span class="comment">// and doesn&#x27;t bother looking for matches everywhere.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The &quot;skip&quot; variable keeps track of how many bytes there are since the</span></span><br><span class="line">      <span class="comment">// last match; dividing it by 32 (ie. right-shifting by five) gives the</span></span><br><span class="line">      <span class="comment">// number of bytes to move ahead for each iteration.</span></span><br><span class="line">      <span class="keyword">uint32_t</span> skip = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* candidate;</span><br><span class="line">      <span class="keyword">if</span> (ip_limit - ip &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> delta = ip - base_ip;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">4</span> * j + k;</span><br><span class="line">            <span class="comment">// These for-loops are meant to be unrolled. So we can freely</span></span><br><span class="line">            <span class="comment">// special case the first iteration to use the value already</span></span><br><span class="line">            <span class="comment">// loaded in preload.</span></span><br><span class="line">            <span class="keyword">uint32_t</span> dword = i == <span class="number">0</span> ? preload : <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(data);</span><br><span class="line">            <span class="built_in">assert</span>(dword == LittleEndian::<span class="built_in">Load32</span>(ip + i));</span><br><span class="line">            <span class="keyword">uint32_t</span> hash = <span class="built_in">HashBytes</span>(dword, mask);</span><br><span class="line">            candidate = base_ip + table[hash];</span><br><span class="line">            <span class="built_in">assert</span>(candidate &gt;= base_ip);</span><br><span class="line">            <span class="built_in">assert</span>(candidate &lt; ip + i);</span><br><span class="line">            table[hash] = delta + i;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(LittleEndian::<span class="built_in">Load32</span>(candidate) == dword)) &#123;</span><br><span class="line">              *op = LITERAL | (i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">              <span class="built_in">UnalignedCopy128</span>(next_emit, op + <span class="number">1</span>);</span><br><span class="line">              ip += i;</span><br><span class="line">              op = op + i + <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">goto</span> emit_match;</span><br><span class="line">            &#125;</span><br><span class="line">            data &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          data = LittleEndian::<span class="built_in">Load64</span>(ip + <span class="number">4</span> * j + <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ip += <span class="number">16</span>;</span><br><span class="line">        skip += <span class="number">16</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(ip));</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        <span class="keyword">uint32_t</span> bytes_between_hash_lookups = skip &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        skip += bytes_between_hash_lookups;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* next_ip = ip + bytes_between_hash_lookups;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(next_ip &gt; ip_limit)) &#123;</span><br><span class="line">          ip = next_emit;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        <span class="built_in">assert</span>(candidate &gt;= base_ip);</span><br><span class="line">        <span class="built_in">assert</span>(candidate &lt; ip);</span><br><span class="line"></span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(data) ==</span><br><span class="line">                                LittleEndian::<span class="built_in">Load32</span>(candidate))) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data = LittleEndian::<span class="built_in">Load32</span>(next_ip);</span><br><span class="line">        ip = next_ip;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 2: A 4-byte match has been found.  We&#x27;ll later see if more</span></span><br><span class="line">      <span class="comment">// than 4 bytes match.  But, prior to the match, input</span></span><br><span class="line">      <span class="comment">// bytes [next_emit, ip) are unmatched.  Emit them as &quot;literal bytes.&quot;</span></span><br><span class="line">      <span class="built_in">assert</span>(next_emit + <span class="number">16</span> &lt;= ip_end);</span><br><span class="line">      op = EmitLiteral&lt;<span class="comment">/*allow_fast_path=*/</span><span class="literal">true</span>&gt;(op, next_emit, ip - next_emit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 3: Call EmitCopy, and then see if another EmitCopy could</span></span><br><span class="line">      <span class="comment">// be our next move.  Repeat until we find no match for the</span></span><br><span class="line">      <span class="comment">// input immediately after what was consumed by the last EmitCopy call.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// If we exit this loop normally then we need to call EmitLiteral next,</span></span><br><span class="line">      <span class="comment">// though we don&#x27;t yet know how big the literal will be.  We handle that</span></span><br><span class="line">      <span class="comment">// by proceeding to the next iteration of the main loop.  We also can exit</span></span><br><span class="line">      <span class="comment">// this loop via goto if we get close to exhausting the input.</span></span><br><span class="line">    emit_match:</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// We have a 4-byte match at ip, and no need to emit any</span></span><br><span class="line">        <span class="comment">// &quot;literal bytes&quot; prior to ip.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* base = ip;</span><br><span class="line">        std::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">bool</span>&gt; p =</span><br><span class="line">            <span class="built_in">FindMatchLength</span>(candidate + <span class="number">4</span>, ip + <span class="number">4</span>, ip_end, &amp;data);</span><br><span class="line">        <span class="keyword">size_t</span> matched = <span class="number">4</span> + p.first;</span><br><span class="line">        ip += matched;</span><br><span class="line">        <span class="keyword">size_t</span> offset = base - candidate;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span> == <span class="built_in">memcmp</span>(base, candidate, matched));</span><br><span class="line">        <span class="keyword">if</span> (p.second) &#123;</span><br><span class="line">          op = EmitCopy&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">true</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          op = EmitCopy&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">false</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(ip &gt;= ip_limit)) &#123;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Expect 5 bytes to match</span></span><br><span class="line">        <span class="built_in">assert</span>((data &amp; <span class="number">0xFFFFFFFFFF</span>) ==</span><br><span class="line">               (LittleEndian::<span class="built_in">Load64</span>(ip) &amp; <span class="number">0xFFFFFFFFFF</span>));</span><br><span class="line">        <span class="comment">// We are now looking for a 4-byte match again.  We read</span></span><br><span class="line">        <span class="comment">// table[Hash(ip, shift)] for that.  To improve compression,</span></span><br><span class="line">        <span class="comment">// we also update table[Hash(ip - 1, mask)] and table[Hash(ip, mask)].</span></span><br><span class="line">        table[<span class="built_in">HashBytes</span>(LittleEndian::<span class="built_in">Load32</span>(ip - <span class="number">1</span>), mask)] = ip - base_ip - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="comment">// Measurements on the benchmarks have shown the following probabilities</span></span><br><span class="line">        <span class="comment">// for the loop to exit (ie. avg. number of iterations is reciprocal).</span></span><br><span class="line">        <span class="comment">// BM_Flat/6  txt1    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/7  txt2    p = 0.35</span></span><br><span class="line">        <span class="comment">// BM_Flat/8  txt3    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/9  txt3    p = 0.34-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/10 pb      p = 0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/11 gaviota p = 0.1</span></span><br><span class="line">        <span class="comment">// BM_Flat/12 cp      p = 0.5</span></span><br><span class="line">        <span class="comment">// BM_Flat/13 c       p = 0.3</span></span><br><span class="line">      &#125; <span class="keyword">while</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(candidate));</span><br><span class="line">      <span class="comment">// Because the least significant 5 bytes matched, we can utilize data</span></span><br><span class="line">      <span class="comment">// for the next iteration.</span></span><br><span class="line">      preload = data &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">emit_remainder:</span><br><span class="line">  <span class="comment">// Emit the remaining bytes as a literal</span></span><br><span class="line">  <span class="keyword">if</span> (ip &lt; ip_end) &#123;</span><br><span class="line">    op = EmitLiteral&lt;<span class="comment">/*allow_fast_path=*/</span><span class="literal">false</span>&gt;(op, ip, ip_end - ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// end namespace internal</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>核心代码是<code>for (uint32_t preload = LittleEndian::Load32(ip + 1);;)</code>控制的大循环。</p>
</li>
<li>
<p>j和k控制两层for循环，指针每次向后移动1个byte（即内层循环k每次加1，data右移8位），对于当前指针指向的4bytes内容dword，将其放入hashtable中。</p>
</li>
<li>
<p>如果在循环中出现了<code>candidata==dword</code>的情况，则将从next_emit开始的16个bytes作为literal写入op，然后<code>goto emit_match</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(LittleEndian::<span class="built_in">Load32</span>(candidate) == dword)) &#123;</span><br><span class="line">              *op = LITERAL | (i &lt;&lt; <span class="number">2</span>);</span><br><span class="line">              <span class="built_in">UnalignedCopy128</span>(next_emit, op + <span class="number">1</span>);</span><br><span class="line">              ip += i;</span><br><span class="line">              op = op + i + <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">goto</span> emit_match;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>否则，进入下面的while循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(ip));</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        <span class="keyword">uint32_t</span> bytes_between_hash_lookups = skip &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        skip += bytes_between_hash_lookups;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* next_ip = ip + bytes_between_hash_lookups;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(next_ip &gt; ip_limit)) &#123;</span><br><span class="line">          ip = next_emit;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        <span class="built_in">assert</span>(candidate &gt;= base_ip);</span><br><span class="line">        <span class="built_in">assert</span>(candidate &lt; ip);</span><br><span class="line"></span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(data) ==</span><br><span class="line">                                LittleEndian::<span class="built_in">Load32</span>(candidate))) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data = LittleEndian::<span class="built_in">Load32</span>(next_ip);</span><br><span class="line">        ip = next_ip;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这就是注释中提到的启发式搜索，skip右移5位作为检查标准，不超过32bytes逐字节检查，超过32bytes不超过64bytes每两个字节检查一次…以此类推，bytes_between_hash_lookups的含义就是每多少个字节检查一次。最终会出现两种情况，一种是next_ip大于ip_limit，直接将其作为literal。另一种是data等于candidate，break跳出循环。</p>
</li>
<li>
<p>while循环结束后，我们得到了4bytes的match，先将match对应的literal写入op。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(next_emit + <span class="number">16</span> &lt;= ip_end);</span><br><span class="line">op = EmitLiteral&lt;<span class="comment">/*allow_fast_path=*/</span><span class="literal">true</span>&gt;(op, next_emit, ip - next_emit);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后进入<code>emit_match</code>这个label标记的程序段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">emit_match:</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// We have a 4-byte match at ip, and no need to emit any</span></span><br><span class="line">        <span class="comment">// &quot;literal bytes&quot; prior to ip.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* base = ip;</span><br><span class="line">        std::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">bool</span>&gt; p =</span><br><span class="line">            <span class="built_in">FindMatchLength</span>(candidate + <span class="number">4</span>, ip + <span class="number">4</span>, ip_end, &amp;data);</span><br><span class="line">        <span class="keyword">size_t</span> matched = <span class="number">4</span> + p.first;</span><br><span class="line">        ip += matched;</span><br><span class="line">        <span class="keyword">size_t</span> offset = base - candidate;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span> == <span class="built_in">memcmp</span>(base, candidate, matched));</span><br><span class="line">        <span class="keyword">if</span> (p.second) &#123;</span><br><span class="line">          op = EmitCopy&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">true</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          op = EmitCopy&lt;<span class="comment">/*len_less_than_12=*/</span><span class="literal">false</span>&gt;(op, offset, matched);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(ip &gt;= ip_limit)) &#123;</span><br><span class="line">          <span class="keyword">goto</span> emit_remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Expect 5 bytes to match</span></span><br><span class="line">        <span class="built_in">assert</span>((data &amp; <span class="number">0xFFFFFFFFFF</span>) ==</span><br><span class="line">               (LittleEndian::<span class="built_in">Load64</span>(ip) &amp; <span class="number">0xFFFFFFFFFF</span>));</span><br><span class="line">        <span class="comment">// We are now looking for a 4-byte match again.  We read</span></span><br><span class="line">        <span class="comment">// table[Hash(ip, shift)] for that.  To improve compression,</span></span><br><span class="line">        <span class="comment">// we also update table[Hash(ip - 1, mask)] and table[Hash(ip, mask)].</span></span><br><span class="line">        table[<span class="built_in">HashBytes</span>(LittleEndian::<span class="built_in">Load32</span>(ip - <span class="number">1</span>), mask)] = ip - base_ip - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = <span class="built_in">HashBytes</span>(data, mask);</span><br><span class="line">        candidate = base_ip + table[hash];</span><br><span class="line">        table[hash] = ip - base_ip;</span><br><span class="line">        <span class="comment">// Measurements on the benchmarks have shown the following probabilities</span></span><br><span class="line">        <span class="comment">// for the loop to exit (ie. avg. number of iterations is reciprocal).</span></span><br><span class="line">        <span class="comment">// BM_Flat/6  txt1    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/7  txt2    p = 0.35</span></span><br><span class="line">        <span class="comment">// BM_Flat/8  txt3    p = 0.3-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/9  txt3    p = 0.34-0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/10 pb      p = 0.4</span></span><br><span class="line">        <span class="comment">// BM_Flat/11 gaviota p = 0.1</span></span><br><span class="line">        <span class="comment">// BM_Flat/12 cp      p = 0.5</span></span><br><span class="line">        <span class="comment">// BM_Flat/13 c       p = 0.3</span></span><br><span class="line">      &#125; <span class="keyword">while</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(data) == LittleEndian::<span class="built_in">Load32</span>(candidate));</span><br><span class="line">      <span class="comment">// Because the least significant 5 bytes matched, we can utilize data</span></span><br><span class="line">      <span class="comment">// for the next iteration.</span></span><br><span class="line">      preload = data &gt;&gt; <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p><code>FindMatchLength</code>求出最大的match长度，将offset和matched写入op，最后更新hashtable。如果data和candidate不相等，退出循环。</p>
</li>
</ul>
</li>
<li>
<p><code>CompressFragment</code>结束后，回到<code>Compress</code>中，最后通过<code>writer-&gt;Append(dest, end - dest)</code>写入writer。</p>
</li>
</ul>
</li>
</ul>
<h3 id="uncompress"><a class="markdownIt-Anchor" href="#uncompress"></a> Uncompress</h3>
<ul>
<li>
<p><code>RawUncompress</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RawUncompress</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* compressed, <span class="keyword">size_t</span> compressed_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">char</span>* uncompressed)</span> </span>&#123;</span><br><span class="line">  <span class="function">ByteArraySource <span class="title">reader</span><span class="params">(compressed, compressed_length)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RawUncompress</span>(&amp;reader, uncompressed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造ByteArraySource，将reader作为参数调用重载的<code>RawUncompress</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RawUncompress</span><span class="params">(Source* compressed, <span class="keyword">char</span>* uncompressed)</span> </span>&#123;</span><br><span class="line">  <span class="function">SnappyArrayWriter <span class="title">output</span><span class="params">(uncompressed)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InternalUncompress</span>(compressed, &amp;output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造SnappyArrayWriter，将output作为参数调用<code>InternalUncompress</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Writer&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">InternalUncompress</span><span class="params">(Source* r, Writer* writer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Read the uncompressed length from the front of the compressed input</span></span><br><span class="line">  <span class="function">SnappyDecompressor <span class="title">decompressor</span><span class="params">(r)</span></span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> uncompressed_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!decompressor.<span class="built_in">ReadUncompressedLength</span>(&amp;uncompressed_len)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InternalUncompressAllTags</span>(&amp;decompressor, writer, r-&gt;<span class="built_in">Available</span>(),</span><br><span class="line">                                   uncompressed_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过source构造decompressor，获取uncompressed_len，调用<code>InternalUncompressAllTags</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Writer&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">InternalUncompressAllTags</span><span class="params">(SnappyDecompressor* decompressor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Writer* writer, <span class="keyword">uint32_t</span> compressed_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">uint32_t</span> uncompressed_len)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Report</span>(<span class="string">&quot;snappy_uncompress&quot;</span>, compressed_len, uncompressed_len);</span><br><span class="line"></span><br><span class="line">  writer-&gt;<span class="built_in">SetExpectedLength</span>(uncompressed_len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process the entire input</span></span><br><span class="line">  decompressor-&gt;<span class="built_in">DecompressAllTags</span>(writer);</span><br><span class="line">  writer-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">  <span class="keyword">return</span> (decompressor-&gt;<span class="built_in">eof</span>() &amp;&amp; writer-&gt;<span class="built_in">CheckLength</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在writer中设置uncompressed_len，通过decompressor的<code>DecompressAllTags(writer)</code>进行解压。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">DecompressAllTags</span><span class="params">(Writer* writer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = ip_;</span><br><span class="line">    <span class="built_in">ResetLimit</span>(ip);</span><br><span class="line">    <span class="keyword">auto</span> op = writer-&gt;<span class="built_in">GetOutputPtr</span>();</span><br><span class="line">    <span class="comment">// We could have put this refill fragment only at the beginning of the loop.</span></span><br><span class="line">    <span class="comment">// However, duplicating it at the end of each branch gives the compiler more</span></span><br><span class="line">    <span class="comment">// scope to optimize the &lt;ip_limit_ - ip&gt; expression based on the local</span></span><br><span class="line">    <span class="comment">// context, which overall increases speed.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAYBE_REFILL()                                      \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (SNAPPY_PREDICT_FALSE(ip &gt;= ip_limit_min_maxtaglen_)) &#123; \</span></span><br><span class="line"><span class="meta">    ip_ = ip;                                               \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (SNAPPY_PREDICT_FALSE(!RefillTag())) goto exit;       \</span></span><br><span class="line"><span class="meta">    ip = ip_;                                               \</span></span><br><span class="line"><span class="meta">    ResetLimit(ip);                                         \</span></span><br><span class="line"><span class="meta">  &#125;                                                         \</span></span><br><span class="line"><span class="meta">  preload = static_cast<span class="meta-string">&lt;uint8_t&gt;</span>(*ip)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At the start of the for loop below the least significant byte of preload</span></span><br><span class="line">    <span class="comment">// contains the tag.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> preload;</span><br><span class="line">    <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">ptrdiff_t</span> op_limit_min_slop;</span><br><span class="line">        <span class="keyword">auto</span> op_base = writer-&gt;<span class="built_in">GetBase</span>(&amp;op_limit_min_slop);</span><br><span class="line">        <span class="keyword">if</span> (op_base) &#123;</span><br><span class="line">          <span class="keyword">auto</span> res =</span><br><span class="line">              <span class="built_in">DecompressBranchless</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ip),</span><br><span class="line">                                   <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ip_limit_),</span><br><span class="line">                                   op - op_base, op_base, op_limit_min_slop);</span><br><span class="line">          ip = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(res.first);</span><br><span class="line">          op = op_base + res.second;</span><br><span class="line">          <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint8_t</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(preload);</span><br><span class="line">      ip++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ratio of iterations that have LITERAL vs non-LITERAL for different</span></span><br><span class="line">      <span class="comment">// inputs.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// input          LITERAL  NON_LITERAL</span></span><br><span class="line">      <span class="comment">// -----------------------------------</span></span><br><span class="line">      <span class="comment">// html|html4|cp   23%        77%</span></span><br><span class="line">      <span class="comment">// urls            36%        64%</span></span><br><span class="line">      <span class="comment">// jpg             47%        53%</span></span><br><span class="line">      <span class="comment">// pdf             19%        81%</span></span><br><span class="line">      <span class="comment">// txt[1-4]        25%        75%</span></span><br><span class="line">      <span class="comment">// pb              24%        76%</span></span><br><span class="line">      <span class="comment">// bin             24%        76%</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>((c &amp; <span class="number">0x3</span>) == LITERAL)) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> literal_length = (c &gt;&gt; <span class="number">2</span>) + <span class="number">1u</span>;</span><br><span class="line">        <span class="keyword">if</span> (writer-&gt;<span class="built_in">TryFastAppend</span>(ip, ip_limit_ - ip, literal_length, &amp;op)) &#123;</span><br><span class="line">          <span class="built_in">assert</span>(literal_length &lt; <span class="number">61</span>);</span><br><span class="line">          ip += literal_length;</span><br><span class="line">          <span class="comment">// <span class="doctag">NOTE:</span> There is no MAYBE_REFILL() here, as TryFastAppend()</span></span><br><span class="line">          <span class="comment">// will not return true unless there&#x27;s already at least five spare</span></span><br><span class="line">          <span class="comment">// bytes in addition to the literal.</span></span><br><span class="line">          preload = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(*ip);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>(literal_length &gt;= <span class="number">61</span>)) &#123;</span><br><span class="line">          <span class="comment">// Long literal.</span></span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">size_t</span> literal_length_length = literal_length - <span class="number">60</span>;</span><br><span class="line">          literal_length =</span><br><span class="line">              <span class="built_in">ExtractLowBytes</span>(LittleEndian::<span class="built_in">Load32</span>(ip), literal_length_length) +</span><br><span class="line">              <span class="number">1</span>;</span><br><span class="line">          ip += literal_length_length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> avail = ip_limit_ - ip;</span><br><span class="line">        <span class="keyword">while</span> (avail &lt; literal_length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Append</span>(ip, avail, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line">          literal_length -= avail;</span><br><span class="line">          reader_-&gt;<span class="built_in">Skip</span>(peeked_);</span><br><span class="line">          <span class="keyword">size_t</span> n;</span><br><span class="line">          ip = reader_-&gt;<span class="built_in">Peek</span>(&amp;n);</span><br><span class="line">          avail = n;</span><br><span class="line">          peeked_ = avail;</span><br><span class="line">          <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">goto</span> exit;</span><br><span class="line">          ip_limit_ = ip + avail;</span><br><span class="line">          <span class="built_in">ResetLimit</span>(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Append</span>(ip, literal_length, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line">        ip += literal_length;</span><br><span class="line">        <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SNAPPY_PREDICT_FALSE</span>((c &amp; <span class="number">3</span>) == COPY_4_BYTE_OFFSET)) &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">size_t</span> copy_offset = LittleEndian::<span class="built_in">Load32</span>(ip);</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">size_t</span> length = (c &gt;&gt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">          ip += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!writer-&gt;<span class="built_in">AppendFromSelf</span>(copy_offset, length, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">ptrdiff_t</span> entry = kLengthMinusOffset[c];</span><br><span class="line">          preload = LittleEndian::<span class="built_in">Load32</span>(ip);</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">uint32_t</span> trailer = <span class="built_in">ExtractLowBytes</span>(preload, c &amp; <span class="number">3</span>);</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">uint32_t</span> length = entry &amp; <span class="number">0xff</span>;</span><br><span class="line">          <span class="built_in">assert</span>(length &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// copy_offset/256 is encoded in bits 8..10.  By just fetching</span></span><br><span class="line">          <span class="comment">// those bits, we get copy_offset (since the bit-field starts at</span></span><br><span class="line">          <span class="comment">// bit 8).</span></span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">uint32_t</span> copy_offset = trailer - entry + length;</span><br><span class="line">          <span class="keyword">if</span> (!writer-&gt;<span class="built_in">AppendFromSelf</span>(copy_offset, length, &amp;op)) <span class="keyword">goto</span> exit;</span><br><span class="line"></span><br><span class="line">          ip += (c &amp; <span class="number">3</span>);</span><br><span class="line">          <span class="comment">// By using the result of the previous load we reduce the critical</span></span><br><span class="line">          <span class="comment">// dependency chain of ip to 4 cycles.</span></span><br><span class="line">          preload &gt;&gt;= (c &amp; <span class="number">3</span>) * <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">if</span> (ip &lt; ip_limit_min_maxtaglen_) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MAYBE_REFILL</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAYBE_REFILL</span></span><br><span class="line">  exit:</span><br><span class="line">    writer-&gt;<span class="built_in">SetOutputPtr</span>(op);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="pseudocode"><a class="markdownIt-Anchor" href="#pseudocode"></a> Pseudocode</h3>
<p><img src="https://gitee.com/yihengtong/figurebed/raw/master/Embedded/202110202113481.png" alt="" /></p>
<h3 id="performance"><a class="markdownIt-Anchor" href="#performance"></a> Performance</h3>
<p>Snappy is intended to be fast. On a single core of a Core i7 processor in 64-bit mode, it compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more. (These numbers are for the slowest inputs in our benchmark suite; others are much faster.) In our tests, Snappy usually is faster than algorithms in the same class (e.g. LZO, LZF, QuickLZ, etc.) while achieving comparable compression ratios.</p>
<p>Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and other already-compressed data. Similar numbers for zlib in its fastest mode are 2.6-2.8x, 3-7x and 1.0x, respectively. More sophisticated algorithms are capable of achieving yet higher compression rates, although usually at the expense of speed. Of course, compression ratio will vary significantly with the input.</p>
<p>Although Snappy should be fairly portable, it is primarily optimized for 64-bit x86-compatible processors, and may run slower in other environments.<br />
In particular:</p>
<ul>
<li>Snappy uses 64-bit operations in several places to process more data at once than would otherwise be possible.</li>
<li>Snappy assumes unaligned 32 and 64-bit loads and stores are cheap. On some platforms, these must be emulated with single-byte loads and stores, which is much slower.</li>
<li>Snappy assumes little-endian throughout, and needs to byte-swap data in several places if running on a big-endian platform.</li>
</ul>
<p>Experience has shown that even heavily tuned code can be improved. Performance optimizations, whether for 64-bit x86 or other platforms, are of course most welcome; see “Contact”, below.</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/google/snappy">https://github.com/google/snappy</a></li>
<li><a target="_blank" rel="noopener" href="https://dirtysalt.github.io/html/snappy.html">https://dirtysalt.github.io/html/snappy.html</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Snappy Algorithm</p><p><a href="https://tongyiheng.top/2021/10/18/Embedded/snappy/">https://tongyiheng.top/2021/10/18/Embedded/snappy/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>TongYiheng</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-10-18</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-10-20</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i> </a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i> </a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i> </a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/cpp/">cpp, </a><a class="link-muted" rel="tag" href="/tags/RocksDB/">RocksDB, </a><a class="link-muted" rel="tag" href="/tags/compression/">compression </a></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=606d9ca4caff460011c58b12&amp;product=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/14/Embedded/db-bench/"><span class="level-item">RocksDB和db_bench安装与配置</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "nUmwvAMIK3DjqBzyQlGQ429s-gzGzoHsz",
            appKey: "9jYGXFAbgktDDeSOnOKsDbyt",
            
            avatar: "robohash",
            avatarForce: true,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-96x96 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="TongYiheng"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TongYiheng</p><p class="is-size-6 is-block">Trust Your Trust</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>QingDao,China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">Posts</p><div><p class="title">24</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">Categories</p><div><p class="title">11</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">Tags</p><div><p class="title">24</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/tongyiheng" target="_blank" rel="noopener"><i class="fab fa-github"></i>  Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/tongyiheng"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#introduction"><span class="level-left"><span class="level-item">1</span><span class="level-item"> Introduction</span></span></a></li><li><a class="level is-mobile" href="#snappy-in-rocksdb"><span class="level-left"><span class="level-item">2</span><span class="level-item"> Snappy in RocksDB</span></span></a></li><li><a class="level is-mobile" href="#snappy"><span class="level-left"><span class="level-item">3</span><span class="level-item"> Snappy</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#format"><span class="level-left"><span class="level-item">3.1</span><span class="level-item"> Format</span></span></a></li><li><a class="level is-mobile" href="#compress"><span class="level-left"><span class="level-item">3.2</span><span class="level-item"> Compress</span></span></a></li><li><a class="level is-mobile" href="#uncompress"><span class="level-left"><span class="level-item">3.3</span><span class="level-item"> Uncompress</span></span></a></li><li><a class="level is-mobile" href="#pseudocode"><span class="level-left"><span class="level-item">3.4</span><span class="level-item"> Pseudocode</span></span></a></li><li><a class="level is-mobile" href="#performance"><span class="level-left"><span class="level-item">3.5</span><span class="level-item"> Performance</span></span></a></li></ul></li><li><a class="level is-mobile" href="#reference"><span class="level-left"><span class="level-item">4</span><span class="level-item"> Reference</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="TongYiheng&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 TongYiheng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/TongYiheng/TongYiheng.github.io"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Email" href="mailto:yihengtong@outlook.com"><i class="fa fa-envelope"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>